
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>용어집 &#8212; Python 3.6.5 文档</title>
    <link rel="stylesheet" href="_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.6.5 文档 中搜索"
          href="_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="about.html" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="copyright" title="저작권" href="copyright.html" />
    <link rel="next" title="About these documents" href="about.html" />
    <link rel="prev" title="&#34;Why is Python Installed on my Computer?&#34; FAQ" href="faq/installed.html" />
    <link rel="shortcut icon" type="image/png" href="_static/py.png" />
    <link rel="canonical" href="https://docs.python.org/3/glossary.html" />
    
    <script type="text/javascript" src="_static/copybutton.js"></script>
    <script type="text/javascript" src="_static/switchers.js"></script>
    
    
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="일반 색인"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="about.html" title="About these documents"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="faq/installed.html" title="&#34;Why is Python Installed on my Computer?&#34; FAQ"
             accesskey="P">上一页</a> |</li>
        <li><img src="_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh</span>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="index.html">도큐멘테이션 </a> &#187;
        </li>

    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="glossary">
<span id="id1"></span><h1>용어집<a class="headerlink" href="#glossary" title="永久链接至标题">¶</a></h1>
<dl class="glossary docutils">
<dt id="term"><code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code></dt>
<dd>대화형 셸의 기본 파이썬 프롬프트. 인터프리터에서 대화형으로 실행될 수 있는 코드 예에서 자주 볼 수 있다.</dd>
<dt id="term-1"><code class="docutils literal notranslate"><span class="pre">...</span></code></dt>
<dd>들여쓰기 된 코드 블록이나, 쌍을 이루는 구분자 (괄호, 꺾쇠괄호, 중괄호) 안에 코드를 입력할 때 대화형 셸의 기본 파이썬 프롬프트.</dd>
<dt id="term-2to3">2to3</dt>
<dd><p class="first">파이썬 2.x 코드를 파이썬 3.x 코드로 변환하려고 시도하는 도구인데, 소스를 파싱하고 파스 트리를 탐색해서 감지할 수 있는 대부분의 비호환성을 다룬다.</p>
<p class="last">2to3 는 표준 라이브러리에서 <a class="reference internal" href="library/2to3.html#module-lib2to3" title="lib2to3: the 2to3 library"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lib2to3</span></code></a> 로 제공된다; 독립적으로 실행할 수 있는 스크립트는 <code class="file docutils literal notranslate"><span class="pre">Tools/scripts/2to3</span></code> 로 제공된다. <a class="reference internal" href="library/2to3.html#to3-reference"><span class="std std-ref">2to3 - Automated Python 2 to 3 code translation</span></a> 를 보세요.</p>
</dd>
<dt id="term-abstract-base-class">abstract base class (추상 베이스 클래스)</dt>
<dd>추상 베이스 클래스는 <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> 같은 다른 테크닉들이 불편하거나 미묘하게 잘못된 (예를 들어, <a class="reference internal" href="reference/datamodel.html#special-lookup"><span class="std std-ref">매직 메서드</span></a>) 경우, 인터페이스를 정의하는 방법을 제공함으로써 <a class="reference internal" href="#term-duck-typing"><span class="xref std std-term">덕 타이핑</span></a> 을 보완한다. ABC는 가상 서브 클래스를 도입하는데, 클래스를 계승하지 않으면서도 <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 와 <a class="reference internal" href="library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 에 의해 감지될 수 있는 클래스들이다; <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to PEP 3119."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> 모듈 도큐멘테이션을 보세요. 파이썬에는 많은 내장 ABC 들이 따라오는데 다음과 같은 것들이 있다: 자료 구조 (<a class="reference internal" href="library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> 모듈에서), 숫자 (<a class="reference internal" href="library/numbers.html#module-numbers" title="numbers: Numeric abstract base classes (Complex, Real, Integral, etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">numbers</span></code></a> 모듈에서), 스트림 (<a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> 모듈에서), 임포트 파인더와 로더 (<a class="reference internal" href="library/importlib.html#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> 모듈에서). <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to PEP 3119."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> 모듈을 사용해서 자신만의 ABC를 만들 수도 있다.</dd>
<dt id="term-argument">argument (인자)</dt>
<dd><p class="first">함수를 호출할 때 <a class="reference internal" href="#term-function"><span class="xref std std-term">함수</span></a> (또는 <a class="reference internal" href="#term-method"><span class="xref std std-term">메서드</span></a>) 로 전달되는 값. 두 종류의 인자가 있다:</p>
<ul>
<li><p class="first"><em class="dfn">키워드 인자 (keyword argument)</em>: 함수 호출 때 식별자가 앞에 붙은 인자 (예를 들어, <code class="docutils literal notranslate"><span class="pre">name=</span></code>) 또는 <code class="docutils literal notranslate"><span class="pre">**</span></code> 를 앞에 붙인 딕셔너리로 전달되는 인자. 예를 들어, 다음과 같은 <a class="reference internal" href="library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a> 호출에서 <code class="docutils literal notranslate"><span class="pre">3</span></code> 과 <code class="docutils literal notranslate"><span class="pre">5</span></code> 는 모두 키워드 인자다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="n">real</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">imag</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;real&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;imag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
</li>
<li><p class="first"><em class="dfn">위치 인자 (positional argument)</em>: 키워드 인자가 아닌 인자. 위치 인자들은 인자 목록의 처음에 나오거나 <a class="reference internal" href="#term-iterable"><span class="xref std std-term">이터러블</span></a> 의 앞에 <code class="docutils literal notranslate"><span class="pre">*</span></code> 를 붙여 전달할 수 있다. 예를 들어, 다음과 같은 호출에서 <code class="docutils literal notranslate"><span class="pre">3</span></code> 과 <code class="docutils literal notranslate"><span class="pre">5</span></code> 는 모두 위치 인자다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
<p>인자는 함수 바의 이름 붙은 지역 변수에 대입된다. 이 대입에 적용되는 규칙들에 대해서는 <a class="reference internal" href="reference/expressions.html#calls"><span class="std std-ref">호출</span></a> 섹션을 보세요. 문법적으로, 어떤 표현식이건 인자로 사용될 수 있다; 구해진 값이 지역 변수에 대입된다.</p>
<p class="last">용어집의 <a class="reference internal" href="#term-parameter"><span class="xref std std-term">파라미터</span></a> 항목과 FAQ 질문 <a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">인자와 파라미터의 차이</span></a> 와 <span class="target" id="index-59"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0362"><strong>PEP 362</strong></a> 도 보세요.</p>
</dd>
<dt id="term-asynchronous-context-manager">asynchronous context manager (비동기 컨텍스트 매니저)</dt>
<dd><a class="reference internal" href="reference/datamodel.html#object.__aenter__" title="object.__aenter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aenter__()</span></code></a> 와 <a class="reference internal" href="reference/datamodel.html#object.__aexit__" title="object.__aexit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code></a> 메서드를 정의함으로써 <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 문에서 보이는 환경을 제어하는 객체. <span class="target" id="index-60"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 로 도입되었다.</dd>
<dt id="term-asynchronous-generator">asynchronous generator (비동기 제너레이터)</dt>
<dd><p class="first"><a class="reference internal" href="#term-asynchronous-generator-iterator"><span class="xref std std-term">비동기 제너레이터 이터레이터</span></a> 를 돌려주는 함수. <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 로 정의되는 코루틴 함수처럼 보이는데, <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 루프가 사용할 수 있는 일련의 값들을 만드는 <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 표현식을 포함한다는 점이 다르다.</p>
<p>보통 비동기 제너레이터 함수를 가리키지만, 어떤 문맥에서는 <em>비동기 제너레이터 이터레이터</em> 를 가리킨다. 의도하는 의미가 명확하지 않은 경우는, 완전한 용어를 써서 모호함을 없앤다.</p>
<p class="last">비동기 제너레이터 함수는 <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식과, <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 문과, <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 문을 포함할 수 있다.</p>
</dd>
<dt id="term-asynchronous-generator-iterator">asynchronous generator iterator (비동기 제너레이터 이터레이터)</dt>
<dd><p class="first"><a class="reference internal" href="#term-asynchronous-generator"><span class="xref std std-term">비동기 제너레이터</span></a> 함수가 만드는 객체.</p>
<p><a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">비동기 이터레이터</span></a> 인데 <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> 를 호출하면 어웨이터블 객체를 돌려주고, 이것은 다음 <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 표현식 까지 비동기 제너레이터 함수의 바디를 실행한다.</p>
<p class="last">각 <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 는 일시적으로 처리를 중단하고, 그 위치의 (지역 변수들과 대기 중인 try-문들을 포함하는) 실행 상태를 기억한다. <em>비동기 제너레이터 이터레이터</em> 가 <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> 가 돌려주는 또 하나의 어웨이터블로 재개되면, 떠난 곳으로 복귀한다. <span class="target" id="index-61"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 와 <span class="target" id="index-62"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0525"><strong>PEP 525</strong></a> 를 보세요.</p>
</dd>
<dt id="term-asynchronous-iterable">asynchronous iterable (비동기 이터러블)</dt>
<dd><a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 문에서 사용될 수 있는 객체. <a class="reference internal" href="reference/datamodel.html#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> 메서드는 <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">비동기 이터레이터</span></a> 를 돌려줘야 한다. <span class="target" id="index-63"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 로 도입되었다.</dd>
<dt id="term-asynchronous-iterator">asynchronous iterator (비동기 이터레이터)</dt>
<dd><a class="reference internal" href="reference/datamodel.html#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> 와 <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> 메서드를 구현하는 객체. <code class="docutils literal notranslate"><span class="pre">__anext__</span></code> 는 <a class="reference internal" href="#term-awaitable"><span class="xref std std-term">어웨이터블</span></a> 객체를 돌려줘야 한다. <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 는 <a class="reference internal" href="library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 예외가 발생할 때까지 비동기 이터레이터의 <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> 메서드가 돌려주는 어웨이터블을 푼다. <span class="target" id="index-64"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 로 도입되었다.</dd>
<dt id="term-attribute">attribute (어트리뷰트)</dt>
<dd>점표현식을 사용하는 이름으로 참조되는 객체와 결합한 값. 예를 들어, 객체 <em>o</em> 가 어트리뷰트 <em>a</em> 를 가지면, <em>o.a</em> 처럼 참조된다.</dd>
<dt id="term-awaitable">awaitable (어웨이터블)</dt>
<dd><a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식에 사용할 수 있는 객체. <a class="reference internal" href="#term-coroutine"><span class="xref std std-term">코루틴</span></a> 이나 <a class="reference internal" href="reference/datamodel.html#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> 메서드를 가진 객체가 될 수 있다. <span class="target" id="index-65"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 를 보세요.</dd>
<dt id="term-bdfl">BDFL</dt>
<dd>자비로운 종신 독재자 (Benevolent Dictator For Life), 즉 <a class="reference external" href="https://www.python.org/~guido/">Guido van Rossum</a>, 파이썬의 창시자.</dd>
<dt id="term-binary-file">binary file (바이너리 파일)</dt>
<dd><p class="first"><a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체들</span></a> 을 읽고 쓸 수 있는 <a class="reference internal" href="#term-file-object"><span class="xref std std-term">파일 객체</span></a>. 바이너리 파일의 예로는 바이너리 모드 (<code class="docutils literal notranslate"><span class="pre">'rb'</span></code>, <code class="docutils literal notranslate"><span class="pre">'wb'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'rb+'</span></code>) 로 열린 파일, <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin.buffer</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout.buffer</span></code>, <a class="reference internal" href="library/io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> 와 <a class="reference internal" href="library/gzip.html#gzip.GzipFile" title="gzip.GzipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">gzip.GzipFile</span></code></a> 의 인스턴스를 들 수 있다.</p>
<div class="last admonition seealso">
<p class="first admonition-title">参见</p>
<p class="last"><a class="reference internal" href="#term-text-file"><span class="xref std std-term">텍스트 파일</span></a> 은 <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 객체들을 읽고 쓴다.</p>
</div>
</dd>
<dt id="term-bytes-like-object">bytes-like object (바이트열류 객체)</dt>
<dd><p class="first"><a class="reference internal" href="c-api/buffer.html#bufferobjects"><span class="std std-ref">Buffer Protocol</span></a> 를 지원하고 C-<a class="reference internal" href="#term-contiguous"><span class="xref std std-term">연속</span></a> 버퍼를 익스포트 할 수 있다. 여러 공통 <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 객체들은 물론이고 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>, <a class="reference internal" href="library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a> 객체들을 포함한다. 바이트열류 객체들은 바이너리 데이터를 다루는 여러 가지 연산들에 사용될 수 있다; 압축, 바이너리 파일로 저장, 소켓을 통한 전송 같은 것들이 있다.</p>
<p class="last">어떤 연산들은 바이너리 데이터가 가변적일 필요가 있다. 이런 경우에 도큐멘테이션은 종종 &quot;읽고-쓰기 바이트열류 객체&quot;라고 표현한다. 가변 버퍼 객체의 예로는 <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 와 <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 의 <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 가 있다. 다른 연산들은 바이너리 데이터가 불변 객체 (&quot;읽기 전용 바이트열류 객체&quot;)에 저장되도록 요구한다; 이런 것들의 예로는 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 와 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체의 <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 가 있다.</p>
</dd>
<dt id="term-bytecode">bytecode (바이트 코드)</dt>
<dd><p class="first">파이썬 소스 코드는 바이트 코드로 컴파일되는데, CPython 인터프리터에서 파이썬 프로그램의 내부 표현이다. 바이트 코드는 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일에 캐시 되어, 같은 파일을 두 번째 실행할 때 더 빨라지게 만든다 (소스에서 바이트 코드로의 재컴파일을 피할 수 있다). 이 &quot;중간 언어&quot; 는 각 바이트 코드에 대응하는 기계를 실행하는 <a class="reference internal" href="#term-virtual-machine"><span class="xref std std-term">가상 기계</span></a> 에서 실행된다고 말한다. 바이트 코드는 서로 다른 파이썬 가상 기계에서 작동할 것으로 기대하지도, 파이썬 배포 간에 안정적이지도 않다는 것에 주의해야 한다.</p>
<p class="last">바이트 코드 명령어들의 목록은 <a class="reference internal" href="library/dis.html#bytecodes"><span class="std std-ref">dis 모듈</span></a> 도큐멘테이션에 나온다.</p>
</dd>
<dt id="term-class">class (클래스)</dt>
<dd>사용자 정의 객체들을 만들기 위한 주형. 클래스 정의는 보통 클래스의 인스턴스를 대상으로 연산하는 메서드 정의들을 포함한다.</dd>
<dt id="term-coercion">coercion (코어션)</dt>
<dd>같은 형의 두 인자를 수반하는 연산이 일어나는 동안, 한 형의 인스턴스를 다른 형으로 묵시적으로 변환하는 것. 예를 들어, <code class="docutils literal notranslate"><span class="pre">int(3.15)</span></code> 는 실수를 정수 <code class="docutils literal notranslate"><span class="pre">3</span></code> 으로 변환한다. 하지만, <code class="docutils literal notranslate"><span class="pre">3+4.5</span></code> 에서, 각 인자는 다른 형이고 (하나는 int, 다른 하나는 float), 둘을 더하기 전에 같은 형으로 변환해야 한다. 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> 를 일으킨다. 코어션 없이는, 호환되는 형들조차도 프로그래머가 같은 형으로 정규화해주어야 한다, 예를 들어, 그냥 <code class="docutils literal notranslate"><span class="pre">3+4.5</span></code> 하는 대신 <code class="docutils literal notranslate"><span class="pre">float(3)+4.5</span></code>.</dd>
<dt id="term-complex-number">complex number (복소수)</dt>
<dd>익숙한 실수 시스템의 확장인데, 모든 숫자가 실수부와 허수부의 합으로 표현된다. 허수부는 실수에 허수 단위 (<code class="docutils literal notranslate"><span class="pre">-1</span></code> 의 제곱근)를 곱한 것인데, 종종 수학에서는 <code class="docutils literal notranslate"><span class="pre">i</span></code> 로, 공학에서는 <code class="docutils literal notranslate"><span class="pre">j</span></code> 로 표기한다. 파이썬은 후자의 표기법을 쓰는 복소수를 기본 지원한다; 허수부는 <code class="docutils literal notranslate"><span class="pre">j</span></code> 접미사를 붙여서 표기한다, 예를 들어, <code class="docutils literal notranslate"><span class="pre">3+1j</span></code>. <a class="reference internal" href="library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 모듈의 복소수 버전이 필요하면, <a class="reference internal" href="library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a> 를 사용한다. 복소수의 활용은 꽤 수준 높은 수학적 기능이다. 필요하다고 느끼지 못한다면, 거의 확실히 무시해도 좋다.</dd>
<dt id="term-context-manager">context manager (컨텍스트 매니저)</dt>
<dd><a class="reference internal" href="reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 와 <a class="reference internal" href="reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 메서드를 정의함으로써 <a class="reference internal" href="reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문에서 보이는 환경을 제어하는 객체. <span class="target" id="index-66"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a> 로 도입되었다.</dd>
<dt id="term-contiguous">contiguous (연속)</dt>
<dd><p class="first last" id="index-8">버퍼는 정확히 <em>C-연속 (C-contiguous)</em> 이거나 <em>포트란 연속 (Fortran contiguous)</em> 일 때 연속이라고 여겨진다. 영차원 버퍼는 C-연속이면서 포트란 연속이다. 일차원 배열에서, 항목들은 서로에 인접하고, 0에서 시작하는 오름차순 인덱스의 순서대로 메모리에 배치되어야 한다. 다차원 C-연속 배열에서, 메모리 주소의 순서대로 항목들을 방문할 때 마지막 인덱스가 가장 빨리 변한다. 하지만, 포트란 연속 배열에서는, 첫 번째 인덱스가 가장 빨리 변한다.</p>
</dd>
<dt id="term-coroutine">coroutine (코루틴)</dt>
<dd>코루틴은 서브루틴의 더 일반화된 형태다. 서브루틴은 한 지점에서 진입하고 다른 지점에서 탈출한다. 코루틴은 여러 다른 지점에서 진입하고, 탈출하고, 재개할 수 있다. 이것들은 <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 문으로 구현할 수 있다. <span class="target" id="index-67"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 를 보세요.</dd>
<dt id="term-coroutine-function">coroutine function (코루틴 함수)</dt>
<dd><a class="reference internal" href="#term-coroutine"><span class="xref std std-term">코루틴</span></a> 객체를 돌려주는 함수. 코루틴 함수는 <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 문으로 정의될 수 있고, <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 와 <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 와 <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 키워드를 포함할 수 있다. 이것들은 <span class="target" id="index-68"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 에 의해 도입되었다.</dd>
<dt id="term-cpython">CPython</dt>
<dd>파이썬 프로그래밍 언어의 규범적인 구현인데, <a class="reference external" href="https://www.python.org">python.org</a> 에서 배포된다. 이 구현을 Jython 이나 IronPython 과 같은 다른 것들과 구별할 필요가 있을 때 용어 &quot;CPython&quot; 이 사용된다.</dd>
<dt id="term-decorator">decorator (데코레이터)</dt>
<dd><p class="first">다른 함수를 돌려주는 함수인데, 보통 <code class="docutils literal notranslate"><span class="pre">&#64;wrapper</span></code> 문법을 사용한 함수 변환으로 적용된다. 데코레이터의 흔한 예는 <a class="reference internal" href="library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> 과 <a class="reference internal" href="library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a> 다.</p>
<p>데코레이터 문법은 단지 편의 문법일 뿐이다. 다음 두 함수 정의는 의미상으로 동등하다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="last">같은 개념이 클래스에도 존재하지만, 덜 자주 쓰인다. 데코레이터에 대한 더 자세한 내용은 <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">함수 정의</span></a> 와 <a class="reference internal" href="reference/compound_stmts.html#class"><span class="std std-ref">클래스 정의</span></a> 의 도큐멘테이션을 보면 된다.</p>
</dd>
<dt id="term-descriptor">descriptor (디스크립터)</dt>
<dd><p class="first">메서드 <a class="reference internal" href="reference/datamodel.html#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> 이나 <a class="reference internal" href="reference/datamodel.html#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> 이나 <a class="reference internal" href="reference/datamodel.html#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a> 를 정의하는 객체. 클래스 어트리뷰트가 디스크립터일 때, 어트리뷰트 조회는 특별한 연결 작용을 일으킨다. 보통, <em>a.b</em> 를 읽거나, 쓰거나, 삭제하는데 사용할 때, <em>a</em> 의 클래스 딕셔너리에서 <em>b</em> 라고 이름 붙여진 객체를 찾는다. 하지만 <em>b</em> 가 디스크립터면, 해당하는 디스크립터 메서드가 호출된다. 디스크립터를 이해하는 것은 파이썬에 대한 깊은 이해의 열쇠인데, 함수, 메서드, 프라퍼티, 클래스 메서드, 스태틱 메서드, 슈퍼클래스 참조 등의 많은 기능의 기초를 이루고 있기 때문이다.</p>
<p class="last">디스크립터의 메서드들에 대한 자세한 내용은 <a class="reference internal" href="reference/datamodel.html#descriptors"><span class="std std-ref">디스크립터 구현하기</span></a> 에 나온다.</p>
</dd>
<dt id="term-dictionary">dictionary (딕셔너리)</dt>
<dd>임의의 키를 값에 대응시키는 연관 배열 (associative array). 키는 <a class="reference internal" href="reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 와 <a class="reference internal" href="reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 메서드를 갖는 모든 객체가 될 수 있다. 펄에서 해시라고 부른다.</dd>
<dt id="term-dictionary-view">dictionary view (딕셔너리 뷰)</dt>
<dd><a class="reference internal" href="library/stdtypes.html#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.keys()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#dict.values" title="dict.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.values()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#dict.items" title="dict.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.items()</span></code></a> 메서드가 돌려주는 객체들을 딕셔너리 뷰라고 부른다. 이것들은 딕셔너리 항목들에 대한 동적인 뷰를 제공하는데, 딕셔너리가 변경될 때, 뷰가 이 변화를 반영한다는 뜻이다. 딕셔너리 뷰를 완전한 리스트로 바꾸려면 <code class="docutils literal notranslate"><span class="pre">list(dictview)</span></code> 를 사용하면 된다. <a class="reference internal" href="library/stdtypes.html#dict-views"><span class="std std-ref">Dictionary view objects</span></a> 를 보세요.</dd>
<dt id="term-docstring">docstring (독스트링)</dt>
<dd>클래스, 함수, 모듈에서 첫 번째 표현식으로 나타나는 문자열 리터럴. 스위트가 실행될 때는 무시되지만, 컴파일러에 의해 인지되어 둘러싼 클래스, 함수, 모듈의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 어트리뷰트로 삽입된다. 인트로스팩션을 통해 사용할 수 있으므로, 객체의 도큐멘테이션을 위한 규범적인 장소다.</dd>
<dt id="term-duck-typing">duck-typing (덕 타이핑)</dt>
<dd>올바른 인터페이스를 가졌는지 판단하는데 객체의 형을 보지 않는 프로그래밍 스타일; 대신, 단순히 메서드나 어트리뷰트가 호출되거나 사용된다 (&quot;오리처럼 보이고 오리처럼 꽥꽥댄다면, 그것은 오리다.&quot;) 특정한 형 대신에 인터페이스를 강조함으로써, 잘 설계된 코드는 다형적인 치환을 허락함으로써 유연성을 개선할 수 있다. 덕 타이핑은 <a class="reference internal" href="library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 이나 <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 을 사용한 검사를 피한다. (하지만, 덕 타이핑이 <a class="reference internal" href="#term-abstract-base-class"><span class="xref std std-term">추상 베이스 클래스</span></a> 로 보완될 수 있음에 유의해야 한다.) 대신에, <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> 검사나 <a class="reference internal" href="#term-eafp"><span class="xref std std-term">EAFP</span></a> 프로그래밍을 쓴다.</dd>
<dt id="term-eafp">EAFP</dt>
<dd>허락보다는 용서를 구하기가 쉽다 (Easier to ask for forgiveness than permission). 이 흔히 볼 수 있는 파이썬 코딩 스타일은, 올바른 키나 어트리뷰트의 존재를 가정하고, 그 가정이 틀리면 예외를 잡는다. 이 깔끔하고 빠른 스타일은 많은 <a class="reference internal" href="reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 와 <a class="reference internal" href="reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 문의 존재로 특징지어진다. 이 테크닉은 C와 같은 다른 많은 언어에서 자주 사용되는 <a class="reference internal" href="#term-lbyl"><span class="xref std std-term">LBYL</span></a> 스타일과 대비된다.</dd>
<dt id="term-expression">expression (표현식)</dt>
<dd>어떤 값으로 구해질 수 있는 문법적인 조각. 다른 말로 표현하면, 표현식은 리터럴, 이름, 어트리뷰트 액세스, 연산자, 함수들과 같은 값을 돌려주는 표현 요소들을 쌓아 올린 것이다. 다른 많은 언어와 대조적으로, 모든 언어 구성물들이 표현식인 것은 아니다. <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 처럼, 표현식으로 사용할 수 없는 <a class="reference internal" href="#term-statement"><span class="xref std std-term">문장</span></a> 들이 있다. 대입 또한 문장이고, 표현식이 아니다.</dd>
<dt id="term-extension-module">extension module (확장 모듈)</dt>
<dd>C 나 C++ 로 작성된 모듈인데, 파이썬의 C API를 사용해서 핵심이나 사용자 코드와 상호 작용한다.</dd>
<dt id="term-f-string">f-string (f-문자열)</dt>
<dd><code class="docutils literal notranslate"><span class="pre">'f'</span></code> 나 <code class="docutils literal notranslate"><span class="pre">'F'</span></code> 를 앞에 붙인 문자열 리터럴들을 흔히 &quot;f-문자열&quot;이라고 부르는데, <a class="reference internal" href="reference/lexical_analysis.html#f-strings"><span class="std std-ref">포맷 문자열 리터럴</span></a> 의 줄임말이다. <span class="target" id="index-69"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0498"><strong>PEP 498</strong></a> 을 보세요.</dd>
<dt id="term-file-object">file object (파일 객체)</dt>
<dd><p class="first">하부 자원에 대해 파일 지향적 API (<code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> 나 <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> 같은 메서드들) 를 드러내는 객체. 만들어진 방법에 따라, 파일 객체는 실제 디스크 상의 파일이나 다른 저장장치나 통신 장치 (예를 들어, 표준 입출력, 인-메모리 버퍼, 소켓, 파이프, 등등)에 대한 액세스를 중계할 수 있다. 파일 객체는 <em class="dfn">파일류 객체 (file-like objects)</em> 나 <em class="dfn">스트림 (streams)</em> 이라고도 불린다.</p>
<p class="last">실제로는 세 부류의 파일 객체들이 있다. 날(raw) <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">바이너리 파일</span></a>, 버퍼드(buffered) <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">바이너리 파일</span></a>, <a class="reference internal" href="#term-text-file"><span class="xref std std-term">텍스트 파일</span></a>. 이들의 인터페이스는 <a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> 모듈에서 정의된다. 파일 객체를 만드는 규범적인 방법은 <a class="reference internal" href="library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 함수를 쓰는 것이다.</p>
</dd>
<dt id="term-file-like-object">file-like object (파일류 객체)</dt>
<dd><a class="reference internal" href="#term-file-object"><span class="xref std std-term">파일 객체</span></a> 의 비슷한 말.</dd>
<dt id="term-finder">finder (파인더)</dt>
<dd><p class="first">임포트될 모듈을 위한 <a class="reference internal" href="#term-loader"><span class="xref std std-term">로더</span></a> 를 찾으려고 시도하는 객체.</p>
<p>파이썬 3.3. 이후로, 두 종류의 파인더가 있다: <a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 와 함께 사용하는 <a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">메타 경로 파인더</span></a> 와 <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> 과 함께 사용하는 <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a>.</p>
<p class="last">더 자세한 내용은 <span class="target" id="index-70"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>, <span class="target" id="index-71"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a>, <span class="target" id="index-72"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0451"><strong>PEP 451</strong></a> 에 나온다.</p>
</dd>
<dt id="term-floor-division">floor division (정수 나눗셈)</dt>
<dd>가장 가까운 정수로 내림하는 수학적 나눗셈. 정수 나눗셈 연산자는 <code class="docutils literal notranslate"><span class="pre">//</span></code> 다. 예를 들어, 표현식 <code class="docutils literal notranslate"><span class="pre">11</span> <span class="pre">//</span> <span class="pre">4</span></code> 의 값은 <code class="docutils literal notranslate"><span class="pre">2</span></code> 가 되지만, 실수 나눗셈은 <code class="docutils literal notranslate"><span class="pre">2.75</span></code> 를 돌려준다. <code class="docutils literal notranslate"><span class="pre">(-11)</span> <span class="pre">//</span> <span class="pre">4</span></code> 가 <code class="docutils literal notranslate"><span class="pre">-2.75</span></code> 를 <em>내림</em> 한 <code class="docutils literal notranslate"><span class="pre">-3</span></code> 이 됨에 유의해야 한다. <span class="target" id="index-73"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0238"><strong>PEP 238</strong></a> 를 보세요.</dd>
<dt id="term-function">function (함수)</dt>
<dd>호출자에게 어떤 값을 돌려주는 일련의 문장들. 없거나 그 이상의 <a class="reference internal" href="#term-argument"><span class="xref std std-term">인자</span></a> 가 전달될 수 있는데, 바디의 실행에 사용될 수 있다. <a class="reference internal" href="#term-parameter"><span class="xref std std-term">파라미터</span></a> 와 <a class="reference internal" href="#term-method"><span class="xref std std-term">메서드</span></a> 와 <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">함수 정의</span></a> 섹션도 보세요.</dd>
<dt id="term-function-annotation">function annotation (함수 어노테이션)</dt>
<dd><p class="first">함수 파라미터나 반환 값에 결합한 임의의 메타데이터 값. 문법은 섹션 <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">함수 정의</span></a> 에서 설명한다. 어노테이션은 함수 객체의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> 특수 어트리뷰트를 통해 액세스 될 수 있다.</p>
<p class="last">파이썬 자체는 함수 어노테이션에 어떤 특별한 의미도 부여하지 않는다. 제삼자 라이브러리나 도구들에 의해 해석되는 것이 목적이다. <span class="target" id="index-74"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3107"><strong>PEP 3107</strong></a> 은 몇 가지 잠재적인 사용에 관해 기술하고 있다.</p>
</dd>
<dt id="term-future">__future__</dt>
<dd><p class="first">프로그래머가 현재 인터프리터와 호환되지 않는 새 언어 기능들을 활성화할 수 있도록 하는 가상 모듈.</p>
<p><a class="reference internal" href="library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a> 모듈을 임포트하고 그 변수들의 값들을 구해서, 새 기능이 언제 처음으로 언어에 추가되었고, 언제부터 그것이 기본이 되는지 볼 수 있다:</p>
<div class="last highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">__future__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__future__</span><span class="o">.</span><span class="n">division</span>
<span class="go">_Feature((2, 2, 0, &#39;alpha&#39;, 2), (3, 0, 0, &#39;alpha&#39;, 0), 8192)</span>
</pre></div>
</div>
</dd>
<dt id="term-garbage-collection">garbage collection (가비지 수거)</dt>
<dd>The process of freeing memory when it is not used anymore.  Python
performs garbage collection via reference counting and a cyclic garbage
collector that is able to detect and break reference cycles.  The
garbage collector can be controlled using the <a class="reference internal" href="library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> module.</dd>
<dt id="index-17"><span id="term-generator"></span>generator (제너레이터)</dt>
<dd><p class="first"><a class="reference internal" href="#term-generator-iterator"><span class="xref std std-term">제너레이터 이터레이터</span></a> 를 돌려주는 함수. 일반 함수처럼 보이는데, 일련의 값들을 만드는 <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 표현식을 포함한다는 점이 다르다. 이 값들은 for-루프로 사용하거나 <a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 함수로 한 번에 하나씩 꺼낼 수 있다.</p>
<p class="last">보통 제너레이터 함수를 가리키지만, 어떤 문맥에서는 <em>제너레이터 이터레이터</em> 를 가리킨다. 의도하는 의미가 명확하지 않은 경우는, 완전한 용어를 써서 모호함을 없앤다.</p>
</dd>
<dt id="term-generator-iterator">generator iterator (제너레이터 이터레이터)</dt>
<dd><p class="first"><a class="reference internal" href="#term-generator"><span class="xref std std-term">제너레이터</span></a> 함수가 만드는 객체.</p>
<p class="last">각 <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 는 일시적으로 처리를 중단하고, 그 위치의 (지역 변수들과 대기 중인 try-문들을 포함하는) 실행 상태를 기억한다. <em>제너레이터 이터레이터</em> 가 재개되면, 떠난 곳으로 복귀한다 (호출마다 새로 시작하는 함수와 대비된다).</p>
</dd>
<dt id="index-18"><span id="term-generator-expression"></span>generator expression (제너레이터 표현식)</dt>
<dd><p class="first">이터레이터를 돌려주는 표현식. 루프 변수와 범위를 정의하는 <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 표현식과 생략 가능한 <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 표현식이 뒤에 붙는 일반 표현식 처럼 보인다. 결합한 표현식은 둘러싼 함수를 위한 값들을 만들어낸다:</p>
<div class="last highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>         <span class="c1"># sum of squares 0, 1, 4, ... 81</span>
<span class="go">285</span>
</pre></div>
</div>
</dd>
<dt id="term-generic-function">generic function (제네릭 함수)</dt>
<dd><p class="first">같은 연산을 서로 다른 형들에 대해 구현한 여러 함수로 구성된 함수. 호출 때 어떤 구현이 사용될지는 디스패치 알고리즘에 의해 결정된다.</p>
<p class="last"><a class="reference internal" href="#term-single-dispatch"><span class="xref std std-term">싱글 디스패치</span></a> 용어집 항목과 <a class="reference internal" href="library/functools.html#functools.singledispatch" title="functools.singledispatch"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.singledispatch()</span></code></a> 데코레이터와 <span class="target" id="index-75"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0443"><strong>PEP 443</strong></a> 도 보세요.</p>
</dd>
<dt id="term-gil">GIL</dt>
<dd><a class="reference internal" href="#term-global-interpreter-lock"><span class="xref std std-term">전역 인터프리터 록</span></a> 을 보세요.</dd>
<dt id="term-global-interpreter-lock">global interpreter lock (전역 인터프리터 록)</dt>
<dd><p class="first">한 번에 오직 하나의 스레드가 파이썬 <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">바이트 코드</span></a> 를 실행하도록 보장하기 위해 <a class="reference internal" href="#term-cpython"><span class="xref std std-term">CPython</span></a> 인터프리터가 사용하는 메커니즘. (<a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 와 같은 중요한 내장형들을 포함하는) 객체 모델이 묵시적으로 동시 액세스에 대해 안전하도록 만들어서 CPython 구현을 단순하게 만든다. 인터프리터 전체를 로킹하는 것은 인터프리터를 다중스레드화하기 쉽게 만드는 대신, 다중 프로세서 기계가 제공하는 병렬성의 많은 부분을 희생한다.</p>
<p>하지만, 어떤 확장 모듈들은, 표준이나 제삼자 모두, 압축이나 해싱 같은 계산 집약적인 작업을 수행할 때는 GIL 을 반납하도록 설계되었다. 또한, I/O를 할 때는 항상 GIL 을 반납한다.</p>
<p class="last">(훨씬 더 미세하게 공유 데이터를 로킹하는) &quot;스레드에 자유로운(free-threaded)&quot; 인터프리터를 만들고자 하는 과거의 노력은 성공적이지 못했는데, 흔한 단일 프로세서 경우의 성능 저하가 심하기 때문이다. 이 성능 이슈를 극복하는 것은 구현을 훨씬 복잡하게 만들어서 유지 비용이 더 들어갈 것으로 여겨지고 있다.</p>
</dd>
<dt id="term-hashable">hashable (해시 가능)</dt>
<dd><p class="first">객체가 일생 그 값이 변하지 않는 해시값을 갖고 (<a class="reference internal" href="reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드가 필요하다), 다른 객체와 비교될 수 있으면 (<a class="reference internal" href="reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 메서드가 필요하다), <em>해시 가능</em> 하다고 한다. 같다고 비교되는 해시 가능한 객체들의 해시값은 같아야 한다.</p>
<p>해시 가능성은 객체를 딕셔너리의 키나 집합의 멤버로 사용할 수 있게 하는데, 이 자료 구조들이 내부적으로 해시값을 사용하기 때문이다.</p>
<p class="last">모든 파이썬의 불변 내장 객체들은 해시 가능하다. (리스트나 딕셔너리 같은) 가변 컨테이너들은 그렇지 않다. 사용자 정의 클래스의 인스턴스 객체들은 기본적으로 해시 가능하다. (자기 자신을 제외하고는) 모두 다르다고 비교되고, 해시값은 <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> 로 부터 만들어진다.</p>
</dd>
<dt id="term-idle">IDLE</dt>
<dd>파이썬을 위한 통합 개발 환경 (Integrated Development Environment). IDLE은 파이썬의 표준 배포판에 따라오는 기초적인 편집기와 인터프리터 환경이다.</dd>
<dt id="term-immutable">immutable (불변)</dt>
<dd>고정된 값을 갖는 객체. 불변 객체는 숫자, 문자열, 튜플을 포함한다. 이런 객체들은 변경될 수 없다. 새 값을 저장하려면 새 객체를 만들어야 한다. 변하지 않는 해시값이 있어야 하는 곳에서 중요한 역할을 한다, 예를 들어, 딕셔너리의 키.</dd>
<dt id="term-import-path">import path (임포트 경로)</dt>
<dd><a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">경로 기반 파인더</span></a> 가 임포트할 모듈을 찾기 위해 검색하는 장소들 (또는 <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">경로 엔트리</span></a>) 의 목록. 임포트하는 동안, 이 장소들의 목록은 보통 <a class="reference internal" href="library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 로부터 온다, 하지만 서브 패키지의 경우 부모 패키지의 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트로부터 올 수도 있다.</dd>
<dt id="term-importing">importing (임포팅)</dt>
<dd>한 모듈의 파이썬 코드가 다른 모듈의 파이썬 코드에서 사용될 수 있도록 하는 절차.</dd>
<dt id="term-importer">importer (임포터)</dt>
<dd>모듈을 찾기도 하고 로드 하기도 하는 객체; 동시에 <a class="reference internal" href="#term-finder"><span class="xref std std-term">파인더</span></a> 이자 <a class="reference internal" href="#term-loader"><span class="xref std std-term">로더</span></a> 객체다.</dd>
<dt id="term-interactive">interactive (대화형)</dt>
<dd>파이썬은 대화형 인터프리터를 갖고 있는데, 인터프리터 프롬프트에서 문장과 표현식을 입력할 수 있고, 즉각 실행된 결과를 볼 수 있다는 뜻이다. 인자 없이 단지 <code class="docutils literal notranslate"><span class="pre">python</span></code> 을 실행하라 (컴퓨터의 주메뉴에서 선택하는 것도 가능할 수 있다). 새 아이디어를 검사하거나 모듈과 패키지를 들여다보는 매우 강력한 방법이다 (<code class="docutils literal notranslate"><span class="pre">help(x)</span></code> 를 기억하세요).</dd>
<dt id="term-interpreted">interpreted (인터프리티드)</dt>
<dd>바이트 코드 컴파일러의 존재 때문에 그 구분이 흐릿해지기는 하지만, 파이썬은 컴파일 언어가 아니라 인터프리터 언어다. 이것은 명시적으로 실행 파일을 만들지 않고도, 소스 파일을 직접 실행할 수 있다는 뜻이다. 그 프로그램이 좀 더 천천히 실행되기는 하지만, 인터프리터 언어는 보통 컴파일 언어보다 짧은 개발/디버깅 주기를 갖는다. <a class="reference internal" href="#term-interactive"><span class="xref std std-term">대화형</span></a> 도 보세요.</dd>
<dt id="term-interpreter-shutdown">interpreter shutdown (인터프리터 종료)</dt>
<dd><p class="first">종료하라는 요청을 받을 때, 파이썬 인터프리터는 특별한 시기에 진입하는데, 모듈이나 여러 가지 중요한 내부 구조들과 같은 모든 할당된 자원들을 단계적으로 반납한다. 또한, <a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">가비지 수거기</span></a> 를 여러 번 호출한다. 사용자 정의 파괴자나 weakref 콜백에 있는 코드들의 실행을 시작시킬 수 있다. 종료 시기 동안 실행되는 코드는 다양한 예외들을 만날 수 있는데, 그것이 의존하는 자원들이 더 기능하지 않을 수 있기 때문이다 (흔한 예는 라이브러리 모듈이나 경고 장치들이다).</p>
<p class="last">인터프리터 종료의 주된 원인은 실행되는 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 모듈이나 스크립트가 실행을 끝내는 것이다.</p>
</dd>
<dt id="term-iterable">iterable (이터러블)</dt>
<dd><p class="first">멤버들을 한 번에 하나씩 돌려줄 수 있는 객체. 이터러블의 예로는 모든 (<a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 같은) 시퀀스 형들, <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 같은 몇몇 비시퀀스 형들, <a class="reference internal" href="#term-file-object"><span class="xref std std-term">파일 객체들</span></a>, <a class="reference internal" href="reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 나 <a class="reference internal" href="#term-sequence"><span class="xref std std-term">시퀀스</span></a> 개념을 구현하는 <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 메서드를 써서 정의한 모든 클래스의 객체들이 있다.</p>
<p class="last">이터러블은 <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 루프에 사용될 수 있고, 시퀀스를 필요로 하는 다른 많은 곳 (<a class="reference internal" href="library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a>, <a class="reference internal" href="library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a>, ...) 에 사용될 수 있다. 이터러블 객체가 내장 함수 <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 에 인자로 전달되면, 그 객체의 이터레이터를 돌려준다. 이 이터레이터는 값들의 집합을 한 번 거치는 동안 유효하다. 이터러블을 사용할 때, 보통은 <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 를 호출하거나, 이터레이터 객체를 직접 다룰 필요는 없다. <code class="docutils literal notranslate"><span class="pre">for</span></code> 문은 이것들을 여러분을 대신해서 자동으로 해주는데, 루프를 도는 동안 이터레이터를 잡아둘 이름 없는 변수를 만든다. <a class="reference internal" href="#term-iterator"><span class="xref std std-term">이터레이터</span></a>, <a class="reference internal" href="#term-sequence"><span class="xref std std-term">시퀀스</span></a>, <a class="reference internal" href="#term-generator"><span class="xref std std-term">제너레이터</span></a> 도 보세요.</p>
</dd>
<dt id="term-iterator">iterator (이터레이터)</dt>
<dd><p class="first">데이터의 스트림을 표현하는 객체. 이터레이터의 <a class="reference internal" href="library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 메서드를 반복적으로 호출하면 (또는 내장 함수 <a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 로 전달하면) 스트림에 있는 항목들을 차례대로 돌려준다. 더 이상의 데이터가 없을 때는 대신 <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 예외를 일으킨다. 이 지점에서, 이터레이터 객체는 소진되고, 이후의 모든 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code> 메서드 호출은 <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 예외를 다시 일으키기만 한다. 이터레이터는 이터레이터 객체 자신을 돌려주는 <a class="reference internal" href="reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 메서드를 가질 것이 요구되기 때문에, 이터레이터는 이터러블이기도 하고 다른 이터러블들을 받아들이는 대부분의 곳에서 사용될 수 있다. 중요한 예외는 여러 번의 이터레이션을 시도하는 코드다. (<a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 같은) 컨테이너 객체는 <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 함수로 전달하거나 <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 루프에 사용할 때마다 새 이터레이터를 만든다. 이런 것을 이터레이터에 대해서 수행하려고 하면, 지난 이터레이션에 사용된 이미 소진된 이터레이터를 돌려줘서, 빈 컨테이너처럼 보이게 만든다.</p>
<p class="last"><a class="reference internal" href="library/stdtypes.html#typeiter"><span class="std std-ref">Iterator Types</span></a> 에 더 자세한 내용이 있다.</p>
</dd>
<dt id="term-key-function">key function (키 함수)</dt>
<dd><p class="first">키 함수 또는 콜레이션(collation) 함수는 정렬(sorting)이나 배열(ordering)에 사용되는 값을 돌려주는 콜러블이다. 예를 들어, <a class="reference internal" href="library/locale.html#locale.strxfrm" title="locale.strxfrm"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.strxfrm()</span></code></a> 은 로케일 특정 방식을 따르는 정렬 키를 만드는 데 사용된다.</p>
<p>파이썬의 많은 도구가 요소들이 어떻게 순서 지어지고 묶이는지를 제어하기 위해 키 함수를 받아들인다. 이런 것들에는 <a class="reference internal" href="library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.merge" title="heapq.merge"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.merge()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.nsmallest" title="heapq.nsmallest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nsmallest()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.nlargest" title="heapq.nlargest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nlargest()</span></code></a>, <a class="reference internal" href="library/itertools.html#itertools.groupby" title="itertools.groupby"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.groupby()</span></code></a> 이 있다.</p>
<p class="last">키 함수를 만드는 데는 여러 방법이 있다. 예를 들어, <a class="reference internal" href="library/stdtypes.html#str.lower" title="str.lower"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.lower()</span></code></a> 메서드는 케이스 구분 없는 정렬을 위한 키 함수로 사용될 수 있다. 대안적으로, 키 함수는 <a class="reference internal" href="reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 표현식으로 만들 수도 있는데, 이런 식이다: <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">r:</span> <span class="pre">(r[0],</span> <span class="pre">r[2])</span></code>. 또한, <a class="reference internal" href="library/operator.html#module-operator" title="operator: Functions corresponding to the standard operators."><code class="xref py py-mod docutils literal notranslate"><span class="pre">operator</span></code></a> 모듈은 세 개의 키 함수 생성자를 제공한다: <a class="reference internal" href="library/operator.html#operator.attrgetter" title="operator.attrgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">attrgetter()</span></code></a>, <a class="reference internal" href="library/operator.html#operator.itemgetter" title="operator.itemgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">itemgetter()</span></code></a>, <a class="reference internal" href="library/operator.html#operator.methodcaller" title="operator.methodcaller"><code class="xref py py-func docutils literal notranslate"><span class="pre">methodcaller()</span></code></a>. 키 함수를 만들고 사용하는 법에 대한 예로 <a class="reference internal" href="howto/sorting.html#sortinghowto"><span class="std std-ref">Sorting HOW TO</span></a> 를 보세요.</p>
</dd>
<dt id="term-keyword-argument">keyword argument (키워드 인자)</dt>
<dd><a class="reference internal" href="#term-argument"><span class="xref std std-term">인자</span></a> 를 보세요.</dd>
<dt id="term-lambda">lambda (람다)</dt>
<dd>호출될 때 값이 구해지는 하나의 <a class="reference internal" href="#term-expression"><span class="xref std std-term">표현식</span></a> 으로 구성된 이름 없는 인라인 함수. 람다 함수를 만드는 문법은 <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">[arguments]:</span> <span class="pre">expression</span></code> 이다.</dd>
<dt id="term-lbyl">LBYL</dt>
<dd><p class="first">뛰기 전에 보라 (Look before you leap). 이 코딩 스타일은 호출이나 조회를 하기 전에 명시적으로 사전 조건들을 검사한다. 이 스타일은 <a class="reference internal" href="#term-eafp"><span class="xref std std-term">EAFP</span></a> 접근법과 대비되고, 많은 <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 문의 존재로 특징지어진다.</p>
<p class="last">다중 스레드 환경에서, LBYL 접근법은 &quot;보기&quot;와 &quot;뛰기&quot; 간에 경쟁 조건을 만들게 될 위험이 있다. 예를 들어, 코드 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">mapping:</span> <span class="pre">return</span> <span class="pre">mapping[key]</span></code> 는 검사 후에, 하지만 조회 전에, 다른 스레드가 <em>key</em> 를 <em>mapping</em> 에서 제거하면 실패할 수 있다. 이런 이슈는 록이나 EAFP 접근법을 사용함으로써 해결될 수 있다.</p>
</dd>
<dt id="term-list">list (리스트)</dt>
<dd>내장 파이썬 <a class="reference internal" href="#term-sequence"><span class="xref std std-term">시퀀스</span></a>. 그 이름에도 불구하고, 원소에 대한 액세스가 O(1)이기 때문에, 연결 리스트(linked list)보다는 다른 언어의 배열과 유사하다.</dd>
<dt id="term-list-comprehension">list comprehension (리스트 컴프리헨션)</dt>
<dd>시퀀스의 요소들 전부 또는 일부를 처리하고 그 결과를 리스트로 돌려주는 간결한 방법. <code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">['{:#04x}'.format(x)</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(256)</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0]</span></code> 는 0에서 255 사이에 있는 짝수들의 16진수 (0x..) 들을 포함하는 문자열의 리스트를 만든다. <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 절은 생략할 수 있다. 생략하면, <code class="docutils literal notranslate"><span class="pre">range(256)</span></code> 에 있는 모든 요소가 처리된다.</dd>
<dt id="term-loader">loader (로더)</dt>
<dd>모듈을 로드하는 객체. <code class="xref py py-meth docutils literal notranslate"><span class="pre">load_module()</span></code> 이라는 이름의 메서드를 정의해야 한다. 로더는 보통 <a class="reference internal" href="#term-finder"><span class="xref std std-term">파인더</span></a> 가 돌려준다. 자세한 내용은 <span class="target" id="index-76"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> 를, <a class="reference internal" href="#term-abstract-base-class"><span class="xref std std-term">추상 베이스 클래스</span></a> 는 <a class="reference internal" href="library/importlib.html#importlib.abc.Loader" title="importlib.abc.Loader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.Loader</span></code></a> 를 보세요.</dd>
<dt id="term-mapping">mapping (매핑)</dt>
<dd>임의의 키 조회를 지원하고 <a class="reference internal" href="library/collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a> 이나 <a class="reference internal" href="library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></a> <a class="reference internal" href="library/collections.abc.html#collections-abstract-base-classes"><span class="std std-ref">추상 베이스 클래스</span></a> 에 지정된 메서드들을 구현하는 컨테이너 객체. 예로는 <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="library/collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a>, <a class="reference internal" href="library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a>, <a class="reference internal" href="library/collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a> 를 들 수 있다.</dd>
<dt id="term-meta-path-finder">meta path finder (메타 경로 파인더)</dt>
<dd><p class="first"><a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 의 검색이 돌려주는 <a class="reference internal" href="#term-finder"><span class="xref std std-term">파인더</span></a>. 메타 경로 파인더는 <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a> 와 관련되어 있기는 하지만 다르다.</p>
<p class="last">메타 경로 파인더가 구현하는 메서드들에 대해서는 <a class="reference internal" href="library/importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> 를 보면 된다.</p>
</dd>
<dt id="term-metaclass">metaclass (메타 클래스)</dt>
<dd><p class="first">클래스의 클래스. 클래스 정의는 클래스 이름, 클래스 딕셔너리, 베이스 클래스들의 목록을 만든다. 메타 클래스는 이 세 인자를 받아서 클래스를 만드는 책임을 진다. 대부분의 객체 지향형 프로그래밍 언어들은 기본 구현을 제공한다. 파이썬을 특별하게 만드는 것은 커스텀 메타 클래스를 만들 수 있다는 것이다. 대부분 사용자에게는 이 도구가 전혀 필요 없지만, 필요가 생길 때, 메타 클래스는 강력하고 우아한 해법을 제공한다. 어트리뷰트 액세스의 로깅(logging), 스레드 안전성의 추가, 객체 생성 추적, 싱글톤 구현과 많은 다른 작업에 사용됐다.</p>
<p class="last"><a class="reference internal" href="reference/datamodel.html#metaclasses"><span class="std std-ref">메타 클래스</span></a> 에서 더 자세한 내용을 찾을 수 있다.</p>
</dd>
<dt id="term-method">method (메서드)</dt>
<dd>클래스 바디 안에서 정의되는 함수. 그 클래스의 인스턴스의 어트리뷰트로서 호출되면, 그 메서드는 첫 번째 <a class="reference internal" href="#term-argument"><span class="xref std std-term">인자</span></a> (보통 <code class="docutils literal notranslate"><span class="pre">self</span></code> 라고 불린다) 로 인스턴스 객체를 받는다. <a class="reference internal" href="#term-function"><span class="xref std std-term">함수</span></a> 와 <a class="reference internal" href="#term-nested-scope"><span class="xref std std-term">중첩된 스코프</span></a> 를 보세요.</dd>
<dt id="term-method-resolution-order">method resolution order (메서드 결정 순서)</dt>
<dd>메서드 결정 순서는 조회하는 동안 멤버를 검색하는 베이스 클래스들의 순서다. 2.3 릴리스부터 파이썬 인터프리터에 사용된 알고리즘의 상세한 내용은 <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">The Python 2.3 Method Resolution Order</a> 를 보면 된다.</dd>
<dt id="term-module">module (모듈)</dt>
<dd><p class="first">파이썬 코드의 조직화 단위를 담당하는 객체. 모듈은 임의의 파이썬 객체들을 담는 이름 공간을 갖는다. 모듈은 <a class="reference internal" href="#term-importing"><span class="xref std std-term">임포팅</span></a> 절차에 의해 파이썬으로 로드된다.</p>
<p class="last"><a class="reference internal" href="#term-package"><span class="xref std std-term">패키지</span></a> 도 보세요.</p>
</dd>
<dt id="term-module-spec">module spec (모듈 스펙)</dt>
<dd>모듈을 로드하는데 사용되는 임포트 관련 정보들을 담고 있는 이름 공간. <a class="reference internal" href="library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ModuleSpec</span></code></a> 의 인스턴스.</dd>
<dt id="term-mro">MRO</dt>
<dd><a class="reference internal" href="#term-method-resolution-order"><span class="xref std std-term">메서드 결정 순서</span></a> 를 보세요.</dd>
<dt id="term-mutable">mutable (가변)</dt>
<dd>가변 객체는 값이 변할 수 있지만 <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> 는 일정하게 유지한다. <a class="reference internal" href="#term-immutable"><span class="xref std std-term">불변</span></a> 도 보세요.</dd>
<dt id="term-named-tuple">named tuple (네임드 튜플)</dt>
<dd><p class="first">인덱싱할 수 있는 요소들을 이름 붙은 어트리뷰트로도 액세스할 수 있는 모든 튜플류 클래스 (예를 들어, <a class="reference internal" href="library/time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.localtime()</span></code></a> 은 <em>year</em> 가 <code class="docutils literal notranslate"><span class="pre">t[0]</span></code> 처럼 인덱스로도, <code class="docutils literal notranslate"><span class="pre">t.tm_year</span></code> 처럼 어트리뷰트로도 액세스할 수 있는 튜플류 객체를 돌려준다.)</p>
<p class="last">네임드 튜플은 <a class="reference internal" href="library/time.html#time.struct_time" title="time.struct_time"><code class="xref py py-class docutils literal notranslate"><span class="pre">time.struct_time</span></code></a> 같은 내장형일 수도, 일반 클래스 정의로 만들 수도 있다. 모든 기능이 구현된 네임드 튜플을 팩토리 함수 <a class="reference internal" href="library/collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a> 로도 만들 수 있다. 마지막 접근법은 <code class="docutils literal notranslate"><span class="pre">Employee(name='jones',</span> <span class="pre">title='programmer')</span></code> 와 같은 스스로 문서로 만드는 repr 과 같은 확장 기능도 자동 제공한다.</p>
</dd>
<dt id="term-namespace">namespace (이름 공간)</dt>
<dd>변수가 저장되는 장소. 이름 공간은 딕셔너리로 구현된다. 객체에 중첩된 이름 공간 (메서드 에서) 뿐만 아니라 지역, 전역, 내장 이름 공간이 있다. 이름 공간은 이름 충돌을 방지해서 모듈성을 지원한다. 예를 들어, 함수 <a class="reference internal" href="library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">builtins.open</span></code></a> 과 <a class="reference internal" href="library/os.html#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a> 은 그들의 이름 공간에 의해 구별된다. 또한, 이름 공간은 어떤 모듈이 함수를 구현하는지를 분명하게 만들어서 가독성과 유지 보수성에 도움을 준다. 예를 들어, <a class="reference internal" href="library/random.html#random.seed" title="random.seed"><code class="xref py py-func docutils literal notranslate"><span class="pre">random.seed()</span></code></a> 또는 <a class="reference internal" href="library/itertools.html#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.islice()</span></code></a> 라고 쓰면 그 함수들이 각각 <a class="reference internal" href="library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> 과 <a class="reference internal" href="library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a> 모듈에 의해 구현되었음이 명확해진다.</dd>
<dt id="term-namespace-package">namespace package (이름 공간 패키지)</dt>
<dd><p class="first">오직 서브 패키지들의 컨테이너로만 기능하는 <span class="target" id="index-77"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> <a class="reference internal" href="#term-package"><span class="xref std std-term">패키지</span></a>. 이름 공간 패키지는 물리적인 실체가 없을 수도 있고, 특히 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 파일이 없으므로 <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">정규 패키지</span></a> 와는 다르다.</p>
<p class="last"><a class="reference internal" href="#term-module"><span class="xref std std-term">모듈</span></a> 도 보세요.</p>
</dd>
<dt id="term-nested-scope">nested scope (중첩된 스코프)</dt>
<dd>둘러싼 정의에서 변수를 참조하는 능력. 예를 들어, 다른 함수 내부에서 정의된 함수는 바깥 함수에 있는 변수들을 참조할 수 있다. 중첩된 스코프는 기본적으로는 참조만 가능할 뿐, 대입은 되지 않는다는 것에 주의해야 한다. 지역 변수들은 가장 내부의 스코프에서 읽고 쓴다. 마찬가지로, 전역 변수들은 전역 이름 공간에서 읽고 쓴다. <a class="reference internal" href="reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 은 바깥 스코프에 쓰는 것을 허락한다.</dd>
<dt id="term-new-style-class">new-style class (뉴스타일 클래스)</dt>
<dd>지금은 모든 클래스 객체에 사용되고 있는 클래스 버전의 예전 이름. 초기의 파이썬 버전에서는, 오직 뉴스타일 클래스만 <a class="reference internal" href="reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>, 디스크립터, 프라퍼티, <a class="reference internal" href="reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a>, 클래스 메서드, 스태틱 메서드와 같은 파이썬의 새롭고 다양한 기능들을 사용할 수 있었다.</dd>
<dt id="term-object">object (객체)</dt>
<dd>상태 (어트리뷰트나 값) 를 갖고 동작 (메서드) 이 정의된 모든 데이터. 또한, 모든 <a class="reference internal" href="#term-new-style-class"><span class="xref std std-term">뉴스타일 클래스</span></a> 의 최종적인 베이스 클래스다.</dd>
<dt id="term-package">package (패키지)</dt>
<dd><p class="first">서브 모듈들이나, 재귀적으로 서브 패키지들을 포함할 수 있는 파이썬 <a class="reference internal" href="#term-module"><span class="xref std std-term">모듈</span></a>. 기술적으로, 패키지는 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트가 있는 파이썬 모듈이다.</p>
<p class="last"><a class="reference internal" href="#term-regular-package"><span class="xref std std-term">정규 패키지</span></a> 와 <a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">이름 공간 패키지</span></a> 도 보세요.</p>
</dd>
<dt id="term-parameter">parameter (파라미터)</dt>
<dd><p class="first"><a class="reference internal" href="#term-function"><span class="xref std std-term">함수</span></a> (또는 메서드) 정의에서 함수가 받을 수 있는 <a class="reference internal" href="#term-argument"><span class="xref std std-term">인자</span></a> (또는 어떤 경우 인자들) 를 지정하는 이름 붙은 엔티티. 다섯 종류의 파라미터가 있다:</p>
<ul>
<li><p class="first"><em class="dfn">위치-키워드 (positional-or-keyword)</em>: <a class="reference internal" href="#term-positional-argument"><span class="xref std std-term">위치 인자</span></a> 나 <a class="reference internal" href="#term-keyword-argument"><span class="xref std std-term">키워드 인자</span></a> 로 전달될 수 있는 인자를 지정한다. 이것이 기본 형태의 파라미터다, 예를 들어 다음에서 <em>foo</em> 와 <em>bar</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul class="simple" id="positional-only-parameter">
<li><em class="dfn">위치-전용 (positional-only)</em>: 위치로만 제공될 수 있는 인자를 지정한다. 파이썬은 위치-전용 파라미터를 정의하는 문법을 갖고 있지 않다. 하지만, 어떤 매장 함수들은 위치-전용 파라미터를 갖는다 (예를 들어, <a class="reference internal" href="library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a>).</li>
</ul>
<ul id="keyword-only-parameter">
<li><p class="first"><em class="dfn">키워드-전용 (keyword-only)</em>: 키워드로만 제공될 수 있는 인자를 지정한다. 키워드-전용 파라미터는 함수 정의의 파라미터 목록에서 앞에 하나의 가변-위치 파라미터나 <code class="docutils literal notranslate"><span class="pre">*</span></code> 를 그대로 포함해서 정의할 수 있다. 예를 들어, 다음에서 <em>kw_only1</em> 와 <em>kw_only2</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kw_only1</span><span class="p">,</span> <span class="n">kw_only2</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p class="first"><em class="dfn">가변-위치 (var-positional)</em>: (다른 파라미터들에 의해서 이미 받아들여진 위치 인자들에 더해) 제공될 수 있는 위치 인자들의 임의의 시퀀스를 지정한다. 이런 파라미터는 파라미터 이름에 <code class="docutils literal notranslate"><span class="pre">*</span></code> 를 앞에 붙여서 정의될 수 있다, 예를 들어 다음에서 <em>args</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p class="first"><em class="dfn">가변-키워드 (var-keyword)</em>: (다른 파라미터들에 의해서 이미 받아들여진 키워드 인자들에 더해) 제공될 수 있는 임의의 개수 키워드 인자들을 지정한다. 이런 파라미터는 파라미터 이름에 <code class="docutils literal notranslate"><span class="pre">**</span></code> 를 앞에 붙여서 정의될 수 있다, 예를 들어 위의 예 에서 <em>kwargs</em>.</p>
</li>
</ul>
<p>파라미터는 선택적 인자들을 위한 기본값뿐만 아니라 선택적이거나 필수 인자들을 지정할 수 있다.</p>
<p class="last"><a class="reference internal" href="#term-argument"><span class="xref std std-term">인자</span></a> 용어집 항목, <a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">인자와 파라미터의 차이</span></a> 에 나오는 FAQ 질문, <a class="reference internal" href="library/inspect.html#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">inspect.Parameter</span></code></a> 클래스, <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">함수 정의</span></a> 섹션, <span class="target" id="index-78"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0362"><strong>PEP 362</strong></a> 도 보세요.</p>
</dd>
<dt id="term-path-entry">path entry (경로 엔트리)</dt>
<dd><a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">경로 기반 파인더</span></a> 가 임포트할 모듈들을 찾기 위해 참고하는 <a class="reference internal" href="#term-import-path"><span class="xref std std-term">임포트 경로</span></a> 상의 하나의 장소.</dd>
<dt id="term-path-entry-finder">path entry finder (경로 엔트리 파인더)</dt>
<dd><p class="first"><a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> 에 있는 콜러블 (즉, <a class="reference internal" href="#term-path-entry-hook"><span class="xref std std-term">경로 엔트리 훅</span></a>) 이 돌려주는 <a class="reference internal" href="#term-finder"><span class="xref std std-term">파인더</span></a> 인데, 주어진 <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">경로 엔트리</span></a> 로 모듈을 찾는 방법을 알고 있다.</p>
<p class="last">경로 엔트리 파인더들이 구현하는 메서드들은 <a class="reference internal" href="library/importlib.html#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder</span></code></a> 에 나온다.</p>
</dd>
<dt id="term-path-entry-hook">path entry hook (경로 엔트리 훅)</dt>
<dd><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hook</span></code> 리스트에 있는 콜러블인데, 특정 <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">경로 엔트리</span></a> 에서 모듈을 찾는 법을 알고 있다면 <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a> 를 돌려준다.</dd>
<dt id="term-path-based-finder">path based finder (경로 기반 파인더)</dt>
<dd>기본 <a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">메타 경로 파인더들</span></a> 중 하나인데, <a class="reference internal" href="#term-import-path"><span class="xref std std-term">임포트 경로</span></a> 에서 모듈을 찾는다.</dd>
<dt id="term-path-like-object">path-like object (경로류 객체)</dt>
<dd>파일 시스템 경로를 나타내는 객체. 경로류 객체는 경로를 나타내는 <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 나 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체이거나 <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> 프로토콜을 구현하는 객체다. <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> 프로토콜을 지원하는 객체는 <a class="reference internal" href="library/os.html#os.fspath" title="os.fspath"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fspath()</span></code></a> 함수를 호출해서 <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 나 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 파일 시스템 경로로 변환될 수 있다; 대신 <a class="reference internal" href="library/os.html#os.fsdecode" title="os.fsdecode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsdecode()</span></code></a> 와 <a class="reference internal" href="library/os.html#os.fsencode" title="os.fsencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsencode()</span></code></a> 는 각각 <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 나 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 결과를 보장하는데 사용될 수 있다. <span class="target" id="index-79"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0519"><strong>PEP 519</strong></a> 로 도입되었다.</dd>
<dt id="term-portion">portion (포션)</dt>
<dd><span class="target" id="index-80"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> 에서 정의한 것처럼, 이름 공간 패키지에 이바지하는 하나의 디렉터리에 들어있는 파일들의 집합 (zip 파일에 저장되는 것도 가능하다).</dd>
<dt id="term-positional-argument">positional argument (위치 인자)</dt>
<dd><a class="reference internal" href="#term-argument"><span class="xref std std-term">인자</span></a> 를 보세요.</dd>
<dt id="term-provisional-api">provisional API (잠정 API)</dt>
<dd><p class="first">잠정 API는 표준 라이브러리의 과거 호환성 보장으로부터 신중히 제외된 것이다. 인터페이스의 큰 변화가 예상되지는 않지만, 잠정적이라고 표시되는 한, 코어 개발자들이 필요하다고 생각한다면 과거 호환성이 유지되지 않는 변경이 일어날 수 있다. 그런 변경은 불필요한 방식으로 일어나지는 않을 것이다 --- API를 포함하기 전에 놓친 중대하고 근본적인 결함이 발견된 경우에만 일어날 것이다.</p>
<p>잠정 API에서조차도, 과거 호환성이 유지되지 않는 변경은 &quot;최후의 수단&quot;으로 여겨진다 - 모든 식별된 문제들에 대해 과거 호환성을 유지하는 해법을 찾으려는 모든 시도가 선행된다.</p>
<p class="last">이 절차는 표준 라이브러리가 오랜 시간 동안 잘못된 설계 오류에 발목 잡히지 않고 발전할 수 있도록 만든다. 더 자세한 내용은 <span class="target" id="index-81"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0411"><strong>PEP 411</strong></a> 를 보면 된다.</p>
</dd>
<dt id="term-provisional-package">provisional package (잠정 패키지)</dt>
<dd><a class="reference internal" href="#term-provisional-api"><span class="xref std std-term">잠정 API</span></a> 를 보세요.</dd>
<dt id="term-python-3000">Python 3000 (파이썬 3000)</dt>
<dd>파이썬 3.x 배포 라인의 별명 (버전 3의 배포가 먼 미래의 이야기던 시절에 만들어진 이름이다.) 이것을 &quot;Py3k&quot; 로 줄여 쓰기도 한다.</dd>
<dt id="term-pythonic">Pythonic (파이썬다운)</dt>
<dd><p class="first">다른 언어들에서 일반적인 개념들을 사용해서 코드를 구현하는 대신, 파이썬 언어에서 가장 자주 사용되는 이디엄들을 가까이 따르는 아이디어나 코드 조작. 예를 들어, 파이썬에서 자주 쓰는 이디엄은 <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 문을 사용해서 이터러블의 모든 요소로 루핑하는 것이다. 다른 많은 언어에는 이런 종류의 구성물이 없으므로, 파이썬에 익숙하지 않은 사람들은 대신에 숫자 카운터를 사용하기도 한다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">food</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">food</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>더 깔끔한, 파이썬다운 방법은 이렇다:</p>
<div class="last highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">piece</span> <span class="ow">in</span> <span class="n">food</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt id="term-qualified-name">qualified name (정규화된 이름)</dt>
<dd><p class="first">모듈의 전역 스코프에서 모듈에 정의된 클래스, 함수, 메서드에 이르는 &quot;경로&quot;를 보여주는 점으로 구분된 이름. <span class="target" id="index-82"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3155"><strong>PEP 3155</strong></a> 에서 정의된다. 최상위 함수와 클래스의 경우에, 정규화된 이름은 객체의 이름과 같다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>            <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">meth</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D.meth&#39;</span>
</pre></div>
</div>
<p>모듈을 가리키는데 사용될 때, <em>완전히 정규화된 이름(fully qualified name)</em> 은 모든 부모 패키지들을 포함해서 모듈로 가는 점으로 분리된 이름을 의미한다, 예를 들어, <code class="docutils literal notranslate"><span class="pre">email.mime.text</span></code>:</p>
<div class="last highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">email.mime.text</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span><span class="o">.</span><span class="n">mime</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;email.mime.text&#39;</span>
</pre></div>
</div>
</dd>
<dt id="term-reference-count">reference count (참조 횟수)</dt>
<dd>객체에 대한 참조의 개수. 객체의 참조 횟수가 0으로 떨어지면, 메모리가 반납된다. 참조 횟수 추적은 일반적으로 파이썬 코드에 노출되지는 않지만, <a class="reference internal" href="#term-cpython"><span class="xref std std-term">CPython</span></a> 구현의 핵심 요소다. <a class="reference internal" href="library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 모듈은 특정 객체의 참조 횟수를 돌려주는 <a class="reference internal" href="library/sys.html#sys.getrefcount" title="sys.getrefcount"><code class="xref py py-func docutils literal notranslate"><span class="pre">getrefcount()</span></code></a> 을 정의한다.</dd>
<dt id="term-regular-package">regular package (정규 패키지)</dt>
<dd><p class="first"><code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 파일을 포함하는 디렉터리와 같은 전통적인 <a class="reference internal" href="#term-package"><span class="xref std std-term">패키지</span></a>.</p>
<p class="last"><a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">이름 공간 패키지</span></a> 도 보세요.</p>
</dd>
<dt id="term-slots">__slots__</dt>
<dd>클래스 내부의 선언인데, 인스턴스 어트리뷰트들을 위한 공간을 미리 선언하고 인스턴스 딕셔너리를 제거함으로써 메모리를 절감하는 효과를 준다. 인기 있기는 하지만, 이 테크닉은 올바르게 사용하기가 좀 까다로운 편이라서, 메모리에 민감한 응용 프로그램에서 많은 수의 인스턴스가 있는 특별한 경우로 한정하는 것이 좋다.</dd>
<dt id="term-sequence">sequence (시퀀스)</dt>
<dd><p class="first"><a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 특수 메서드를 통해 정수 인덱스를 사용한 빠른 요소 액세스를 지원하고, 시퀀스의 길이를 돌려주는 <a class="reference internal" href="reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 메서드를 정의하는 <a class="reference internal" href="#term-iterable"><span class="xref std std-term">이터러블</span></a>. 몇몇 내장 시퀀스들을 나열해보면, <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 가 있다. <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 또한 <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 과 <a class="reference internal" href="reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 을 지원하지만, 조회에 정수 대신 임의의 <a class="reference internal" href="#term-immutable"><span class="xref std std-term">불변</span></a> 키를 사용하기 때문에 시퀀스가 아니라 매핑으로 취급된다는 것에 주의해야 한다.</p>
<p class="last"><a class="reference internal" href="library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> 추상 베이스 클래스는 <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 과 <a class="reference internal" href="reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 를 넘어서 훨씬 풍부한 인터페이스를 정의하는데, <code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>, <a class="reference internal" href="reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a>, <a class="reference internal" href="reference/datamodel.html#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> 를 추가한다. 이 확장된 인터페이스를 구현한 형을 <code class="xref py py-func docutils literal notranslate"><span class="pre">register()</span></code> 를 사용해서 명시적으로 등록할 수 있다.</p>
</dd>
<dt id="term-single-dispatch">single dispatch (싱글 디스패치)</dt>
<dd>구현이 하나의 인자의 형에 기초해서 결정되는 <a class="reference internal" href="#term-generic-function"><span class="xref std std-term">제네릭 함수</span></a> 디스패치의 한 형태.</dd>
<dt id="term-slice">slice (슬라이스)</dt>
<dd>보통 <a class="reference internal" href="#term-sequence"><span class="xref std std-term">시퀀스</span></a> 의 일부를 포함하는 객체. 슬라이스는 서브 스크립트 표기법을 사용해서 만든다. <code class="docutils literal notranslate"><span class="pre">variable_name[1:3:5]</span></code> 처럼, <code class="docutils literal notranslate"><span class="pre">[]</span></code> 안에서 여러 개의 숫자를 콜론으로 분리한다. 꺾쇠괄호 (서브 스크립트) 표기법은 내부적으로 <a class="reference internal" href="library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> 객체를 사용한다.</dd>
<dt id="term-special-method">special method (특수 메서드)</dt>
<dd>파이썬이 형에 어떤 연산을, 덧셈 같은, 실행할 때 묵시적으로 호출되는 메서드. 이런 메서드는 두 개의 밑줄로 시작하고 끝나는 이름을 갖고 있다. 특수 메서드는 <a class="reference internal" href="reference/datamodel.html#specialnames"><span class="std std-ref">특수 메서드 이름들</span></a> 에 문서로 만들어져 있다.</dd>
<dt id="term-statement">statement (문장)</dt>
<dd>문장은 스위트 (코드의 &quot;블록(block)&quot;) 를 구성하는 부분이다. 문장은 <a class="reference internal" href="#term-expression"><span class="xref std std-term">표현식</span></a> 이거나 키워드를 사용하는 여러 가지 구조물 중의 하나다. 가령 <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>, <a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a>, <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>.</dd>
<dt id="term-struct-sequence">struct sequence (구조체 시퀀스)</dt>
<dd>이름 붙은 요소들을 가진 튜플. 구조체 시퀀스는 <a class="reference internal" href="#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a> 과 비슷한 인터페이스를 드러내는데, 요소들이 인덱스나 어트리뷰트로 액세스 될 수 있다. 하지만, 이것은 <a class="reference internal" href="library/collections.html#collections.somenamedtuple._make" title="collections.somenamedtuple._make"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_make()</span></code></a> 나 <a class="reference internal" href="library/collections.html#collections.somenamedtuple._asdict" title="collections.somenamedtuple._asdict"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_asdict()</span></code></a> 같은 네임드 튜플의 메서드들을 갖고 있지 않다. 구조체 시퀀스의 예로는 <a class="reference internal" href="library/sys.html#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.float_info</span></code></a> 과 <a class="reference internal" href="library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a> 의 반환 값을 들 수 있다.</dd>
<dt id="term-text-encoding">text encoding (텍스트 인코딩)</dt>
<dd>유니코드 문자열을 바이트열로 인코딩하는 코덱.</dd>
<dt id="term-text-file">text file (텍스트 파일)</dt>
<dd><p class="first"><a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 객체를 읽고 쓸 수 있는 <a class="reference internal" href="#term-file-object"><span class="xref std std-term">파일 객체</span></a>. 종종, 텍스트 파일은 실제로는 바이트 지향 데이터스트림을 액세스하고 <a class="reference internal" href="#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a> 을 자동 처리한다. 텍스트 파일의 예로는 텍스트 모드 (<code class="docutils literal notranslate"><span class="pre">'r'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'w'</span></code>) 로 열린 파일, <a class="reference internal" href="library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a>, <a class="reference internal" href="library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>, <a class="reference internal" href="library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> 의 인스턴스를 들 수 있다.</p>
<div class="last admonition seealso">
<p class="first admonition-title">参见</p>
<p class="last"><a class="reference internal" href="#term-binary-file"><span class="xref std std-term">바이너리 파일</span></a> 은 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체를 읽고 쓴다.</p>
</div>
</dd>
<dt id="term-triple-quoted-string">triple-quoted string (삼중 따옴표 된 문자열)</dt>
<dd>따옴표 (&quot;) 나 작은따옴표 (') 세 개로 둘러싸인 문자열. 그냥 따옴표 하나로 둘러싸인 문자열에 없는 기능을 제공하지는 않지만, 여러 가지 이유에서 쓸모가 있다. 이스케이프 되지 않은 작은따옴표나 큰따옴표를 문자열 안에 포함할 수 있도록 하고, 연결 문자를 쓰지 않고도 여러 줄에 걸칠 수 있는데, 독스트링을 쓸 때 특히 쓸모 있다.</dd>
<dt id="term-type">type (형)</dt>
<dd>파이썬 객체의 형은 그것이 어떤 종류의 객체인지를 결정한다; 모든 객체는 형이 있다. 객체의 형은 <a class="reference internal" href="library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> 어트리뷰트로 액세스할 수 있거나 <code class="docutils literal notranslate"><span class="pre">type(obj)</span></code> 로 얻을 수 있다.</dd>
<dt id="term-universal-newlines">universal newlines (유니버설 줄 넘김)</dt>
<dd>다음과 같은 것들을 모두 줄의 끝으로 인식하는, 텍스트 스트림을 해석하는 태도: 유닉스 개행 문자 관례 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>, 윈도우즈 관례 <code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code>, 예전의 매킨토시 관례 <code class="docutils literal notranslate"><span class="pre">'\r'</span></code>. 추가적인 사용에 관해서는 <a class="reference internal" href="library/stdtypes.html#bytes.splitlines" title="bytes.splitlines"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.splitlines()</span></code></a> 뿐만 아니라 <span class="target" id="index-83"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0278"><strong>PEP 278</strong></a> 와 <span class="target" id="index-84"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3116"><strong>PEP 3116</strong></a> 도 보세요.</dd>
<dt id="term-variable-annotation">variable annotation (변수 어노테이션)</dt>
<dd><p class="first">모듈 전역 변수나 클래스 어트리뷰트와 결합한 형 메타데이터 값. 문법은 섹션 <a class="reference internal" href="reference/simple_stmts.html#annassign"><span class="std std-ref">어노테이트된 대입문(Annotated assignment statements)</span></a> 에서 설명한다. 어노테이션은 클래스나 모듈 객체의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> 특수 어트리뷰트에 저장되고, <a class="reference internal" href="library/typing.html#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.get_type_hints()</span></code></a> 를 사용해서 액세스할 수 있다.</p>
<p class="last">파이썬 자체는 변수 어노테이션에 어떤 특별한 의미도 부여하지 않는다. 제삼자 라이브러리나 형 검사 도구들에 의해 해석되는 것이 목적이다. <span class="target" id="index-85"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> 과 <span class="target" id="index-86"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> 은 몇 가지 잠재적인 사용에 관해 기술하고 있다.</p>
</dd>
<dt id="term-virtual-environment">virtual environment (가상 환경)</dt>
<dd><p class="first">파이썬 사용자와 응용 프로그램이, 같은 시스템에서 실행되는 다른 파이썬 응용 프로그램들의 동작에 영향을 주지 않으면서, 파이썬 배포 패키지들을 설치하거나 업그레이드하는 것을 가능하게 하는, 협력적으로 격리된 실행 환경.</p>
<p class="last"><a class="reference internal" href="library/venv.html#module-venv" title="venv: Creation of virtual environments."><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code></a> 도 보세요.</p>
</dd>
<dt id="term-virtual-machine">virtual machine (가상 기계)</dt>
<dd>소프트웨어만으로 정의된 컴퓨터. 파이썬의 가상 기계는 바이트 코드 컴파일러가 출력하는 <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">바이트 코드</span></a> 를 실행한다.</dd>
<dt id="term-zen-of-python">Zen of Python (파이썬 젠)</dt>
<dd>파이썬 디자인 원리와 철학들의 목록인데, 인어를 이해하고 사용하는 데 도움이 된다. 이 목록은 대화형 프롬프트에서 &quot;<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">this</span></code>&quot; 를 입력하면 보인다.</dd>
</dl>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>上一个主题</h4>
  <p class="topless"><a href="faq/installed.html"
                        title="上一章">&quot;Why is Python Installed on my Computer?&quot; FAQ</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="about.html"
                        title="下一章">About these documents</a></p>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/glossary.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="일반 색인"
             >索引</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="about.html" title="About these documents"
             >下一页</a> |</li>
        <li class="right" >
          <a href="faq/installed.html" title="&#34;Why is Python Installed on my Computer?&#34; FAQ"
             >上一页</a> |</li>
        <li><img src="_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh</span>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="index.html">도큐멘테이션 </a> &#187;
        </li>

    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    파이썬 소프트웨어 재단은 비영리 법인입니다.
    <a href="https://www.python.org/psf/donations/">기부를 부탁합니다.</a>
    <br />
    4月 21, 2018 에 마지막으로 업데이트되었습니다.
    <a href="bugs.html">버그를 찾았나요?</a>
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.7.2 를 사용해서 만들었습니다.
    </div>

  </body>
</html>