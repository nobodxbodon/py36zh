
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>2. 내장 함수 &#8212; Python 3.6.5 文档</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.6.5 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="3. Built-in Constants" href="constants.html" />
    <link rel="prev" title="1. 소개" href="intro.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.org/3/library/functions.html" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="constants.html" title="3. Built-in Constants"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="intro.html" title="1. 소개"
             accesskey="P">上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh</span>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">도큐멘테이션 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 표준 라이브러리</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="built-in-functions">
<span id="built-in-funcs"></span><h1>2. 내장 함수<a class="headerlink" href="#built-in-functions" title="永久链接至标题">¶</a></h1>
<p>파이썬 인터프리터에는 항상 사용할 수 있는 많은 함수와 형이 내장되어 있다. 여기에서 알파벳 순으로 나열한다.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="19%" />
<col width="20%" />
<col width="18%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"></th>
<th class="head"></th>
<th class="head">내장 함수</th>
<th class="head"></th>
<th class="head"></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a></td>
<td><a class="reference internal" href="#func-dict"><code class="docutils literal notranslate"><span class="pre">dict()</span></code></a></td>
<td><a class="reference internal" href="#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a></td>
<td><a class="reference internal" href="#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a></td>
<td><a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#all" title="all"><code class="xref py py-func docutils literal notranslate"><span class="pre">all()</span></code></a></td>
<td><a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a></td>
<td><a class="reference internal" href="#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a></td>
<td><a class="reference internal" href="#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a></td>
<td><a class="reference internal" href="#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#any" title="any"><code class="xref py py-func docutils literal notranslate"><span class="pre">any()</span></code></a></td>
<td><a class="reference internal" href="#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a></td>
<td><a class="reference internal" href="#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a></td>
<td><a class="reference internal" href="#object" title="object"><code class="xref py py-func docutils literal notranslate"><span class="pre">object()</span></code></a></td>
<td><a class="reference internal" href="#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ascii" title="ascii"><code class="xref py py-func docutils literal notranslate"><span class="pre">ascii()</span></code></a></td>
<td><a class="reference internal" href="#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a></td>
<td><a class="reference internal" href="#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a></td>
<td><a class="reference internal" href="#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a></td>
<td><a class="reference internal" href="#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a></td>
<td><a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a></td>
<td><a class="reference internal" href="#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a></td>
<td><a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a></td>
<td><a class="reference internal" href="#func-str"><code class="docutils literal notranslate"><span class="pre">str()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a></td>
<td><a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a></td>
<td><a class="reference internal" href="#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a></td>
<td><a class="reference internal" href="#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a></td>
<td><a class="reference internal" href="#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#func-bytearray"><code class="docutils literal notranslate"><span class="pre">bytearray()</span></code></a></td>
<td><a class="reference internal" href="#filter" title="filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a></td>
<td><a class="reference internal" href="#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a></td>
<td><a class="reference internal" href="#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a></td>
<td><a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#func-bytes"><code class="docutils literal notranslate"><span class="pre">bytes()</span></code></a></td>
<td><a class="reference internal" href="#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a></td>
<td><a class="reference internal" href="#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a></td>
<td><a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a></td>
<td><a class="reference internal" href="#func-tuple"><code class="docutils literal notranslate"><span class="pre">tuple()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#callable" title="callable"><code class="xref py py-func docutils literal notranslate"><span class="pre">callable()</span></code></a></td>
<td><a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a></td>
<td><a class="reference internal" href="#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a></td>
<td><a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a></td>
<td><a class="reference internal" href="#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a></td>
<td><a class="reference internal" href="#func-frozenset"><code class="docutils literal notranslate"><span class="pre">frozenset()</span></code></a></td>
<td><a class="reference internal" href="#func-list"><code class="docutils literal notranslate"><span class="pre">list()</span></code></a></td>
<td><a class="reference internal" href="#func-range"><code class="docutils literal notranslate"><span class="pre">range()</span></code></a></td>
<td><a class="reference internal" href="#vars" title="vars"><code class="xref py py-func docutils literal notranslate"><span class="pre">vars()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a></td>
<td><a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a></td>
<td><a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a></td>
<td><a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a></td>
<td><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a></td>
<td><a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a></td>
<td><a class="reference internal" href="#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a></td>
<td><a class="reference internal" href="#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a></td>
<td><a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a></td>
<td><a class="reference internal" href="#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a></td>
<td><a class="reference internal" href="#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a></td>
<td><a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#delattr" title="delattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">delattr()</span></code></a></td>
<td><a class="reference internal" href="#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a></td>
<td><a class="reference internal" href="#func-memoryview"><code class="docutils literal notranslate"><span class="pre">memoryview()</span></code></a></td>
<td><a class="reference internal" href="#func-set"><code class="docutils literal notranslate"><span class="pre">set()</span></code></a></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="abs">
<code class="descname">abs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#abs" title="永久链接至目标">¶</a></dt>
<dd><p>숫자의 절댓값을 돌려준다. 인자는 정수 또는 실수다. 인자가 복소수면 그 크기가 반환된다.</p>
</dd></dl>

<dl class="function">
<dt id="all">
<code class="descname">all</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#all" title="永久链接至目标">¶</a></dt>
<dd><p><em>iterable</em> 의 모든 요소가 참이면 (또는 iterable 이 비어있으면) <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 돌려준다. 다음과 동등하다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">element</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="any">
<code class="descname">any</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#any" title="永久链接至目标">¶</a></dt>
<dd><p><em>iterable</em> 의 요소 중 어느 하나라도 참이면 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 돌려준다. iterable이 비어 있으면 <code class="docutils literal notranslate"><span class="pre">False</span></code> 를 돌려준다. 다음과 동등하다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">element</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="ascii">
<code class="descname">ascii</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#ascii" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 처럼, 객체의 인쇄 가능한 표현을 포함하는 문자열을 반환하지만, <code class="docutils literal notranslate"><span class="pre">\x</span></code> 나 <code class="docutils literal notranslate"><span class="pre">\u</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">\U</span></code> 이스케이프를 사용하여 <a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 이 돌려주는 문자열에 포함된 비 ASCII 문자를 이스케이프 한다. 이것은 파이썬 2의 <a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 이 돌려주는 것과 비슷한 문자열을 만든다.</p>
</dd></dl>

<dl class="function">
<dt id="bin">
<code class="descname">bin</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#bin" title="永久链接至目标">¶</a></dt>
<dd><blockquote>
<div><p>정수를 &quot;0b&quot; 가 앞에 붙은 이진 문자열로 변환한다. 결과는 올바른 파이썬 표현식이다. <em>x</em> 가 파이썬 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 객체가 아니라면, 정수를 돌려주는 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> 메서드를 정의해야 한다. 몇 가지 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;0b11&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>
<span class="go">&#39;-0b1010&#39;</span>
</pre></div>
</div>
<p>접두어 &quot;0b&quot; 가 필요할 수도, 필요 없을 수도 있다면, 다음 방법의 하나를 사용할 수 있다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="s1">&#39;#b&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">(&#39;0b1110&#39;, &#39;1110&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{14:#b}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{14:b}</span><span class="s1">&#39;</span>
<span class="go">(&#39;0b1110&#39;, &#39;1110&#39;)</span>
</pre></div>
</div>
</div></blockquote>
<p>자세한 내용은 <a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 을 보면 된다.</p>
</dd></dl>

<dl class="class">
<dt id="bool">
<em class="property">class </em><code class="descname">bool</code><span class="sig-paren">(</span><span class="optional">[</span><em>x</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bool" title="永久链接至目标">¶</a></dt>
<dd><p>논리값, 즉 <code class="docutils literal notranslate"><span class="pre">True</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">False</span></code> 중 하나를 돌려준다. <em>x</em> 표준 <a class="reference internal" href="stdtypes.html#truth"><span class="std std-ref">논리값 검사 절차</span></a> 를 사용하여 변환된다. <em>x</em> 가 거짓이거나 생략되면 <code class="docutils literal notranslate"><span class="pre">False</span></code> 를 돌려준다. 그렇지 않으면``True`` 를 돌려준다. <a class="reference internal" href="#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> 클래스는 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> (<a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">Numeric Types --- int, float, complex</span></a> 참조)의 서브 클래스다. 서브 클래스를 더 만들 수 없다. 이것의 유일한 인스턴스는 <code class="docutils literal notranslate"><span class="pre">False</span></code> 와``True`` 다 (<a class="reference internal" href="stdtypes.html#bltin-boolean-values"><span class="std std-ref">Boolean Values</span></a> 참조).</p>
</dd></dl>

<span class="target" id="func-bytearray"><span id="index-0"></span></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">bytearray</code><span class="sig-paren">(</span><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>새로운 바이트 배열을 돌려준다. <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 클래스는 0 &lt;= x &lt; 256 범위에 있는 정수의 가변 시퀀스다. <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 형이 가진 대부분의 메서드뿐만 아니라 (<a class="reference internal" href="stdtypes.html#bytes-methods"><span class="std std-ref">Bytes and Bytearray Operations</span></a> 참조), <a class="reference internal" href="stdtypes.html#typesseq-mutable"><span class="std std-ref">Mutable Sequence Types</span></a> 에 기술된 가변 시퀀스의 일반적인 메서드 대부분을 갖고 있다.</p>
<p>선택적 <em>source</em> 파라미터는 몇 가지 다른 방법으로 배열을 초기화하는 데 사용할 수 있다:</p>
<ul class="simple">
<li><em>문자열</em> 이면, 반드시 <em>encoding</em> 파라미터도 제공해야 한다 (그리고 선택적으로 <em>errors</em> 도); 그러면 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a> 는 <a class="reference internal" href="stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> 를 사용하여 문자열을 바이트로 변환한다.</li>
<li><em>정수</em> 면, 배열은 그 크기를 갖고, 널 바이트로 초기화된다.</li>
<li><em>버퍼(buffer)</em> 인터페이스를 제공하는 객체면, 객체의 읽기 전용 버퍼가 바이트 배열을 초기화하는 데 사용된다.</li>
<li><em>이터러블</em> 이면, 범위 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code> 의 정수를 제공하는 이터러블이어야 하고, 그 값들이 배열의 초기 내용물로 사용된다.</li>
</ul>
<p>인자가 없으면 크기 0의 배열이 만들어진다.</p>
<p><a class="reference internal" href="stdtypes.html#binaryseq"><span class="std std-ref">Binary Sequence Types --- bytes, bytearray, memoryview</span></a> 와 <a class="reference internal" href="stdtypes.html#typebytearray"><span class="std std-ref">Bytearray Objects</span></a> 를 참고하라.</p>
</dd></dl>

<span class="target" id="func-bytes"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">bytes</code><span class="sig-paren">(</span><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>새로운 &quot;바이트열&quot; 객체를 돌려준다. 이 객체는 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code> 범위에 있는 정수의 불변 시퀀스다. <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 는 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 의 불변 버전이다 -- 같은 불변 메서드와 같은 인덱싱 및 슬라이싱 동작을 갖는다.</p>
<p>따라서 생성자 인자는 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a> 와 같이 해석된다.</p>
<p>바이트열 객체는 리터럴을 사용하여 만들 수도 있다 (<a class="reference internal" href="../reference/lexical_analysis.html#strings"><span class="std std-ref">문자열과 바이트열 리터럴</span></a> 참조).</p>
<p><a class="reference internal" href="stdtypes.html#binaryseq"><span class="std std-ref">Binary Sequence Types --- bytes, bytearray, memoryview</span></a>, <a class="reference internal" href="stdtypes.html#typebytes"><span class="std std-ref">Bytes Objects</span></a> 및 <a class="reference internal" href="stdtypes.html#bytes-methods"><span class="std std-ref">Bytes and Bytearray Operations</span></a> 를 참고하라.</p>
</dd></dl>

<dl class="function">
<dt id="callable">
<code class="descname">callable</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#callable" title="永久链接至目标">¶</a></dt>
<dd><p><em>object</em> 인자가 콜러블인 것처럼 보이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> 를, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> 를 돌려준다. 이것이 참을 돌려줘도 여전히 호출이 실패할 가능성이 있지만, 거짓일 때 <em>object</em> 를 호출하면 반드시 실패한다. 클래스가 콜러블 이라는 것에 유의해야 한다 (클래스를 호출하면 새 인스턴스를 돌려준다); 클래스에 <a class="reference internal" href="../reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> 메서드가 있으면 인스턴스도 콜러블이다.</p>
<div class="versionadded">
<p><span class="versionmodified">3.2 新版功能: </span>이 함수는 파이썬 3.0에서 먼저 제거된 다음 파이썬 3.2에서 다시 도입했다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="chr">
<code class="descname">chr</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#chr" title="永久链接至目标">¶</a></dt>
<dd><p>유니코드 코드 포인트가 정수 <em>i</em> 인 문자를 나타내는 문자열을 돌려준다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">chr(97)</span></code> 은 문자열 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 를 돌려주고, <code class="docutils literal notranslate"><span class="pre">chr(8364)</span></code> 는 문자열 <code class="docutils literal notranslate"><span class="pre">'€'</span></code> 를 돌려준다. 이 것은 <a class="reference internal" href="#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a> 의 반대다.</p>
<p>인자의 유효 범위는 0에서 1,114,111(16진수로 0x10FFFF)까지다. <em>i</em> 가 이 범위 밖에 있을 때 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 가 발생한다.</p>
</dd></dl>

<dl class="function">
<dt id="classmethod">
<code class="descclassname">&#64;</code><code class="descname">classmethod</code><a class="headerlink" href="#classmethod" title="永久链接至目标">¶</a></dt>
<dd><p>메서드를 클래스 메서드로 변환한다.</p>
<p>인스턴스 메서드가 인스턴스를 받는 것처럼, 클래스 메서드는 클래스를 묵시적인 첫 번째 인자로 받는다. 클래스 메서드를 선언하려면 이 관용구를 사용한다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&#64;classmethod</span></code> 형식은 함수 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">데코레이터</span></a> 다 -- 자세한 내용은 <a class="reference internal" href="../reference/compound_stmts.html#function"><span class="std std-ref">함수 정의</span></a> 에 있는 함수 정의에 대한 설명을 보면 된다.</p>
<p>클래스 (<code class="docutils literal notranslate"><span class="pre">C.f()</span></code> 처럼) 또는 인스턴스 (<code class="docutils literal notranslate"><span class="pre">C().f()</span></code> 처럼) 를 통해 호출할 수 있다. 인스턴스는 클래스만 참조하고 무시된다. 파생 클래스에 대해 클래스 메서드가 호출되면, 파생 클래스 객체가 묵시적인 첫 번째 인자로 전달된다.</p>
<p>클래스 메서드는 C++ 또는 자바의 정적 메서드와 다르다. 그것들을 원하면, 이 섹션의 <a class="reference internal" href="#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a> 를 보기 바란다.</p>
<p>클래스 메서드에 대한 더 자세한 정보를 원하면, <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">표준형 계층</span></a> 에 있는 표준 형 계층에 대한 도큐멘테이션을 참고하기 바란다.</p>
</dd></dl>

<dl class="function">
<dt id="compile">
<code class="descname">compile</code><span class="sig-paren">(</span><em>source</em>, <em>filename</em>, <em>mode</em>, <em>flags=0</em>, <em>dont_inherit=False</em>, <em>optimize=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#compile" title="永久链接至目标">¶</a></dt>
<dd><p><em>source</em> 를 코드 또는 AST 객체로 컴파일한다. 코드 객체는 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 또는 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 로 실행할 수 있다. <em>source</em> 는 일반 문자열, 바이트열 또는 AST 객체 일 수 있다. AST 객체로 작업하는 방법에 대한 정보는 <a class="reference internal" href="ast.html#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 모듈 문서를 참조하면 된다.</p>
<p><em>filename</em> 인자는 코드를 읽은 파일을 제공해야 한다; 파일에서 읽지 않으면 인식 가능한 값을 전달한다 (<code class="docutils literal notranslate"><span class="pre">'&lt;string&gt;'</span></code> 이 일반적으로 사용된다).</p>
<p><em>mode</em> 인자는 컴파일해야 하는 코드 종류를 지정한다; <em>source</em> 가 문장의 시퀀스로 구성되어 있다면 <code class="docutils literal notranslate"><span class="pre">exec</span></code>, 단일 표현식으로 구성되어 있다면 <code class="docutils literal notranslate"><span class="pre">'eval'</span></code>, 단일 대화형 문장으로 구성되면 <code class="docutils literal notranslate"><span class="pre">'single'</span></code> 이 될 수 있다 (마지막의 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이외의 값으로 구해지는 표현식 문은 인쇄된다).</p>
<p>선택적 인자 <em>flags</em> 와 <em>dont_inherit</em> 는 어떤 퓨처 문(<span class="target" id="index-19"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0236"><strong>PEP 236</strong></a> 참조)이 <em>source</em> 의 컴파일에 영향을 미칠지 제어한다. 둘 다 제공되지 않는 경우 (또는 둘 다 0의 경우), 코드는 <a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 을 호출하는 코드에 적용되고 있는 퓨처 문으로 컴파일된다. <em>flags</em> 인자가 주어지고, <em>dont_inherit</em> 가 없으면 (또는 0) 원래 사용될 것에 더해 <em>flags</em> 인자로 지정된 퓨처 문이 사용된다. <em>dont_inherit</em> 가 0이 아닌 정수면 <em>flags</em> 인자가 사용된다 -- compile을 호출하는 코드에 적용되는 퓨처 문은 무시된다.</p>
<p>퓨처 문은 여러 개의 문장을 지정하기 위해 비트 OR 될 수 있는 비트에 의해 지정된다. 주어진 기능을 지정하는 데 필요한 비트 필드는 <a class="reference internal" href="__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a> 모듈의 <code class="xref py py-class docutils literal notranslate"><span class="pre">_Feature</span></code> 인스턴스에서 <code class="xref py py-attr docutils literal notranslate"><span class="pre">compiler_flag</span></code> 어트리뷰트로 찾을 수 있다.</p>
<p>인자 <em>optimize</em> 는 컴파일러의 최적화 수준을 지정한다; 기본값 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 은 <a class="reference internal" href="../using/cmdline.html#cmdoption-o"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> 옵션에 의해 주어진 인터프리터의 최적화 수준을 선택한다. 명시적 수준은 <code class="docutils literal notranslate"><span class="pre">0</span></code> (최적화 없음, <code class="docutils literal notranslate"><span class="pre">__debug__</span></code> 이 참이다), <code class="docutils literal notranslate"><span class="pre">1</span></code> (assert가 제거된다, <code class="docutils literal notranslate"><span class="pre">__debug__</span></code> 이 거짓이다) 또는 <code class="docutils literal notranslate"><span class="pre">2</span></code> 다 (독스트링도 제거된다).</p>
<p>이 함수는 컴파일된 소스가 올바르지 않으면 <a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 를 일으키고, 소스에 널 바이트가 들어있는 경우 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 를 일으킨다.</p>
<p>파이썬 코드를 AST 표현으로 파싱하려면, <a class="reference internal" href="ast.html#ast.parse" title="ast.parse"><code class="xref py py-func docutils literal notranslate"><span class="pre">ast.parse()</span></code></a> 를 참조하면 된다.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">'single'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'eval'</span></code> mode로 여러 줄 코드를 가진 문자열을 컴파일할 때, 적어도 하나의 개행 문자로 입력을 끝내야 한다. 이것은 <a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-mod docutils literal notranslate"><span class="pre">code</span></code></a> 모듈에서 문장이 불완전한지 완전한지를 쉽게 탐지하게 하기 위함이다.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">It is possible to crash the Python interpreter with a
sufficiently large/complex string when compiling to an AST
object due to stack depth limitations in Python's AST compiler.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.2 版更改: </span>윈도우 및 맥의 줄 바꿈을 사용할 수 있다. 또한, 이제는 <code class="docutils literal notranslate"><span class="pre">'exec'</span></code> mode에서 입력이 줄 넘김 문자로 끝나지 않아도 된다. <em>optimize</em> 파라미터가 추가되었다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.5 版更改: </span>이전에는, <em>source</em> 에서 널 바이트가 발견될 때 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 가 발생했다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="complex">
<em class="property">class </em><code class="descname">complex</code><span class="sig-paren">(</span><span class="optional">[</span><em>real</em><span class="optional">[</span>, <em>imag</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#complex" title="永久链接至目标">¶</a></dt>
<dd><p><em>real</em> + <em>imag</em>*1j 값을 가진 복소수를 돌려주거나 문자열 또는 숫자를 복소수로 변환한다. 첫 번째 파라미터가 문자열이면 복소수로 해석되며, 두 번째 파라미터 없이 함수를 호출해야 한다. 두 번째 파라미터는 결코 문자열 일 수 없다. 각 인자는 모든 (복소수를 포함한) 숫자 형이 될 수 있다. <em>imag</em> 가 생략되면 기본값은 0이고, 생성자는 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 와 <a class="reference internal" href="#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 와 같은 숫자 변환으로 사용된다. 두 인자가 모두 생략되면 <code class="docutils literal notranslate"><span class="pre">0j</span></code> 를 돌려준다.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">문자열을 변환할 때, 문자열은 중앙의 <code class="docutils literal notranslate"><span class="pre">+</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">-</span></code> 연산자 주위에 공백을 포함해서는 안 된다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">complex('1+2j')</span></code> 는 괜찮지만 <code class="docutils literal notranslate"><span class="pre">complex('1</span> <span class="pre">+</span> <span class="pre">2j')</span></code> 는 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 를 일으킨다.</p>
</div>
<p>복소수 형은 <a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">Numeric Types --- int, float, complex</span></a> 에서 설명한다.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.6 版更改: </span>코드 리터럴 처럼 숫자를 밑줄로 그룹화할 수 있다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="delattr">
<code class="descname">delattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#delattr" title="永久链接至目标">¶</a></dt>
<dd><p>이것은 <a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a> 의 친척뻘이다. 인자는 객체와 문자열이다. 문자열은 객체의 어트리뷰트 중 하나의 이름이어야 한다. 이 함수는 객체가 허용하는 경우 명명된 어트리뷰트를 삭제한다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">delattr(x,</span> <span class="pre">'foobar')</span></code> 는 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x.foobar</span></code> 와 동등하다.</p>
</dd></dl>

<span class="target" id="func-dict"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>**kwarg</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>mapping</em>, <em>**kwarg</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>iterable</em>, <em>**kwarg</em><span class="sig-paren">)</span></dt>
<dd><p>새 딕셔너리를 만든다. <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 객체는 딕셔너리 클래스다. 이 클래스에 대한 도큐멘테이션은 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 및 <a class="reference internal" href="stdtypes.html#typesmapping"><span class="std std-ref">Mapping Types --- dict</span></a> 을 참조하면 된다.</p>
<p>다른 컨테이너의 경우 <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 및 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 클래스와 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 모듈을 참조하기 바란다.</p>
</dd></dl>

<dl class="function">
<dt id="dir">
<code class="descname">dir</code><span class="sig-paren">(</span><span class="optional">[</span><em>object</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dir" title="永久链接至目标">¶</a></dt>
<dd><p>인자가 없으면, 현재 지역 스코프에 있는 이름들의 리스트를 돌려준다. 인자가 있으면, 해당 객체에 유효한 어트리뷰트들의 리스트를 돌려주려고 시도한다.</p>
<p>객체에 <a class="reference internal" href="../reference/datamodel.html#object.__dir__" title="object.__dir__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__dir__()</span></code></a> 메서드가 있으면, 이 메서드가 호출되는데, 반드시 어트리뷰트 리스트를 돌려줘야 한다. 이렇게 하면 커스텀 <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 또는 <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 함수를 구현하는 객체가 <a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 이 어트리뷰트들을 보고하는 방법을 커스터마이즈할 수 있다.</p>
<p>객체가 <a class="reference internal" href="../reference/datamodel.html#object.__dir__" title="object.__dir__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__dir__()</span></code></a> 을 제공하지 않으면, 함수는 (정의되었다면) 객체의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__</span> <span class="pre">dict__</span></code> 어트리뷰트와 형 객체로부터 정보를 수집하기 위해 최선을 다한다. 결과로 얻어지는 리스트는 반드시 완전하지는 않으며, 객체가 커스텀 <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 을 가질 때 부정확할 수도 있다.</p>
<p>기본 <a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 메커니즘은 다른 형의 객체에 대해서 다르게 동작하는데, 완전한 정보보다는 가장 적절한 정보를 만들려고 시도하기 때문이다:</p>
<ul class="simple">
<li>객체가 모듈 객체면, 리스트에는 모듈 어트리뷰트의 이름이 포함된다.</li>
<li>객체가 형 또는 클래스 객체면, 리스트에는 그것의 어트리뷰트 이름과 베이스의 어트리뷰트 이름들이 재귀적으로 포함된다.</li>
<li>그 밖의 경우, 리스트에는 객체의 어트리뷰트 이름, 해당 클래스의 어트리뷰트 이름 및 해당 클래스의 베이스 클래스들의 어트리뷰트 이름을 재귀적으로 포함한다.</li>
</ul>
<p>결과 리스트는 알파벳 순으로 정렬된다. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">()</span>   <span class="c1"># show the names in the module namespace</span>
<span class="go">[&#39;__builtins__&#39;, &#39;__name__&#39;, &#39;struct&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>   <span class="c1"># show the names in the struct module </span>
<span class="go">[&#39;Struct&#39;, &#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;,</span>
<span class="go"> &#39;__initializing__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;,</span>
<span class="go"> &#39;_clearcache&#39;, &#39;calcsize&#39;, &#39;error&#39;, &#39;pack&#39;, &#39;pack_into&#39;,</span>
<span class="go"> &#39;unpack&#39;, &#39;unpack_from&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Shape</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;perimeter&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;area&#39;, &#39;location&#39;, &#39;perimeter&#39;]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 은 주로 대화형 프롬프트에서의 사용 편의를 위해 제공되기 때문에, 엄격하거나 일관되게 정의된 이름 집합을 제공하기보다 흥미로운 이름 집합을 제공하려고 시도하며, 상세한 동작은 배포마다 변경될 수 있다. 예를 들어, 인자가 클래스면 메타 클래스 어트리뷰트는 결과 리스트에 없다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="divmod">
<code class="descname">divmod</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#divmod" title="永久链接至目标">¶</a></dt>
<dd><p>두 개의 (복소수가 아닌) 숫자를 인자로 취하고 정수 나누기를 사용할 때의 몫과 나머지로 구성된 한 쌍의 숫자를 돌려준다. 두 인자의 형이 다른 경우, 이 항 산술 연산자에 대한 규칙이 적용된다. 정수의 경우, 결과는 <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">//</span> <span class="pre">b,</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b)</span></code> 와 같다. 부동 소수점 숫자의 경우 결과는 <code class="docutils literal notranslate"><span class="pre">(q,</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b)</span></code> 인데, <em>q</em> 는 보통 <code class="docutils literal notranslate"><span class="pre">math.floor(a</span> <span class="pre">/</span> <span class="pre">b)</span></code> 이지만, 이보다 1작을 수 있다. 어떤 경우건 <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code> 는 <em>a</em> 에 매우 가깝다. <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code> 는 0이 아닐 때 <em>b</em> 와 같은 부호를 가지며, <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">abs(a</span> <span class="pre">%</span> <span class="pre">b)</span> <span class="pre">&lt;</span> <span class="pre">abs(b)</span></code> 가 성립한다.</p>
</dd></dl>

<dl class="function">
<dt id="enumerate">
<code class="descname">enumerate</code><span class="sig-paren">(</span><em>iterable</em>, <em>start=0</em><span class="sig-paren">)</span><a class="headerlink" href="#enumerate" title="永久链接至目标">¶</a></dt>
<dd><p>열거 객체를 돌려준다. <em>iterable</em> 은 시퀀스, <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">이터레이터</span></a> 또는 이터레이션을 지원하는 다른 객체여야 한다. <a class="reference internal" href="#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a> 에 의해 반환된 이터레이터의 <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 메서드는 카운트 (기본값 0을 갖는 <em>start</em> 부터)와 <em>iterable</em> 을 이터레이션 해서 얻어지는 값을 포함하는 튜플을 돌려준다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seasons</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Spring&#39;</span><span class="p">,</span> <span class="s1">&#39;Summer&#39;</span><span class="p">,</span> <span class="s1">&#39;Fall&#39;</span><span class="p">,</span> <span class="s1">&#39;Winter&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">seasons</span><span class="p">))</span>
<span class="go">[(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">seasons</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[(1, &#39;Spring&#39;), (2, &#39;Summer&#39;), (3, &#39;Fall&#39;), (4, &#39;Winter&#39;)]</span>
</pre></div>
</div>
<p>다음과 동등하다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">start</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">n</span><span class="p">,</span> <span class="n">elem</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>expression</em>, <em>globals=None</em>, <em>locals=None</em><span class="sig-paren">)</span><a class="headerlink" href="#eval" title="永久链接至目标">¶</a></dt>
<dd><p>인자는 문자열 및 선택적 globals 및 locals다. 제공된 경우, <em>globals</em> 는 딕셔너리여야 한다. 제공되는 경우, <em>locals</em> 는 모든 매핑 객체가 될 수 있다.</p>
<p><em>expression</em> 인자는 전역 및 지역 이름 공간으로 <em>globals</em> 및 <em>locals</em> 딕셔너리를 사용하여 파이썬 표현식(기술적으로 말하면, 조건 목록)으로 파싱 되고 값이 구해진다. <em>globals</em> 사전이 제공되고 '__builtins__' 가 없으면 <em>expression</em> 가 파싱 되기 전에 현재 전역 변수가 <em>globals</em> 에 복사된다. 이는 <em>expression</em> 이 일반적으로 표준 <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 모듈에 대한 모든 액세스 권한을 가지며 제한된 환경이 전파됨을 뜻한다. <em>locals</em> 딕셔너리를 생략하면 기본적으로 <em>globals</em> 딕셔너리가 사용된다. 두 딕셔너리가 모두 생략되면, 표현식은 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 이 호출되는 환경에서 실행된다. 반환 값은 계산된 표현식의 결과다. 문법 에러는 예외로 보고된다. 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;x+1&#39;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>이 함수는 임의의 코드 객체 (<a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 로 만든 것과 같은)를 실행하는 데에도 사용할 수 있다. 이 경우 문자열 대신 코드 객체를 전달한다. 코드 객체가 mode 인자 <code class="docutils literal notranslate"><span class="pre">'exec'</span></code> 로 컴파일되었다면, <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 의 반환 값은 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이다.</p>
<p>힌트: 문장의 동적 실행은 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 함수에 의해 지원된다. <a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a> 와 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 함수는 각각 현재의 전역과 지역 딕셔너리를 반환하는데, <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 또는 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 에 전달하는 데 유용하다.</p>
<p>리터럴 만 포함 된 표현식의 값을 안전하게 구할 수 있는 함수 <a class="reference internal" href="ast.html#ast.literal_eval" title="ast.literal_eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">ast.literal_eval()</span></code></a> 를 보기 바란다.</p>
</dd></dl>

<span class="target" id="index-2"></span><dl class="function">
<dt id="exec">
<code class="descname">exec</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>globals</em><span class="optional">[</span>, <em>locals</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#exec" title="永久链接至目标">¶</a></dt>
<dd><p>이 함수는 파이썬 코드의 동적 실행을 지원한다. <em>object</em> 는 문자열 또는 코드 객체여야 한다. 문자열이면 문자열은 파이썬 문장들의 스위트로 파싱된 후 (문법 에러가 발생하지 않는 한) 실행된다. <a class="footnote-reference" href="#id2" id="id1">[1]</a> 코드 객체면, 단순히 실행된다. 모든 경우에, 실행되는 코드는 파일 입력으로 올바를 것이 기대된다 (레퍼런스 설명서의 &quot;파일 입력&quot; 섹션 참조). <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 과 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 문은 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 함수에 전달 된 코드 문맥 안에서조차도 함수 정의 밖에서 사용될 수 없음에 유의해야 한다. 반환 값은 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이다.</p>
<p>모든 경우에, 선택적 부분을 생략하면, 현재 스코프에서 코드가 실행된다. <em>globals</em> 만 제공된 경우, 사전이어야 하며, 전역과 지역 변수 모두에 사용된다. <em>globals</em> 및 <em>locals</em> 가 주어지면, 전역과 지역 변수에 각각 사용된다. 제공되는 경우, <em>locals</em> 는 모든 매핑 객체가 될 수 있다. 모듈 수준에서, 전역과 지역은 같은 딕셔너리임을 기억해야 한다. exec 가 <em>globals</em> 와 <em>locals</em> 로 별도의 객체를 받으면, 코드는 클래스 정의에 포함된 것처럼 실행된다.</p>
<p><em>globals</em> 딕셔너리가 <code class="docutils literal notranslate"><span class="pre">__builtins__</span></code> 를 키로 하는 값을 갖고 있지 않으면, 그 키로 내장 모듈 <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 에 대한 참조가 삽입된다. 이런 식으로 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 에 전달하기 전에 <em>globals</em> 에 여러분 자신의 <code class="docutils literal notranslate"><span class="pre">__builtins__</span></code> 딕셔너리를 삽입함으로써, 실행되는 코드에 어떤 내장 객체들이 제공될지를 제어할 수 있다.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">내장 함수 <a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a> 와 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 는 각각 현재 전역 및 지역 딕셔너리를 돌려주는데, <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 로 전달되는 두 번째 및 세 번째 인자로 사용하는 데 유용하다.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">기본 <em>locals</em> 는 아래 함수 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 에 설명된 대로 작동한다: 기본 <em>locals</em> 사전에 대해 수정이 시도되어서는 안 된다. 함수 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 가 돌아온 후에 <em>locals</em> 에 코드가 만든 효과를 보려면 명시적으로 <em>locals</em> 딕셔너리를 전달해야 한다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>function</em>, <em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#filter" title="永久链接至目标">¶</a></dt>
<dd><p><em>function</em> 이 참을 돌려주는 <em>iterable</em> 의 요소들로 이터레이터를 구축한다. <em>iterable</em> 은 시퀀스, 이터레이션을 지원하는 컨테이너 또는 이터레이터 일 수 있다. <em>function</em> 이 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, 항등함수가 가정된다, 즉, 거짓인 <em>iterable</em> 의 모든 요소가 제거된다.</p>
<p><code class="docutils literal notranslate"><span class="pre">filter(function,</span> <span class="pre">iterable)</span></code> 는 function이 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 아닐 때 제너레이터 표현식 <code class="docutils literal notranslate"><span class="pre">(item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">iterable</span> <span class="pre">if</span> <span class="pre">function(item))</span></code> 과, <code class="docutils literal notranslate"><span class="pre">None</span></code> 일 때 <code class="docutils literal notranslate"><span class="pre">(item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">iterable</span> <span class="pre">if</span> <span class="pre">item)</span></code> 와 동등함에 유의하라.</p>
<p><em>function</em> 이 거짓을 돌려주는 <em>iterable</em> 의 요소들을 돌려주는 상보적인 함수는 <a class="reference internal" href="itertools.html#itertools.filterfalse" title="itertools.filterfalse"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.filterfalse()</span></code></a> 를 참조하라.</p>
</dd></dl>

<dl class="class">
<dt id="float">
<em class="property">class </em><code class="descname">float</code><span class="sig-paren">(</span><span class="optional">[</span><em>x</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#float" title="永久链接至目标">¶</a></dt>
<dd><p id="index-3">숫자 또는 문자열 <em>x</em> 로 부터 실수를 만들어 돌려준다.</p>
<p>인수가 문자열이면, 십진수를 포함해야 하고, 선택적으로 부호가 앞에 오며 선택적으로 공백으로 둘러싸일 수 있다. 선택적 부호는 <code class="docutils literal notranslate"><span class="pre">'+'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'-'</span></code> 일 수 있다; <code class="docutils literal notranslate"><span class="pre">'+'</span></code> 부호는 생성되는 값에 아무런 영향을 주지 않는다. 인자는 NaN (not-a-number) 또는 양 또는 음의 무한대를 나타내는 문자열 일 수도 있다. 더욱 정확하게, 입력은 앞과 뒤의 공백 문자를 제거한 후 다음 문법을 따라야 한다:</p>
<pre>
<strong id="grammar-token-sign">sign          </strong> ::=  &quot;+&quot; | &quot;-&quot;
<strong id="grammar-token-infinity">infinity      </strong> ::=  &quot;Infinity&quot; | &quot;inf&quot;
<strong id="grammar-token-nan">nan           </strong> ::=  &quot;nan&quot;
<strong id="grammar-token-numeric_value">numeric_value </strong> ::=  <a class="reference internal" href="../reference/lexical_analysis.html#grammar-token-floatnumber"><code class="xref docutils literal notranslate"><span class="pre">floatnumber</span></code></a> | <a class="reference internal" href="#grammar-token-infinity"><code class="xref docutils literal notranslate"><span class="pre">infinity</span></code></a> | <a class="reference internal" href="#grammar-token-nan"><code class="xref docutils literal notranslate"><span class="pre">nan</span></code></a>
<strong id="grammar-token-numeric_string">numeric_string</strong> ::=  [<a class="reference internal" href="#grammar-token-sign"><code class="xref docutils literal notranslate"><span class="pre">sign</span></code></a>] <a class="reference internal" href="#grammar-token-numeric_value"><code class="xref docutils literal notranslate"><span class="pre">numeric_value</span></code></a>
</pre>
<p>여기서 <code class="docutils literal notranslate"><span class="pre">floatnumber</span></code> 는 <a class="reference internal" href="../reference/lexical_analysis.html#floating"><span class="std std-ref">실수 리터럴</span></a> 에 설명된 파이썬 실수 리터럴의 형식이다. 대/소문자는 중요하지 않아서, 예를 들면, &quot;inf&quot;, &quot;Inf&quot;, &quot;INFINITY&quot; 및 &quot;iNfINity&quot;는 모두 양의 무한대에 대해 허용되는 철자다.</p>
<p>그렇지 않으면, 인자가 정수 또는 실수면 (파이썬의 부동 소수점 정밀도 내에서) 같은 값을 가진 실수가 반환된다. 인자가 파이썬 float 범위를 벗어나면, <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> 가 발생한다.</p>
<p>일반적인 파이썬 객체 <code class="docutils literal notranslate"><span class="pre">x</span></code> 의 경우, <code class="docutils literal notranslate"><span class="pre">float</span> <span class="pre">(x)</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">.__</span> <span class="pre">float</span> <span class="pre">__</span> <span class="pre">()</span></code> 로 위임한다.</p>
<p>인자가 주어지지 않으면, <code class="docutils literal notranslate"><span class="pre">0.0</span></code> 을 돌려준다.</p>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+1.23&#39;</span><span class="p">)</span>
<span class="go">1.23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;   -12345</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">-12345.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;1e-003&#39;</span><span class="p">)</span>
<span class="go">0.001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+1E6&#39;</span><span class="p">)</span>
<span class="go">1000000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-Infinity&#39;</span><span class="p">)</span>
<span class="go">-inf</span>
</pre></div>
</div>
<p>float 형은 <a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">Numeric Types --- int, float, complex</span></a> 에 설명되어 있다.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.6 版更改: </span>코드 리터럴 처럼 숫자를 밑줄로 그룹화할 수 있다.</p>
</div>
</dd></dl>

<span class="target" id="index-4"></span><dl class="function">
<dt id="format">
<code class="descname">format</code><span class="sig-paren">(</span><em>value</em><span class="optional">[</span>, <em>format_spec</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#format" title="永久链接至目标">¶</a></dt>
<dd><p><em>format_spec</em> 의 제어에 따라, <em>value</em> 를 &quot;포맷된&quot; 표현으로 변환한다. <em>format_spec</em> 의 해석은 <em>value</em> 인자의 형에 의존하지만, 대부분의 내장형에 의해 사용되는 표준 포매팅 문법이 있다: <a class="reference internal" href="string.html#formatspec"><span class="std std-ref">Format Specification Mini-Language</span></a>.</p>
<p>기본 <em>format_spec</em> 은 빈 문자열이며 일반적으로 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str(value)</span></code></a> 를 호출하는 것과 같은 효과를 준다.</p>
<p><code class="docutils literal notranslate"><span class="pre">format(value,</span> <span class="pre">format_spec)</span></code> 에 대한 호출은 <code class="docutils literal notranslate"><span class="pre">type(value).__format__(value,</span> <span class="pre">format_spec)</span></code> 로 번역되는데, value의 <a class="reference internal" href="../reference/datamodel.html#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a> 메서드를 검색할 때 인스턴스 딕셔너리를 건너뛴다. 메서드 검색이 <a class="reference internal" href="#object" title="object"><code class="xref py py-mod docutils literal notranslate"><span class="pre">object</span></code></a> 에 도달하고 <em>format_spec</em> 이 비어 있지 않거나, <em>format_spec</em> 또는 반환 값이 문자열이 아닌 경우 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 예외가 발생한다.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.4 版更改: </span><code class="docutils literal notranslate"><span class="pre">object().__format__(format_spec)</span></code> 은 <em>format_spec</em> 이 빈 문자열이 아닌 경우 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으킨다.</p>
</div>
</dd></dl>

<span class="target" id="func-frozenset"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">frozenset</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>새 <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> 객체를 돌려주는데, 선택적으로 <em>iterable</em> 에서 가져온 요소를 포함한다. <code class="docutils literal notranslate"><span class="pre">frozenset</span></code> 은 내장 클래스다. 이 클래스에 대한 도큐멘테이션은 <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> 과 <a class="reference internal" href="stdtypes.html#types-set"><span class="std std-ref">Set Types --- set, frozenset</span></a> 을 참조하면 된다.</p>
<p>다른 컨테이너의 경우 <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 및 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 클래스와 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 모듈을 참조하기 바란다.</p>
</dd></dl>

<dl class="function">
<dt id="getattr">
<code class="descname">getattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#getattr" title="永久链接至目标">¶</a></dt>
<dd><p>주어진 이름의 <em>object</em> 어트리뷰트를 돌려준다. <em>name</em> 은 문자열이어야 한다. 문자열이 객체의 어트리뷰트 중 하나의 이름이면, 결과는 그 어트리뷰트의 값이다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">getattr(x,</span> <span class="pre">'foobar')</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.foobar</span></code> 와 동등하다. 명명된 어트리뷰트가 없으면, <em>default</em> 가 제공되는 경우 그 값이 반환되고, 그렇지 않으면 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 가 발생한다.</p>
</dd></dl>

<dl class="function">
<dt id="globals">
<code class="descname">globals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#globals" title="永久链接至目标">¶</a></dt>
<dd><p>현재 전역 심볼 테이블을 나타내는 딕셔너리를 돌려준다. 이것은 항상 현재 모듈의 딕셔너리다 (함수 또는 메서드 내에서, 이 모듈은 그것들을 호출하는 모듈이 아니라, 그것들이 정의된 모듈이다).</p>
</dd></dl>

<dl class="function">
<dt id="hasattr">
<code class="descname">hasattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hasattr" title="永久链接至目标">¶</a></dt>
<dd><p>인자는 객체와 문자열이다. 문자열이 객체의 속성 중 하나의 이름이면 결과는``True` 이고, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code> 가 된다. (이것은 <code class="docutils literal notranslate"><span class="pre">getattr(object,</span> <span class="pre">name)</span></code> 을 호출하고 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 발생시키는지를 보는 식으로 구현된다.)</p>
</dd></dl>

<dl class="function">
<dt id="hash">
<code class="descname">hash</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#hash" title="永久链接至目标">¶</a></dt>
<dd><blockquote>
<div>객체의 해시값을 돌려준다 (해시가 있는 경우). 해시값은 정수다. 딕셔너리 조회 중에 딕셔너리 키를 빨리 비교하는 데 사용된다. 같다고 비교되는 숫자 값은 같은 해시값을 갖는다 (1과 1.0의 경우와 같이 형이 다른 경우조차도 그렇다).</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">커스텀 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드를 가진 객체의 경우, <a class="reference internal" href="#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 는 호스트 기계의 비트 폭을 기준으로 반환 값을 잘라 버리는 것에 주의해야 한다. 자세한 내용은 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 을 참조하라.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="help">
<code class="descname">help</code><span class="sig-paren">(</span><span class="optional">[</span><em>object</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#help" title="永久链接至目标">¶</a></dt>
<dd><p>내장 도움말 시스템을 호출한다. (이 함수는 대화형 사용을 위한 것이다.) 인자가 제공되지 않으면, 인터프리터 콘솔에서 대화형 도움말 시스템이 시작된다. 인자가 문자열이면 문자열은 모듈, 함수, 클래스, 메서드, 키워드 또는 도큐멘테이션 주제의 이름으로 조회되고, 도움말 페이지가 콘솔에 인쇄된다. 인자가 다른 종류의 객체면, 객체에 대한 도움말 페이지가 만들어진다.</p>
<p>이 함수는 <a class="reference internal" href="site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 모듈에 의해 내장 이름 공간에 추가된다.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.4 版更改: </span><a class="reference internal" href="pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 과 <a class="reference internal" href="inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 의 변경 사항은 콜러블의 시그니처가 이제 더 포괄적이고 일관성이 있음을 의미한다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="hex">
<code class="descname">hex</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#hex" title="永久链接至目标">¶</a></dt>
<dd><p>정수를 &quot;0x&quot; 접두사가 붙은 소문자 16진수 문자열로 변환한다. x가 파이썬 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 객체가 아니면, 정수를 돌려주는 __index __() 메서드를 정의해야 한다. 몇 가지 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>
<span class="go">&#39;0xff&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="o">-</span><span class="mi">42</span><span class="p">)</span>
<span class="go">&#39;-0x2a&#39;</span>
</pre></div>
</div>
<p>정수를 대문자 또는 소문자 16진수로, 접두사가 있거나 없는 형태로 변환하려면 다음 방법의 하나를 사용할 수 있다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%#x</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%x</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">255</span>
<span class="go">(&#39;0xff&#39;, &#39;ff&#39;, &#39;FF&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;#x&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="go">(&#39;0xff&#39;, &#39;ff&#39;, &#39;FF&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{255:#x}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{255:x}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{255:X}</span><span class="s1">&#39;</span>
<span class="go">(&#39;0xff&#39;, &#39;ff&#39;, &#39;FF&#39;)</span>
</pre></div>
</div>
<p>자세한 내용은 <a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 을 보면 된다.</p>
<p>16진수 문자열을 진수 16을 사용해서 정수로 변환하려면 <a class="reference internal" href="#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 도 참조하라.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">float에 대한 16진수 문자열 표현을 얻으려면, <a class="reference internal" href="stdtypes.html#float.hex" title="float.hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">float.hex()</span></code></a> 메서드를 사용한다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="id">
<code class="descname">id</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#id" title="永久链接至目标">¶</a></dt>
<dd><p>객체의 &quot;아이덴티티&quot;를 돌려준다. 이것은 객체의 수명 동안 유일하고 바뀌지 않음이 보장되는 정수다. 수명이 겹치지 않는 두 개의 객체는 같은 <a class="reference internal" href="#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> 값을 가질 수 있다.</p>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> This is the address of the object in memory.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="input">
<code class="descname">input</code><span class="sig-paren">(</span><span class="optional">[</span><em>prompt</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#input" title="永久链接至目标">¶</a></dt>
<dd><p><em>prompt</em> 인자가 있으면, 끝에 개행 문자를 붙이지 않고 표준 출력에 쓴다. 그런 다음 함수는 입력에서 한 줄을 읽고, 문자열로 변환해서 (줄 끝의 줄 바꿈 문자를 제거한다) 돌려준다. EOF를 읽으면 <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a> 를 일으킨다. 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;--&gt; &#39;</span><span class="p">)</span>  
<span class="go">--&gt; Monty Python&#39;s Flying Circus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">&quot;Monty Python&#39;s Flying Circus&quot;</span>
</pre></div>
</div>
<p><a class="reference internal" href="readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a> 모듈이 로드되었다면, <a class="reference internal" href="#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a> 은 그것을 사용하여 정교한 줄 편집과 히스토리 기능을 제공한다.</p>
</dd></dl>

<dl class="class">
<dt id="int">
<em class="property">class </em><code class="descname">int</code><span class="sig-paren">(</span><em>x=0</em><span class="sig-paren">)</span><a class="headerlink" href="#int" title="永久链接至目标">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">int</code><span class="sig-paren">(</span><em>x</em>, <em>base=10</em><span class="sig-paren">)</span></dt>
<dd><p>Return an integer object constructed from a number or string <em>x</em>, or return
<code class="docutils literal notranslate"><span class="pre">0</span></code> if no arguments are given.  If <em>x</em> is a number, return
<a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">x.__int__()</span></code></a>. If <em>x</em> defines
<a class="reference internal" href="../reference/datamodel.html#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">x.__trunc__()</span></code></a> but not
<a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">x.__int__()</span></code></a>, then return
if <a class="reference internal" href="../reference/datamodel.html#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">x.__trunc__()</span></code></a>.  For floating point numbers,
this truncates towards zero.</p>
<p><em>x</em> 가 숫자가 아니거나 <em>base</em> 가 주어지면, <em>x</em> 는 문자열, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, 또는 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 인스턴스여야 하는데, 진수 <em>base</em> 의 <a class="reference internal" href="../reference/lexical_analysis.html#integers"><span class="std std-ref">integer literal</span></a> 을 나타내야 한다. 선택적으로, 리터럴은 (사이에 공백 없이) <code class="docutils literal notranslate"><span class="pre">+</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">-</span></code> 를 앞에 붙일 수 있고, 앞뒤로 공백에 둘러싸일 수 있다. 진수-n 리터럴은 0에서 n-1까지의 숫자로 구성되며, <code class="docutils literal notranslate"><span class="pre">a</span></code> 에서 <code class="docutils literal notranslate"><span class="pre">z</span></code> (또는 <code class="docutils literal notranslate"><span class="pre">A</span></code> 에서 <code class="docutils literal notranslate"><span class="pre">Z</span></code>) 가 10에서 35 사이의 값을 가진다. 기본 <em>base</em> 는 10이다. 허용되는 값은 0과 2--36이다. 코드에서의 리터럴 처럼, 진수-2, -8 및 -16 리터럴에는 선택적으로 <code class="docutils literal notranslate"><span class="pre">0b</span></code>/<code class="docutils literal notranslate"><span class="pre">0B</span></code>, <code class="docutils literal notranslate"><span class="pre">0o</span></code>/<code class="docutils literal notranslate"><span class="pre">0O</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">0x</span></code>/<code class="docutils literal notranslate"><span class="pre">0X</span></code> 접두사가 붙을 수 있다. base 0은 코드 리터럴과 똑같이 해석하라는 뜻이기 때문에, 실제 진수는 2, 8, 10 또는 16이고, 그래서 <code class="docutils literal notranslate"><span class="pre">int('010',</span> <span class="pre">0)</span></code> 는 올바르지 않지만 <code class="docutils literal notranslate"><span class="pre">int('010',</span> <span class="pre">8)</span></code> 뿐만 아니라 <code class="docutils literal notranslate"><span class="pre">int('010')</span></code> 도 올바르다.</p>
<p>정수 형은 <a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">Numeric Types --- int, float, complex</span></a> 에 설명되어 있다.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.4 版更改: </span><em>base</em> 가 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 의 인스턴스가 아니고 <em>base</em> 객체가 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base.__index__</span></code></a> 메서드를 가지면, 그 진수로 쓸 정수를 얻기 위해 그 메서드를 호출한다. 예전 버전에서는 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base.__index__</span></code></a> 대신에 <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base.__int__</span></code></a> 가 사용되었다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.6 版更改: </span>코드 리터럴 처럼 숫자를 밑줄로 그룹화할 수 있다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="isinstance">
<code class="descname">isinstance</code><span class="sig-paren">(</span><em>object</em>, <em>classinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#isinstance" title="永久链接至目标">¶</a></dt>
<dd><p><em>object</em> 인자가 <em>classinfo</em> 인자 또는 그것의 (직접, 간접 혹은 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">가상</span></a>) 서브 클래스의 인스턴스면 참을 돌려준다. <em>object</em> 가 주어진 형의 객체가 아니면, 함수는 항상 거짓을 돌려준다. <em>classinfo</em> 가 형 객체들의 튜플 (또는 재귀적으로 이런 종류의 튜플이 중첩된 튜플) 이면, <em>object</em> 가 그 형 중 어느 하나의 인스턴스일 때 참을 돌려준다. <em>classinfo</em> 가 형이나, 형들의 튜플이나, 이런 튜플들의 튜플이 아니면, <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 예외를 일으킨다.</p>
</dd></dl>

<dl class="function">
<dt id="issubclass">
<code class="descname">issubclass</code><span class="sig-paren">(</span><em>class</em>, <em>classinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#issubclass" title="永久链接至目标">¶</a></dt>
<dd><p><em>class</em> 가 <em>classinfo</em> 의 서브 클래스 (직접, 간접 또는 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">가상</span></a>)면 참을 돌려준다. 클래스는 그 자체의 서브 클래스로 간주한다. <em>classinfo</em> 는 클래스 객체의 튜플 일 수 있다. 이 경우 <em>classinfo</em> 의 모든 항목이 검사된다. 다른 모든 경우에는, <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 예외가 발생한다.</p>
</dd></dl>

<dl class="function">
<dt id="iter">
<code class="descname">iter</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>sentinel</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#iter" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">이터레이터</span></a> 객체를 돌려준다. 첫 번째 인자는 두 번째 인자의 존재 여부에 따라 매우 다르게 해석된다. 두 번째 인자가 없으면, <em>object</em> 는 이터레이션 프로토콜 (<a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 메서드)을 지원하는 컬렉션 객체이거나 시퀀스 프로토콜 (0에서 시작하는 정수 인자를 받는 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 메서드)을 지원해야 한다. 이러한 프로토콜 중 아무것도 지원하지 않으면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 가 일어난다. 두 번째 인자 <em>sentinel</em> 이 주어지면, <em>object</em> 는 콜러블이어야 한다. 이 경우 만들어지는 이터레이터는 <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 메서드가 호출될 때마다 인자 없이 <em>object</em> 를 호출한다; 반환된 값이 <em>sentinel</em> 과 같으면, <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 을 일으키고, 그렇지 않으면 값을 돌려준다.</p>
<p><a class="reference internal" href="stdtypes.html#typeiter"><span class="std std-ref">Iterator Types</span></a> 도 참조하라.</p>
<p>두 번째 형태의 <a class="reference internal" href="#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 의 유용한 응용은 특정 줄에 도달할 때까지 파일의 줄을 읽는 것이다. 다음의 예는 <a class="reference internal" href="io.html#io.TextIOBase.readline" title="io.TextIOBase.readline"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> 메서드가 빈 문자열을 돌려줄 때까지 파일을 읽는다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;mydata.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">readline</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="n">process_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="len">
<code class="descname">len</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#len" title="永久链接至目标">¶</a></dt>
<dd><p>객체의 길이 (항목 수)를 돌려준다. 인자는 시퀀스 (문자열, 바이트열, 튜플, 리스트 또는 range 같은) 또는 컬렉션 (딕셔너리, 집합 또는 불변 집합 같은) 일 수 있다.</p>
</dd></dl>

<span class="target" id="func-list"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">list</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>함수이기보다, <a class="reference internal" href="stdtypes.html#typesseq-list"><span class="std std-ref">Lists</span></a> 와 <a class="reference internal" href="stdtypes.html#typesseq"><span class="std std-ref">Sequence Types --- list, tuple, range</span></a> 에 문서화 된 것처럼, <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 는 실제로는 가변 시퀀스 형이다.</p>
</dd></dl>

<dl class="function">
<dt id="locals">
<code class="descname">locals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#locals" title="永久链接至目标">¶</a></dt>
<dd><p>현재 지역 심볼 테이블을 나타내는 딕셔너리를 갱신하고 돌려준다. <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 이 함수 블록에서 호출될 때 자유 변수를 돌려주지만, 클래스 블록에서 호출할 때는 그렇지 않다.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">이 딕셔너리의 내용은 수정해서는 안 된다. 변경 사항은 인터프리터가 사용하는 지역 및 자유 변수의 값에 영향을 미치지 않을 수 있다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="map">
<code class="descname">map</code><span class="sig-paren">(</span><em>function</em>, <em>iterable</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#map" title="永久链接至目标">¶</a></dt>
<dd><p><em>iterable</em> 의 모든 항목에 <em>function</em> 을 적용한 후 그 결과를 돌려주는 이터레이터를 돌려준다. 추가 <em>iterable</em> 인자가 전달되면, <em>function</em> 은 그 수 만큼의 인자를 받아들여야 하고 모든 이터러블에서 병렬로 제공되는 항목들에 적용된다. 다중 이터러블의 경우, 이터레이터는 가장 짧은 이터러블이 모두 소모되면 멈춘다. 함수 입력이 이미 인자 튜플로 배치된 경우에는, <a class="reference internal" href="itertools.html#itertools.starmap" title="itertools.starmap"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.starmap()</span></code></a> 를 참조한다.</p>
</dd></dl>

<dl class="function">
<dt id="max">
<code class="descname">max</code><span class="sig-paren">(</span><em>iterable</em>, <em>*</em><span class="optional">[</span>, <em>key</em>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#max" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">max</code><span class="sig-paren">(</span><em>arg1</em>, <em>arg2</em>, <em>*args</em><span class="optional">[</span>, <em>key</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>iterable 에서 가장 큰 항목이나 두 개 이상의 인자 중 가장 큰 것을 돌려준다.</p>
<p>하나의 위치 인자가 제공되면, 그것은 <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">이터러블</span></a> 이어야 한다. iterable에서 가장 큰 항목을 돌려준다. 두 개 이상의 위치 인자가 제공되면, 위치 인자 중 가장 큰 것을 돌려준다.</p>
<p>선택적 키워드-전용 인자가 두 개 있다. <em>key</em> 인자는 <a class="reference internal" href="stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> 에 사용되는 것처럼 단일 인자 순서 함수를 지정한다. <em>default</em> 인자는 제공된 iterable이 비어있는 경우 돌려줄 객체를 지정한다. iterable이 비어 있고 <em>default</em> 가 제공되지 않으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 가 발생한다.</p>
<p>여러 항목이 최댓값이면, 함수는 처음 만난 항목을 돌려준다. 이것은 <code class="docutils literal notranslate"><span class="pre">sorted(iterable,</span> <span class="pre">key=keyfunc,</span> <span class="pre">reverse=True)[0]</span></code> 와 <code class="docutils literal notranslate"><span class="pre">heapq.nlargest(1,</span> <span class="pre">iterable,</span> <span class="pre">key=keyfunc)</span></code> 같은 다른 정렬 안정성 보존 도구와 일관성을 유지한다.</p>
<div class="versionadded">
<p><span class="versionmodified">3.4 新版功能: </span><em>default</em> 키워드-전용 인자.</p>
</div>
</dd></dl>

<span class="target" id="func-memoryview"></span><dl class="function">
<dt>
<code class="descname">memoryview</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span></dt>
<dd><p>지정된 인자로부터 만들어진 &quot;메모리 뷰&quot; 객체를 돌려준다. 자세한 정보는 <a class="reference internal" href="stdtypes.html#typememoryview"><span class="std std-ref">Memory Views</span></a> 를 보기 바란다.</p>
</dd></dl>

<dl class="function">
<dt id="min">
<code class="descname">min</code><span class="sig-paren">(</span><em>iterable</em>, <em>*</em><span class="optional">[</span>, <em>key</em>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#min" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">min</code><span class="sig-paren">(</span><em>arg1</em>, <em>arg2</em>, <em>*args</em><span class="optional">[</span>, <em>key</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>iterable 에서 가장 작은 항목이나 두 개 이상의 인자 중 가장 작은 것을 돌려준다.</p>
<p>하나의 위치 인자가 제공되면, 그것은 <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">이터러블</span></a> 이어야 한다. iterable에서 가장 작은 항목을 돌려준다. 두 개 이상의 위치 인자가 제공되면, 위치 인자 중 가장 작은 것을 돌려준다.</p>
<p>선택적 키워드-전용 인자가 두 개 있다. <em>key</em> 인자는 <a class="reference internal" href="stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> 에 사용되는 것처럼 단일 인자 순서 함수를 지정한다. <em>default</em> 인자는 제공된 iterable이 비어있는 경우 돌려줄 객체를 지정한다. iterable이 비어 있고 <em>default</em> 가 제공되지 않으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 가 발생한다.</p>
<p>여러 항목이 최솟값이면, 함수는 처음 만난 항목을 돌려준다. 이것은 <code class="docutils literal notranslate"><span class="pre">sorted(iterable,</span> <span class="pre">key=keyfunc)[0]</span></code> 와 <code class="docutils literal notranslate"><span class="pre">heapq.nsmallest(1,</span> <span class="pre">iterable,</span> <span class="pre">key=keyfunc)</span></code> 같은 다른 정렬 안정성 보존 도구와 일관성을 유지한다.</p>
<div class="versionadded">
<p><span class="versionmodified">3.4 新版功能: </span><em>default</em> 키워드-전용 인자.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="next">
<code class="descname">next</code><span class="sig-paren">(</span><em>iterator</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#next" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 메서드를 호출하여 <em>iterator</em> 에서 다음 항목을 꺼낸다. <em>default</em> 가 주어지면, iterator가 고갈될 때 돌려주고, 그렇지 않으면 <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 을 일으킨다.</p>
</dd></dl>

<dl class="class">
<dt id="object">
<em class="property">class </em><code class="descname">object</code><a class="headerlink" href="#object" title="永久链接至目标">¶</a></dt>
<dd><p>새 기능 없는 객체를 돌려준다. <a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 는 모든 클래스의 베이스 클래스다. 모든 파이썬 클래스의 인스턴스에 공통적인 메서드를 가지고 있다. 이 함수는 인자를 받아들이지 않는다.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 는 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 을 가지지 <em>않는다</em>. 그래서, <a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 클래스의 인스턴스에 임의의 어트리뷰트를 대입할 수 없다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="oct">
<code class="descname">oct</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#oct" title="永久链接至目标">¶</a></dt>
<dd><p>정수를 &quot;0o&quot;로 시작하는 8진수 문자열로 변환한다. 결과는 올바른 파이썬 표현식이다. <em>x</em> 가 파이썬 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 객체가 아니면, 정수를 돌려주는 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> 메서드를 정의해야 한다. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">oct</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="go">&#39;0o10&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">oct</span><span class="p">(</span><span class="o">-</span><span class="mi">56</span><span class="p">)</span>
<span class="go">&#39;-0o70&#39;</span>
</pre></div>
</div>
<p>정수를 접두사 &quot;0o&quot;가 있거나 없는 형태의 8진수 문자열로 변환하려면, 다음 방법의 하나를 사용할 수 있다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%#o</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%o</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">10</span>
<span class="go">(&#39;0o12&#39;, &#39;12&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;#o&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">(&#39;0o12&#39;, &#39;12&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{10:#o}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{10:o}</span><span class="s1">&#39;</span>
<span class="go">(&#39;0o12&#39;, &#39;12&#39;)</span>
</pre></div>
</div>
<p>자세한 내용은 <a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 을 보면 된다.</p>
<blockquote>
<div><span class="target" id="index-5"></span></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="open">
<code class="descname">open</code><span class="sig-paren">(</span><em>file</em>, <em>mode='r'</em>, <em>buffering=-1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>, <em>closefd=True</em>, <em>opener=None</em><span class="sig-paren">)</span><a class="headerlink" href="#open" title="永久链接至目标">¶</a></dt>
<dd><p><em>file</em> 을 열고 해당 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a> 를 돌려준다. 파일을 열 수 없으면, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 가 발생한다.</p>
<p><em>file</em> 은 열 파일의 경로명(절대 혹은 현재 작업 디렉터리에 상대적인)을 주는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a> 거나, 감쌀 파일의 정수 파일 디스크립터다. (파일 디스크립터가 주어지면, <em>closefd</em> 가 <code class="docutils literal notranslate"><span class="pre">False</span></code> 가 아닌 한, 반환된 I/O 객체가 닫힐 때 닫힌다.)</p>
<p><em>mode</em> 는 파일이 열리는 모드를 지정하는 선택적 문자열이다. 기본값은 <code class="docutils literal notranslate"><span class="pre">'r'</span></code> 인데, 텍스트 모드로 읽기 위해 여는 것을 뜻한다. 다른 일반적인 값은 쓰기 위한 <code class="docutils literal notranslate"><span class="pre">'w'</span></code> (파일이 이미 존재하는 경우 파일을 자른다), 독점적 파일 만들기를 위한 <code class="docutils literal notranslate"><span class="pre">'x'</span></code> 및 덧붙이기를 위한 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> (<em>일부</em> 유닉스 시스템에서, 현재 위치와 관계없이 <em>모든</em> 쓰기가 파일의 끝에 덧붙여짐을 뜻한다) 다. 텍스트 모드에서, <em>encoding</em> 을 지정하지 않으면 사용되는 인코딩은 플랫폼에 따라 다르다: 현재 로케일 인코딩을 얻기 위해 <code class="docutils literal notranslate"><span class="pre">locale.getpreferredencoding(False)</span></code> 가 호출된다. (날 바이트열을 읽고 쓰려면 바이너리 모드를 사용하고 <em>encoding</em> 을 지정하지 않는다.) 사용 가능한 모드는 다음과 같다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">문자</th>
<th class="head">의미</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'r'</span></code></td>
<td>읽기용으로 연다 (기본값)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'w'</span></code></td>
<td>쓰기용으로 연다, 파일을 먼저 자른다.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'x'</span></code></td>
<td>독점적인 파일 만들기용으로 연다, 이미 존재하는 경우에는 실패한다.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'a'</span></code></td>
<td>쓰기용으로 연다, 파일이 존재하는 경우는 파일의 끝에 덧붙인다</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'b'</span></code></td>
<td>바이너리 모드</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'t'</span></code></td>
<td>텍스트 모드 (기본값)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'+'</span></code></td>
<td>갱신(읽기 및 쓰기)용으로 디스크 파일을 연다</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'U'</span></code></td>
<td><a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">유니버설 줄 넘김</span></a> 모드 (디프리케이트 되었다)</td>
</tr>
</tbody>
</table>
<p>기본 모드는 <code class="docutils literal notranslate"><span class="pre">'r'</span></code> 이다 (텍스트를 읽는 용으로 연다, <code class="docutils literal notranslate"><span class="pre">'rt'</span></code> 의 동의어). 바이너리 읽기-쓰기 액세스의 경우는, 모드 <code class="docutils literal notranslate"><span class="pre">'w+b'</span></code> 는 파일을 열면서 0바이트로 자른다. <code class="docutils literal notranslate"><span class="pre">'r+b'</span></code> 는 자르지 않고 파일을 연다.</p>
<p><a class="reference internal" href="io.html#io-overview"><span class="std std-ref">Overview</span></a> 에서 언급했듯이, 파이썬은 바이너리와 텍스트 I/O를 구별한다. 바이너리 모드 (<em>mode</em> 인자에 <code class="docutils literal notranslate"><span class="pre">'b'</span></code> 를 포함한다)로 열린 파일은 내용을 디코딩 없이 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체로 돌려준다. 텍스트 모드 (기본값, 또는 <em>mode</em> 인자에 <code class="docutils literal notranslate"><span class="pre">'t'</span></code> 가 포함될 때)에서는, 파일의 내용이 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 로 반환되는데, 바이트 열이 플랫폼 의존적인 인코딩이나 주어진 <em>encoding</em> 을 사용해서 먼저 디코드 된다.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">파이썬은 하위 운영 체제의 텍스트 파일 개념에 의존하지 않는다. 모든 처리는 파이썬 자체에 의해 수행되므로 플랫폼에 독립적이다.</p>
</div>
<p><em>buffering</em> 은 버퍼링 정책을 설정하는 데 사용되는 선택적 정수다. 버퍼링을 끄려면 (바이너리 모드에서만 허용) 0을 전달하고, 줄 버퍼링 (텍스트 모드에서만 사용 가능)을 선택하려면 1을, 고정 크기 청크 버퍼를 선택하려면 그 크기를 바이트 단위로 표시한 정수 &gt; 1을 전달한다. <em>buffering</em> 인자가 제공되지 않을 때, 기본 버퍼링 정책은 다음과 같이 작동한다:</p>
<ul class="simple">
<li>바이너리 파일은 고정 크기 청크로 버퍼링 된다. 버퍼의 크기는 하부 장치의 &quot;블록 크기&quot;를 파악하려고 시도하는 경험적인 방법을 사용해서 선택되고 <a class="reference internal" href="io.html#io.DEFAULT_BUFFER_SIZE" title="io.DEFAULT_BUFFER_SIZE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">io.DEFAULT_BUFFER_SIZE</span></code></a> 으로 폴백된다. 많은 시스템에서, 버퍼는 일반적으로 4096 또는 8192바이트 길이다.</li>
<li>&quot;대화형&quot; 텍스트 파일 (<a class="reference internal" href="io.html#io.IOBase.isatty" title="io.IOBase.isatty"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isatty()</span></code></a> 가 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 돌려주는 파일)은 줄 버퍼링을 사용한다. 다른 텍스트 파일은 바이너리 파일에 대해 위에서 설명한 정책을 사용한다.</li>
</ul>
<p><em>encoding</em> 은 파일을 디코딩하거나 인코딩하는 데 사용되는 인코딩의 이름이다. 텍스트 모드에서만 사용해야 한다. 기본 인코딩은 플랫폼에 따라 다르지만 (<a class="reference internal" href="locale.html#locale.getpreferredencoding" title="locale.getpreferredencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.getpreferredencoding()</span></code></a> 이 돌려주는 값), 파이썬에서 지원하는 <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a> 은 모두 사용할 수 있다. 지원되는 인코딩 목록은 <a class="reference internal" href="codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> 모듈을 보면 된다.</p>
<p><em>errors</em> 는 인코딩 및 디코딩 에러를 처리하는 방법을 지정하는 선택적 문자열이다. 바이너리 모드에서는 사용할 수 없다. 다양한 표준 에러 처리기가 제공된다 (<a class="reference internal" href="codecs.html#error-handlers"><span class="std std-ref">Error Handlers</span></a> 에 나열된다). 하지만, <a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.register_error()</span></code></a> 로 등록된 에러 처리기 이름 역시 사용할 수 있다. 표준 이름은 다음과 같다:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">'strict'</span></code> 는 인코딩 에러가 있는 경우 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 예외를 발생시킨다. 기본값 <code class="docutils literal notranslate"><span class="pre">None</span></code> 은 같은 효과를 낸다.</li>
<li><code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> 는 에러를 무시한다. 인코딩 에러를 무시하면 데이터가 손실될 수 있음에 주의해야 한다.</li>
<li><code class="docutils literal notranslate"><span class="pre">'replace'</span></code> 는 잘못된 데이터가 있는 자리에 대체 마커(<code class="docutils literal notranslate"><span class="pre">'?'</span></code> 와 같은)를 삽입한다.</li>
<li><code class="docutils literal notranslate"><span class="pre">'surrogateescape'</span></code> 는 U+DC80에서 U+DCFF까지의 유니코드 개인 사용 영역의 코드 포인트로 잘못된 바이트를 나타낸다. 데이터를 쓸 때 <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code> 에러 처리기가 사용되면, 이 개인 코드 포인트들은 원래의 바이트로 되돌아간다. 알 수 없는 인코딩의 파일을 처리할 때 유용하다.</li>
<li><code class="docutils literal notranslate"><span class="pre">'xmlcharrefreplace'</span></code> 는 파일에 쓸 때만 지원된다. 인코딩이 지원하지 않는 문자는 적절한 XML 문자 참조 <code class="docutils literal notranslate"><span class="pre">&amp;#nnn;</span></code> 로 대체된다.</li>
<li><code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code> 는 잘못된 데이터를 파이썬의 역 슬래시 이스케이프 시퀀스로 대체한다.</li>
<li><code class="docutils literal notranslate"><span class="pre">'namereplace'</span></code> (역시 파일에 쓸 때만 지원된다)는 지원되지 않는 문자를 <code class="docutils literal notranslate"><span class="pre">\N{...}</span></code> 이스케이프 시퀀스로 대체한다.</li>
</ul>
<p id="index-6"><em>newline</em> 은 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">유니버설 줄 넘김</span></a> 모드가 작동하는 방식을 제어한다 (텍스트 모드에만 적용된다). <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">''</span></code>, <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>, <code class="docutils literal notranslate"><span class="pre">'\r'</span></code> 및 `` <code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code> 일 수 있다. 다음과 같이 작동한다:</p>
<ul class="simple">
<li>스트림에서 입력을 읽을 때, <em>newline</em> 이 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, 유니버설 줄 넘김 모드가 활성화된다. 입력에 있는 줄은 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>, <code class="docutils literal notranslate"><span class="pre">'\r'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code> 로 끝날 수 있으며, 호출자에게 돌려주기 전에 모두 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 로 변환된다. 그것이 <code class="docutils literal notranslate"><span class="pre">''</span></code> 이면, 유니버설 줄 넘김 모드가 활성화되지만, 줄 끝은 변환되지 않은 채로 호출자에게 반환된다. 다른 유효한 값이면, 입력 줄은 주어진 문자열로만 끝나며, 줄 끝은 변환되지 않은 채로 호출자에게 돌려준다.</li>
<li>스트림에 출력을 쓸 때, <em>newline</em> 이 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, 모든 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 문자는 시스템 기본 줄 구분자인 <a class="reference internal" href="os.html#os.linesep" title="os.linesep"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.linesep</span></code></a> 로 변환된다. <em>newline</em> 이 <code class="docutils literal notranslate"><span class="pre">''</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 이면, 변환이 이루어지지 않는다. <em>newline</em> 이 다른 유효한 값이면, 쓰이는 모든 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 문자는 주어진 문자열로 변환된다.</li>
</ul>
<p><em>closefd</em> 가 <code class="docutils literal notranslate"><span class="pre">False</span></code> 이고 파일명 대신 파일 디스크립터가 주어지면, 파일이 닫힐 때 하위 파일 디스크립터가 열려있게 된다. 파일명이 주어지면 <em>closefd</em> 는 <code class="docutils literal notranslate"><span class="pre">True</span></code> (기본값) 여야 한다. 그렇지 않으면 에러가 발생한다.</p>
<p>콜러블을 <em>opener</em> 로 전달하여 커스텀 오프너를 사용할 수 있다. 파일 객체를 위한 하위 파일 디스크립터는 <em>opener</em> 를 (<em>file</em>, <em>flags</em>) 로 호출해서 얻는다. <em>opener</em> 는 열린 파일 디스크립터를 반환해야 한다 (<em>opener</em> 에 <a class="reference internal" href="os.html#os.open" title="os.open"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.open</span></code></a> 을 전달하는 것은 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 전달하는 것과 비슷한 기능을 수행하게 된다).</p>
<p>새로 만들어진 파일은 <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">상속 불가능</span></a> 하다.</p>
<p>다음 예는 주어진 디렉터리에 상대적인 파일을 열기 위해 <a class="reference internal" href="os.html#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a> 함수의 <a class="reference internal" href="os.html#dir-fd"><span class="std std-ref">dir_fd</span></a> 파라미터를 사용한다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dir_fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;somedir&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_RDONLY</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">opener</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">dir_fd</span><span class="o">=</span><span class="n">dir_fd</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;spamspam.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">opener</span><span class="o">=</span><span class="n">opener</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;This will be written to somedir/spamspam.txt&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">dir_fd</span><span class="p">)</span>  <span class="c1"># don&#39;t leak a file descriptor</span>
</pre></div>
</div>
<p><a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 함수에 의해 반환된 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a> 의 형은 모드에 의존한다. <a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 이 텍스트 모드(<code class="docutils literal notranslate"><span class="pre">'w'</span></code>, <code class="docutils literal notranslate"><span class="pre">'r'</span></code>, <code class="docutils literal notranslate"><span class="pre">'wt'</span></code>, <code class="docutils literal notranslate"><span class="pre">'rt'</span></code>, 등)로 파일을 여는 데 사용되면, <a class="reference internal" href="io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a> 의 서브 클래스를 돌려준다 (구체적으로 <a class="reference internal" href="io.html#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOWrapper</span></code></a>). 버퍼링과 함께 바이너리 모드로 파일을 여는 데 사용되는 경우, 반환되는 클래스는 <a class="reference internal" href="io.html#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedIOBase</span></code></a> 의 서브 클래스다. 정확한 클래스는 다양하다: 읽기 바이너리 모드에서는, <a class="reference internal" href="io.html#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedReader</span></code></a> 를 돌려준다; 쓰기 바이너리와 덧붙이기 바이너리 모드에서는, <a class="reference internal" href="io.html#io.BufferedWriter" title="io.BufferedWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedWriter</span></code></a> 를 돌려주고, 읽기/쓰기 모드에서는, <a class="reference internal" href="io.html#io.BufferedRandom" title="io.BufferedRandom"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedRandom</span></code></a> 을 돌려준다. 버퍼링을 끄면, 날 스트림, <a class="reference internal" href="io.html#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.RawIOBase</span></code></a> 의 서브 클래스, <a class="reference internal" href="io.html#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.FileIO</span></code></a>, 을 돌려준다.</p>
<p id="index-7"><a class="reference internal" href="fileinput.html#module-fileinput" title="fileinput: Loop over standard input or a list of files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">fileinput</span></code></a>, <a class="reference internal" href="io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> (<a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 이 선언된 곳), <a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a>, <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.path</span></code></a>, <a class="reference internal" href="tempfile.html#module-tempfile" title="tempfile: Generate temporary files and directories."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tempfile</span></code></a>, 그리고 <a class="reference internal" href="shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a> 와 같은 파일 처리 모듈들도 보기 바란다.</p>
<div class="versionchanged">
<blockquote>
<div><span class="versionmodified">在 3.3 版更改: </span><ul class="simple">
<li><em>opener</em> 파라미터가 추가되었다.</li>
<li><code class="docutils literal notranslate"><span class="pre">'x'</span></code> 모드가 추가되었다.</li>
<li><a class="reference internal" href="exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a> 를 일으켜왔다. 이제는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 의 별칭이다.</li>
<li>독점적 파일 만들기 모드(<code class="docutils literal notranslate"><span class="pre">'x'</span></code>)로 여는 파일이 이미 존재하면, 이제 <a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileExistsError</span></code></a> 를 일으킨다.</li>
</ul>
</div></blockquote>
</div>
<div class="versionchanged">
<blockquote>
<div><span class="versionmodified">在 3.4 版更改: </span><ul class="simple">
<li>파일은 이제 상속 불가능하다.</li>
</ul>
</div></blockquote>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.4, will be removed in version 4.0: </span><code class="docutils literal notranslate"><span class="pre">'U'</span></code> 모드.</p>
</div>
<div class="versionchanged">
<blockquote>
<div><span class="versionmodified">在 3.5 版更改: </span><ul class="simple">
<li>시스템 호출이 인터럽트 되고 시그널 처리기가 예외를 발생시키지 않으면, 이 함수는 이제 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> 예외를 일으키는 대신 시스템 호출을 재시도한다 (이유는 <span class="target" id="index-20"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> 참조).</li>
<li><code class="docutils literal notranslate"><span class="pre">'namereplace'</span></code> 오류 처리기가 추가되었다.</li>
</ul>
</div></blockquote>
</div>
<div class="versionchanged">
<blockquote>
<div><span class="versionmodified">在 3.6 版更改: </span><ul class="simple">
<li><a class="reference internal" href="os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> 를 구현하는 객체를 받아들이도록 지원이 추가되었다.</li>
<li>윈도우에서, 콘솔 버퍼를 열면 <a class="reference internal" href="io.html#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.FileIO</span></code></a> 가 아닌 <a class="reference internal" href="io.html#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.RawIOBase</span></code></a> 의 서브 클래스가 반환될 수 있다.</li>
</ul>
</div></blockquote>
</div>
</dd></dl>

<dl class="function">
<dt id="ord">
<code class="descname">ord</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#ord" title="永久链接至目标">¶</a></dt>
<dd><p>하나의 유니코드 문자를 나타내는 문자열이 주어지면 해당 문자의 유니코드 코드 포인트를 나타내는 정수를 돌려준다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">ord('a')</span></code> 는 정수 <code class="docutils literal notranslate"><span class="pre">97</span></code> 을 반환하고 <code class="docutils literal notranslate"><span class="pre">ord('€')</span></code> (유로 기호)는 <code class="docutils literal notranslate"><span class="pre">8364</span></code> 를 반환한다. 이것은 <a class="reference internal" href="#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a> 의 반대다.</p>
</dd></dl>

<dl class="function">
<dt id="pow">
<code class="descname">pow</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="optional">[</span>, <em>z</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#pow" title="永久链接至目标">¶</a></dt>
<dd><p><em>x</em> 의 <em>y</em> 거듭제곱을 돌려준다; <em>z</em> 가 있는 경우, <em>x</em> 의 <em>y</em> 거듭제곱의 모듈로 <em>z</em> 를 돌려준다 (<code class="docutils literal notranslate"><span class="pre">pow(x,</span> <span class="pre">y)</span> <span class="pre">%</span> <span class="pre">z</span></code> 보다 더 빠르게 계산된다). 두 개의 인자 형식인 <code class="docutils literal notranslate"><span class="pre">pow</span> <span class="pre">(x,</span> <span class="pre">y)</span></code> 는 거듭제곱 연산자를 사용하는 것과 동등하다: <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">**</span> <span class="pre">y</span></code>.</p>
<p>인자는 숫자 형이어야 한다. 피연산자들의 형이 다를 경우, 이 항 산술 연산자에 대한 코어션 규칙이 적용된다. <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 피연산자들의 경우, 결과는 두 번째 인자가 음수가 아닌 한 피연산자와 같은 형 (코어션 후에)이 된다; 두 번째 인자가 음수면 모든 인자가 float로 변환되고 float 결과가 전달된다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">10**2</span></code> 는 <code class="docutils literal notranslate"><span class="pre">100</span></code> 을 반환하지만, <code class="docutils literal notranslate"><span class="pre">10**-2``는</span> <span class="pre">``0.01</span></code> 을 반환한다. 두 번째 인자가 음수면 세 번째 인수는 생략해야 한다. <em>z</em> 가 있는 경우, <em>x</em> 및 <em>y</em> 는 정수형이어야 하고, <em>y</em> 는 음수가 아니어야 한다.</p>
</dd></dl>

<dl class="function">
<dt id="print">
<code class="descname">print</code><span class="sig-paren">(</span><em>*objects</em>, <em>sep=' '</em>, <em>end='\n'</em>, <em>file=sys.stdout</em>, <em>flush=False</em><span class="sig-paren">)</span><a class="headerlink" href="#print" title="永久链接至目标">¶</a></dt>
<dd><p><em>objects</em> 를 텍스트 스트림 <em>file</em> 로 인쇄하는데, <em>sep</em> 로 구분되고 <em>end</em> 를 뒤에 붙인다. 있다면, <em>sep</em>, <em>end</em>, <em>file</em> 및 <em>flush</em> 는 반드시 키워드 인자로 제공해야 한다.</p>
<p>모든 비 키워드 인자는 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 이 하듯이 문자열로 변환된 후 스트림에 쓰이는데, <em>sep</em> 로 구분되고 <em>end</em> 를 뒤에 붙인다. <em>sep</em> 과 <em>end</em> 는 모두 문자열이어야 한다; <code class="docutils literal notranslate"><span class="pre">None</span></code> 일 수도 있는데, 기본값을 사용한다는 뜻이다. <em>objects</em> 가 주어지지 않으면 <a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 는 <em>end</em> 만 쓴다.</p>
<p><em>file</em> 인자는 <code class="docutils literal notranslate"><span class="pre">write(string)</span></code> 메서드를 가진 객체여야 한다; 존재하지 않거나 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a> 이 사용된다. 인쇄된 인자는 텍스트 문자열로 변환되기 때문에, <a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 는 바이너리 모드 파일 객체와 함께 사용할 수 없다. 이를 위해서는. 대신 <code class="docutils literal notranslate"><span class="pre">file.write(...)</span></code> 를 사용한다.</p>
<p>출력의 버퍼링 여부는 일반적으로 <em>file</em> 에 의해 결정되지만, <em>flush</em> 키워드 인자가 참이면 스트림이 강제로 플러시 된다.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span><em>flush</em> 키워드 인자가 추가되었다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="property">
<em class="property">class </em><code class="descname">property</code><span class="sig-paren">(</span><em>fget=None</em>, <em>fset=None</em>, <em>fdel=None</em>, <em>doc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#property" title="永久链接至目标">¶</a></dt>
<dd><p>프로퍼티 어트리뷰트를 돌려준다.</p>
<p><em>fget</em> 은 어트리뷰트 값을 얻는 함수다. <em>fset</em> 은 어트리뷰트 값을 설정하는 함수다. <em>fdel</em> 은 어트리뷰트 값을 삭제하는 함수다. 그리고 <em>doc</em> 은 어트리뷰트의 독스트링을 만든다.</p>
<p>전형적인 사용은 관리되는 어트리뷰트 <code class="docutils literal notranslate"><span class="pre">x</span></code> 를 정의하는 것이다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">getx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="k">def</span> <span class="nf">setx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">delx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="n">x</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">getx</span><span class="p">,</span> <span class="n">setx</span><span class="p">,</span> <span class="n">delx</span><span class="p">,</span> <span class="s2">&quot;I&#39;m the &#39;x&#39; property.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><em>c</em> 가 <em>C</em> 의 인스턴스면, <code class="docutils literal notranslate"><span class="pre">c.x</span></code> 는 게터(getter)를 호출하고, <code class="docutils literal notranslate"><span class="pre">cx</span> <span class="pre">=</span> <span class="pre">value</span></code> 는 세터(setter)를 호출하고, <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">c.x</span></code> 는 딜리터(deleter)를 호출한다.</p>
<p>주어진 경우, <em>doc</em> 은 프로퍼티 어트리뷰트의 독스트링이 된다. 그렇지 않으면, <em>fget</em> 의 독스트링(있는 경우)이 복사된다. 이렇게 하면 <a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> 를 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">데코레이터</span></a> 로 사용하여 읽기 전용 프로퍼티를 쉽게 만들 수 있다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parrot</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_voltage</span> <span class="o">=</span> <span class="mi">100000</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the current voltage.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_voltage</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&#64;property</span></code> 데코레이터는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">voltage()</span></code> 메서드를 같은 이름의 읽기 전용 어트리뷰트에 대한 &quot;게터&quot;로 바꾸고, <em>voltage</em> 에 대한 독스트링을 &quot;Get the current voltage.&quot; 로 설정한다.</p>
<p>프로퍼티 객체는 데코레이터로 사용할 수 있는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">getter</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">setter</span></code> 및 <code class="xref py py-attr docutils literal notranslate"><span class="pre">deleter</span></code> 메서드를 갖는데, 해당 접근자 함수를 데코레이트 된 함수로 설정한 프로퍼티의 사본을 만든다. 이것은 예제로 가장 잘 설명된다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;I&#39;m the &#39;x&#39; property.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
</pre></div>
</div>
<p>이 코드는 첫 번째 예제와 정확히 동등하다. 추가적인 함수들에 원래 프로퍼티(이 경우 <code class="docutils literal notranslate"><span class="pre">x</span></code>)와 같은 이름을 사용해야 한다.</p>
<p>반환된 프로퍼티 객체는 생성자 인자에 해당하는 <code class="docutils literal notranslate"><span class="pre">fget</span></code>, <code class="docutils literal notranslate"><span class="pre">fset</span></code> 및 <code class="docutils literal notranslate"><span class="pre">fdel</span></code> 어트리뷰트를 가진다.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.5 版更改: </span>이제 프로퍼티 개체의 독스트링이 쓰기 가능하다.</p>
</div>
</dd></dl>

<span class="target" id="func-range"></span><dl class="function">
<dt>
<code class="descname">range</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span></dt>
<dt>
<code class="descname">range</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>함수라기보다, <a class="reference internal" href="stdtypes.html#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a> 는 실제로는 <a class="reference internal" href="stdtypes.html#typesseq-range"><span class="std std-ref">Ranges</span></a> 와 <a class="reference internal" href="stdtypes.html#typesseq"><span class="std std-ref">Sequence Types --- list, tuple, range</span></a> 에 설명된 대로 불변 시퀀스 형이다.</p>
</dd></dl>

<dl class="function">
<dt id="repr">
<code class="descname">repr</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#repr" title="永久链接至目标">¶</a></dt>
<dd><p>객체의 인쇄 가능한 표현을 포함한 문자열을 돌려준다. 많은 형에서, 이 함수는 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 에 전달 될 때 같은 값을 가진 객체를 생성하는 문자열을 반환하려고 시도한다, 그렇지 않으면 표현은 객체의 형의 이름과 종종 객체의 이름과 주소를 포함하는 추가의 정보를 화살괄호로 묶은 문자열이다. 클래스는 <a class="reference internal" href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 메서드를 정의하여 이 함수가 인스턴스에 대해 돌려주는 것을 제어할 수 있다.</p>
</dd></dl>

<dl class="function">
<dt id="reversed">
<code class="descname">reversed</code><span class="sig-paren">(</span><em>seq</em><span class="sig-paren">)</span><a class="headerlink" href="#reversed" title="永久链接至目标">¶</a></dt>
<dd><p>역 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">이터레이터</span></a> 를 돌려준다. <em>seq</em> 는 <a class="reference internal" href="../reference/datamodel.html#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> 메서드를 가졌거나 시퀀스 프로토콜(<a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 메서드와 <code class="docutils literal notranslate"><span class="pre">0</span></code> 에서 시작하는 정수 인자를 받는 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 메서드)을 지원하는 객체여야 한다.</p>
</dd></dl>

<dl class="function">
<dt id="round">
<code class="descname">round</code><span class="sig-paren">(</span><em>number</em><span class="optional">[</span>, <em>ndigits</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#round" title="永久链接至目标">¶</a></dt>
<dd><p><em>number</em> 를 소수점 다음에 <em>ndigits</em> 정밀도로 반올림한 값을 돌려준다. <em>ndigits</em> 가 생략되거나 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, 입력에 가장 가까운 정수를 돌려준다.</p>
<p><a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> 를 지원하는 내장형의 경우, 값은 10의 <em>-ndigits</em> 거듭제곱의 가장 가까운 배수로 반올림된다; 두 배수가 똑같이 가깝다면, 반올림은 짝수를 선택한다 (예를 들어, <code class="docutils literal notranslate"><span class="pre">round(0.5)</span></code> 와 <code class="docutils literal notranslate"><span class="pre">round(-0.5)</span></code> 는 모두 <code class="docutils literal notranslate"><span class="pre">0</span></code> 이고, <code class="docutils literal notranslate"><span class="pre">round(1.5)</span></code> 는 <code class="docutils literal notranslate"><span class="pre">2</span></code> 다). 모든 정숫값은 <em>ndigits</em> 에 유효하다 (양수, 0 또는 음수). 하나의 인자로 호출되면 반환 값은 정수이고, 그렇지 않으면 <em>number</em> 와 같은 형이다.</p>
<p>일반적인 파이썬 객체 <code class="docutils literal notranslate"><span class="pre">number</span></code> 의 경우, <code class="docutils literal notranslate"><span class="pre">round(number,</span> <span class="pre">ndigits)</span></code> 는 <code class="docutils literal notranslate"><span class="pre">number.__round__(ndigits)</span></code> 에 위임한다.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">float에 대한 <a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> 의 동작은 예상과 다를 수 있다: 예를 들어, <code class="docutils literal notranslate"><span class="pre">round(2.675,</span> <span class="pre">2)</span></code> 는 <code class="docutils literal notranslate"><span class="pre">2.68</span></code> 대신에 <code class="docutils literal notranslate"><span class="pre">2.67</span></code> 을 제공한다. 이것은 버그가 아니다: 대부분의 십진 소수가 float로 정확히 표현될 수 없다는 사실로부터 오는 결과다. 자세한 정보는 <a class="reference internal" href="../tutorial/floatingpoint.html#tut-fp-issues"><span class="std std-ref">부동 소수점 산술: 문제점 및 한계</span></a> 를 보기 바란다.</p>
</div>
</dd></dl>

<span class="target" id="func-set"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">set</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>새 <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 객체를 돌려준다. 선택적으로 <em>iterable</em> 에서 가져온 요소를 갖는다. <code class="docutils literal notranslate"><span class="pre">set</span></code> 은 내장 클래스다. 이 클래스에 대한 도큐멘테이션은 <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 및 <a class="reference internal" href="stdtypes.html#types-set"><span class="std std-ref">Set Types --- set, frozenset</span></a> 을 보기 바란다.</p>
<p>다른 컨테이너의 경우 내장 <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>, <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 및 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 클래스와 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 모듈을 참조하라.</p>
</dd></dl>

<dl class="function">
<dt id="setattr">
<code class="descname">setattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#setattr" title="永久链接至目标">¶</a></dt>
<dd><p>이것은 <a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> 과 한 쌍이다. 인자는 객체, 문자열 및 임의의 값이다. 문자열은 기존 어트리뷰트 또는 새 어트리뷰트의 이름을 지정할 수 있다. 이 함수는 객체가 허용하는 경우 값을 어트리뷰트에 대입한다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">setattr(x,</span> <span class="pre">'foobar',</span> <span class="pre">123)</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.foobar</span> <span class="pre">=</span> <span class="pre">123</span></code> 과 동등하다.</p>
</dd></dl>

<dl class="class">
<dt id="slice">
<em class="property">class </em><code class="descname">slice</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span><a class="headerlink" href="#slice" title="永久链接至目标">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">slice</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p id="index-9"><code class="docutils literal notranslate"><span class="pre">range(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></code> 에 의해 지정된 인덱스 세트를 나타내는 <a class="reference internal" href="../glossary.html#term-slice"><span class="xref std std-term">슬라이스</span></a> 객체를 돌려준다. <em>start</em> 및 <em>step</em> 인자의 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이다. 슬라이스 객체는 단지 인자 값 (또는 기본값)을 돌려주는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code> 및 <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code> 의 읽기 전용 데이터 어트리뷰트를 갖는다. 다른 명시적 기능은 없다; 그러나 Numerical Python과 다른 제삼자 확장이 사용한다. 슬라이스 객체는 확장 인덱싱 문법을 사용할 때도 만들어진다. 예를 들어: <code class="docutils literal notranslate"><span class="pre">a[start:stop:step]</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">a[start:stop,</span> <span class="pre">i]</span></code>. 이터레이터를 돌려주는 대안 버전은 <a class="reference internal" href="itertools.html#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.islice()</span></code></a> 를 보라.</p>
</dd></dl>

<dl class="function">
<dt id="sorted">
<code class="descname">sorted</code><span class="sig-paren">(</span><em>iterable</em>, <em>*</em>, <em>key=None</em>, <em>reverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sorted" title="永久链接至目标">¶</a></dt>
<dd><p><em>iterable</em> 의 항목들로 새 정렬된 리스트를 돌려준다.</p>
<p>키워드 인자로만 지정해야 하는 두 개의 선택적 인자가 있다.</p>
<p><em>key</em> 는 하나의 인자를 받는 함수를 지정하는데, 각 리스트 요소들로부터 비교 키를 추출하는 데 사용된다: <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">=</span> <span class="pre">str.lower</span></code>. 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이다 (요소를 직접 비교한다).</p>
<p><em>reverse</em> 는 논리값이다. <code class="docutils literal notranslate"><span class="pre">True</span></code> 로 설정되면, 각 비교가 뒤집힌 것처럼 리스트 요소들이 정렬된다.</p>
<p>예전 스타일의 <em>cmp</em> 함수를 <em>key</em> 함수로 변환하려면 <a class="reference internal" href="functools.html#functools.cmp_to_key" title="functools.cmp_to_key"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.cmp_to_key()</span></code></a> 를 사용한다.</p>
<p>내장 <a class="reference internal" href="#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> 함수는 안정적(stable)임이 보장된다. 정렬은 같다고 비교되는 요소의 상대적 순서를 변경하지 않으면 안정적이다 --- 이는 여러 번 정렬할 때 유용하다 (예를 들어, 부서별로 정렬한 후에 급여 등급별로 정렬하기).</p>
<p>정렬 예제와 간단한 정렬 자습서는 <a class="reference internal" href="../howto/sorting.html#sortinghowto"><span class="std std-ref">Sorting HOW TO</span></a> 를 참조하라.</p>
</dd></dl>

<dl class="function">
<dt id="staticmethod">
<code class="descclassname">&#64;</code><code class="descname">staticmethod</code><a class="headerlink" href="#staticmethod" title="永久链接至目标">¶</a></dt>
<dd><p>메서드를 정적 메서드로 변환한다.</p>
<p>정적 메서드는 묵시적인 첫 번째 인자를 받지 않는다. 정적 메서드를 선언하려면, 이 관용구를 사용한다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&#64;staticmethod</span></code> 형식은 함수 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">데코레이터</span></a> 다 -- 자세한 내용은 <a class="reference internal" href="../reference/compound_stmts.html#function"><span class="std std-ref">함수 정의</span></a> 의 함수 정의에 대한 설명을 보면 된다.</p>
<p>클래스 (<code class="docutils literal notranslate"><span class="pre">C.f()</span></code> 처럼) 또는 인스턴스 (<code class="docutils literal notranslate"><span class="pre">C().f()</span></code> 처럼)에 대해 호출할 수 있다. 인스턴스는 해당 클래스만 참조하고 무시한다.</p>
<p>파이썬의 정적 메서드는 자바 또는 C++ 에서 발견되는 정적 메서드와 비슷하다. 대체 클래스 생성자를 만드는 데 유용한 변형을 보려면 <a class="reference internal" href="#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> 도 참조하라.</p>
<p>Like all decorators, it is also possible to call <code class="docutils literal notranslate"><span class="pre">staticmethod</span></code> as
a regular function and do something with its result.  This is needed
in some cases where you need a reference to a function from a class
body and you want to avoid the automatic transformation to instance
method.  For these cases, use this idiom:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">builtin_open</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="nb">open</span><span class="p">)</span>
</pre></div>
</div>
<p>정적 메서드에 대한 더 자세한 정보는, <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">표준형 계층</span></a> 에 있는 표준 타입 계층에 대한 도큐멘테이션을 참조하라.</p>
</dd></dl>

<span class="target" id="func-str"><span id="index-10"></span></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=''</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=b''</em>, <em>encoding='utf-8'</em>, <em>errors='strict'</em><span class="sig-paren">)</span></dt>
<dd><p><em>object</em> 의 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 버전을 돌려준다. 자세한 내용은 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 을 참조하라.</p>
<p><code class="docutils literal notranslate"><span class="pre">str</span></code> 은 내장 문자열 <a class="reference internal" href="../glossary.html#term-class"><span class="xref std std-term">클래스</span></a> 다. 문자열에 대한 일반적인 정보는 <a class="reference internal" href="stdtypes.html#textseq"><span class="std std-ref">Text Sequence Type --- str</span></a> 를 참조하라.</p>
</dd></dl>

<dl class="function">
<dt id="sum">
<code class="descname">sum</code><span class="sig-paren">(</span><em>iterable</em><span class="optional">[</span>, <em>start</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#sum" title="永久链接至目标">¶</a></dt>
<dd><p><em>start</em> 및 <em>iterable</em> 의 항목들을 왼쪽에서 오른쪽으로 합하고 합계를 돌려준다. <em>start</em> 의 기본값은 <code class="docutils literal notranslate"><span class="pre">0</span></code> 이다. <em>iterable</em> 의 항목은 일반적으로 숫자며 시작 값은 문자열이 될 수 없다.</p>
<p>어떤 경우에는 <a class="reference internal" href="#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a> 에 대한 좋은 대안이 있다. 문자열의 시퀀스를 연결하는 가장 선호되고 빠른 방법은 <code class="docutils literal notranslate"><span class="pre">''.join(sequence)</span></code> 를 호출하는 것이다. 확장된 정밀도로 부동 소수점 값을 더하려면 <a class="reference internal" href="math.html#math.fsum" title="math.fsum"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.fsum()</span></code></a> 를 참조하라. 일련의 이터러블들을 연결하려면 <a class="reference internal" href="itertools.html#itertools.chain" title="itertools.chain"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.chain()</span></code></a> 를 고려해보라.</p>
</dd></dl>

<dl class="function">
<dt id="super">
<code class="descname">super</code><span class="sig-paren">(</span><span class="optional">[</span><em>type</em><span class="optional">[</span>, <em>object-or-type</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#super" title="永久链接至目标">¶</a></dt>
<dd><p>메서드 호출을 <em>type</em> 의 부모나 형제 클래스에 위임하는 프락시 객체를 돌려준다. 이는 클래스에서 재정의된 상속 된 메서드를 액세스할 때 유용하다. 검색 순서는 <em>type</em> 자체를 건너뛰는 것을 제외하면, <a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> 에 의해 사용된 순서와 같다.</p>
<p><em>type</em> 의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__</span> <span class="pre">mro__</span></code> 어트리뷰트는 메서드 결정 검색 순서를 나열하는데 <a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> 과 <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 에서 사용된다. 이 어트리뷰트는 동적이며 상속 계층 구조가 변경될 때마다 바뀔 수 있다.</p>
<p>두 번째 인자가 생략되면, 반환되는 슈퍼 객체는 연결되지 않았다(unbound). 두 번째 인자가 객체면, <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">type)</span></code> 는 참이어야 한다. 두 번째 인자가 형이면, <code class="docutils literal notranslate"><span class="pre">issubclass(type2,</span> <span class="pre">type)</span></code> 는 참이어야 한다 (이것은 클래스 메서드에 유용하다).</p>
<p><em>super</em> 에는 두 가지 일반적인 사용 사례가 있다. 단일 상속 클래스 계층 구조에서는, <em>super</em> 를 사용하여 명시적으로 이름을 지정하지 않고 부모 클래스를 참조할 수 있으므로, 코드를 더 유지 관리하기 쉽게 만들 수 있다. 이 사용은 다른 프로그래밍 언어에서 <em>super</em> 를 쓰는 것과 매우 유사하다.</p>
<p>두 번째 사용 사례는 동적 실행 환경에서 협력적 다중 상속을 지원하는 것이다. 이 사례는 파이썬에 고유하며 정적으로 컴파일되는 언어 또는 단일 상속만 지원하는 언어에서는 찾을 수 없다. 이것은 여러 베이스 클래스가 같은 메서드를 구현하는 &quot;다이아몬드 다이어그램&quot;을 구현할 수 있게 한다. 좋은 설계는 모든 경우에 이 메서드가 같은 호출 시그니처를 갖도록 하는 것이다 (호출 순서는 실행 시간에 결정되기 때문에, 그 순서가 클래스 계층 구조의 변경에 적응하기 때문에, 그리고 그 순서가 실행 시간 전에 미리 알려지지 않은 형제 클래스를 포함할 수 있으므로).</p>
<p>두 경우 모두, 일반적인 슈퍼 클래스 호출은 이런 식이다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>    <span class="c1"># This does the same thing as:</span>
                               <span class="c1"># super(C, self).method(arg)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 는 <code class="docutils literal notranslate"><span class="pre">super().__getitem__(name)</span></code> 과 같은 명시적인 점으로 구분된 어트리뷰트 조회를 위한 연결 절차의 일부로 구현됨에 주의해야 한다. 이것은 협력적인 다중 상속을 지원하는 예측 가능한 순서로 클래스를 검색하기 위해 자체 <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 메서드를 구현함으로써 그렇게 한다. 따라서, <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 는 <code class="docutils literal notranslate"><span class="pre">super()[name]</span></code> 과같이 문장이나 연산자를 사용하는 묵시적 조회에 대해서는 정의되지 않았다.</p>
<p>또한, 인자가 없는 형식을 제외하고는, <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 는 메서드 내부에서만 사용하도록 제한되지 않는다는 점에 유의해야 한다. 두 개의 인자 형식은 인자를 정확하게 지정하고 적절한 참조를 만든다. 인자가 없는 형식은 클래스 정의 내에서만 작동하는데, 컴파일러가 정의되고 있는 클래스를 올바르게 가져오고 일반 메서드에서 현재 인스턴스에 액세스하는 데 필요한 세부 정보를 채우기 때문이다.</p>
<p><a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 를 사용하여 협력적 클래스를 설계하는 방법에 대한 실용적인 제안은 <a class="reference external" href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/">super() 사용 안내</a> 를 보라.</p>
</dd></dl>

<span class="target" id="func-tuple"></span><dl class="function">
<dt>
<code class="descname">tuple</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>함수이기보다, <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 은 실제로 <a class="reference internal" href="stdtypes.html#typesseq-tuple"><span class="std std-ref">Tuples</span></a> 과 <a class="reference internal" href="stdtypes.html#typesseq"><span class="std std-ref">Sequence Types --- list, tuple, range</span></a> 에 문서화 된 것처럼 불변 시퀀스 형이다.</p>
</dd></dl>

<dl class="class">
<dt id="type">
<em class="property">class </em><code class="descname">type</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#type" title="永久链接至目标">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">type</code><span class="sig-paren">(</span><em>name</em>, <em>bases</em>, <em>dict</em><span class="sig-paren">)</span></dt>
<dd><p id="index-11">인자 하나의 경우, <em>object</em> 의 형을 돌려준다. 반환 값은 형 객체며 일반적으로 <a class="reference internal" href="stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">object.__class__</span></code></a> 가 돌려주는 것과 같은 객체다.</p>
<p>객체의 형을 검사하는 데는 <a class="reference internal" href="#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 내장 함수가 권장되는데, 서브 클래스를 고려하기 때문이다.</p>
<p>세 개의 인자를 주는 경우, 새 형 객체를 돌려준다. 이것은 본래 <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> 문의 동적인 형태다. <em>name</em> 문자열은 클래스 이름이고 <a class="reference internal" href="stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 어트리뷰트가 된다; <em>bases</em> 튜플은 베이스 클래스들을 항목화하고 <a class="reference internal" href="stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code></a> 어트리뷰트가 된다; <em>dict</em> 딕셔너리는 클래스 바디의 정의들이 들어있는 이름 공간이며 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 어트리뷰트가 되도록 표준 딕셔너리에 복사된다. 예를 들어, 다음 두 문장은 같은 <a class="reference internal" href="#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 객체를 만든다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p><a class="reference internal" href="stdtypes.html#bltin-type-objects"><span class="std std-ref">Type Objects</span></a> 를 참조하라.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.6 版更改: </span><code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> 를 재정의하지 않는 <a class="reference internal" href="#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 의 서브 클래스는 이제 객체의 형을 얻기 위해 하나의 인자 형식을 사용할 수 없다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="vars">
<code class="descname">vars</code><span class="sig-paren">(</span><span class="optional">[</span><em>object</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#vars" title="永久链接至目标">¶</a></dt>
<dd><p>모듈, 클래스, 인스턴스 또는 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 어트리뷰트가 있는 다른 객체의 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 어트리뷰트를 돌려준다.</p>
<p>모듈 및 인스턴스와 같은 객체는 업데이트 가능한 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 어트리뷰트를 갖는다; 그러나, 다른 객체는 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 어트리뷰트에 쓰기 제한을 가질 수 있다 (예를 들어, 클래스는 직접적인 딕셔너리 갱신을 방지하기 위해 <a class="reference internal" href="types.html#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.MappingProxyType</span></code></a> 를 사용한다).</p>
<p>인자가 없으면, <a class="reference internal" href="#vars" title="vars"><code class="xref py py-func docutils literal notranslate"><span class="pre">vars()</span></code></a> 는 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 처럼 동작한다. locals 딕셔너리에 대한 변경이 무시되기 때문에 locals 딕셔너리는 읽기에만 유용하다는 것에 주의해야 한다.</p>
</dd></dl>

<dl class="function">
<dt id="zip">
<code class="descname">zip</code><span class="sig-paren">(</span><em>*iterables</em><span class="sig-paren">)</span><a class="headerlink" href="#zip" title="永久链接至目标">¶</a></dt>
<dd><p>각 iterables 의 요소들을 모으는 이터레이터를 만든다.</p>
<p>튜플의 이터레이터를 돌려주는데, <em>i</em> 번째 튜플은 각 인자로 전달된 시퀀스나 이터러블의 <em>i</em> 번째 요소를 포함한다. 이터레이터는 가장 짧은 입력 이터러블이 모두 소모되면 멈춘다. 하나의 이터러블 인자를 사용하면, 1-튜플의 이터레이터를 돌려준다. 인자가 없으면, 빈 이터레이터를 돌려준다. 다음과 동등하다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="c1"># zip(&#39;ABCD&#39;, &#39;xy&#39;) --&gt; Ax By</span>
    <span class="n">sentinel</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
    <span class="n">iterators</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">iterators</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterators</span><span class="p">:</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">sentinel</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="ow">is</span> <span class="n">sentinel</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>iterables 를 왼쪽에서 오른쪽으로 값을 구하는 순서가 보장된다. 이것은 <code class="docutils literal notranslate"><span class="pre">zip(*[iter(s)]*n)</span></code> 을 사용하여 데이터 시리즈를 길이 n인 그룹으로 클러스터링하는 관용구를 가능하게 만든다. 이것은 <em>같은</em> 이터레이터를 <code class="docutils literal notranslate"><span class="pre">n</span></code> 번 반복해서, 각 출력 튜플이 이터레이터를 <code class="docutils literal notranslate"><span class="pre">n</span></code> 번 호출한 결과를 갖게 된다. 입력을 길이 n인 묶음으로 나누는 효과를 준다.</p>
<p><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 에 길이가 같지 않은 입력들을 제공하는 것은, 끝부분에서 매치되지 않고 남는 더 긴 이터러블들의 값들에 신경 쓰지 않는 경우로 제한해야 한다. 그 값들이 중요하다면, 대신 <a class="reference internal" href="itertools.html#itertools.zip_longest" title="itertools.zip_longest"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.zip_longest()</span></code></a> 를 사용한다.</p>
<p><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 을 <code class="docutils literal notranslate"><span class="pre">*</span></code> 연산자와 함께 쓰면 리스트를 unzip 할 수 있다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zipped</span><span class="p">)</span>
<span class="go">[(1, 4), (2, 5), (3, 6)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="__import__">
<code class="descname">__import__</code><span class="sig-paren">(</span><em>name</em>, <em>globals=None</em>, <em>locals=None</em>, <em>fromlist=()</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#__import__" title="永久链接至目标">¶</a></dt>
<dd><div class="admonition note" id="index-12">
<p class="first admonition-title">注解</p>
<p class="last">이것은 <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 과 달리 일상적인 파이썬 프로그래밍에서는 필요하지 않은 고급 함수다.</p>
</div>
<p>이 함수는 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문에 의해 호출된다. <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문의 의미를 변경하기 위해 대체할 수 있다 (<a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 모듈을 임포트하고 <code class="docutils literal notranslate"><span class="pre">builtins</span> <span class="pre">.__</span> <span class="pre">import__</span></code> 에 대입한다). 그러나 그렇게 하지 말 것을 <strong>강하게</strong> 권고하는데, 보통 같은 목적을 달성하는데 임포트 훅(<span class="target" id="index-21"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> 참조)을 사용하는 것이 더 간단하고 기본 임포트 구현이 사용될 것이라고 가정하는 코드들과 문제를 일으키지 않기 때문이다. <a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 의 직접 사용 역시 피하고 <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 을 사용할 것을 권한다.</p>
<p>함수는 모듈 <em>name</em> 을 임포트하는데, 잠재적으로 패키지 문맥에서 이름을 해석하는 방법을 결정하는데 주어진 <em>globals</em> 와 <em>locals</em> 를 사용한다. <em>fromlist</em> 는 <em>name</em> 에 의해 주어진 모듈로부터 임포트 되어야 하는 객체 또는 서브 모듈의 이름을 제공한다. 표준 구현은 <em>locals</em> 인자를 전혀 사용하지 않고, <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문의 패키지 문맥을 결정할 때만 <em>globals</em> 를 사용한다.</p>
<p><em>level</em> 은 절대 또는 상대 임포트를 사용할지를 지정한다. <code class="docutils literal notranslate"><span class="pre">0</span></code> (기본값)은 오직 절대 임포트를 수행한다는 것을 의미한다. 양수 값 <em>level</em> 은 <a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 를 호출하는 모듈 디렉터리에 상대적으로 검색할 상위 디렉터리들의 개수를 가리킨다 (자세한 내용은 <span class="target" id="index-22"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a> 참조).</p>
<p><em>name</em> 변수가 <code class="docutils literal notranslate"><span class="pre">package.module</span></code> 형식일 때, 일반적으로 <em>name</em> 에 의해 명명된 모듈이 <em>아니라</em>, 최상위 패키지(첫 번째 점까지의 이름)가 반환된다. 그러나 비어 있지 않은 <em>fromlist</em> 인자가 주어지면 <em>name</em> 에 의해 명명된 모듈이 반환된다.</p>
<p>예를 들어, 문장 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">spam</span></code> 은 다음 코드를 닮은 바이트 코드를 생성한다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">spam</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>문장 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">spam.ham</span></code> 은 이런 호출로 이어진다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">spam</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;spam.ham&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>여기에서 <a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 가 최상위 모듈을 돌려주는 것에 주목하라. 이것이 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문에 의해 이름에 연결되는 객체이기 때문이다.</p>
<p>반면에, 문장 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">spam.ham</span> <span class="pre">import</span> <span class="pre">eggs,</span> <span class="pre">sausage</span> <span class="pre">as</span> <span class="pre">saus</span></code> 는 라는 문장은 이런 결과를 준다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">_temp</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;spam.ham&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[</span><span class="s1">&#39;eggs&#39;</span><span class="p">,</span> <span class="s1">&#39;sausage&#39;</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">eggs</span> <span class="o">=</span> <span class="n">_temp</span><span class="o">.</span><span class="n">eggs</span>
<span class="n">saus</span> <span class="o">=</span> <span class="n">_temp</span><span class="o">.</span><span class="n">sausage</span>
</pre></div>
</div>
<p>여기서 <code class="docutils literal notranslate"><span class="pre">spam.ham</span></code> 모듈이 <a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 에서 반환된다. 이 객체로부터, 임포트할 이름들을 가져온 후 해당 이름들로 대입된다.</p>
<p>단순히 이름으로 모듈을 임포트 하기 원한다면 (잠재적으로 패키지 내에서), <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 을 사용한다.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>음수 <em>level</em> 은 더 지원되지 않는다 (기본값도 0으로 변경한다).</p>
</div>
</dd></dl>

<p class="rubric">각주</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>파서는 유닉스 스타일의 줄 종료 규칙만 받아들이는 것에 주의해야 한다. 파일에서 코드를 읽는 경우, 줄 넘김 변환 모드를 사용해서 윈도우나 맥 스타일 줄 넘김을 변환해야 한다.</td></tr>
</tbody>
</table>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>上一个主题</h4>
  <p class="topless"><a href="intro.html"
                        title="上一章">1. 소개</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="constants.html"
                        title="下一章">3. Built-in Constants</a></p>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/library/functions.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="constants.html" title="3. Built-in Constants"
             >下一页</a> |</li>
        <li class="right" >
          <a href="intro.html" title="1. 소개"
             >上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh</span>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">도큐멘테이션 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    파이썬 소프트웨어 재단은 비영리 법인입니다.
    <a href="https://www.python.org/psf/donations/">기부를 부탁합니다.</a>
    <br />
    4月 21, 2018 에 마지막으로 업데이트되었습니다.
    <a href="../bugs.html">버그를 찾았나요?</a>
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.7.2 를 사용해서 만들었습니다.
    </div>

  </body>
</html>