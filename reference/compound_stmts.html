
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>8. 복합문(Compound statements) &#8212; Python 3.6.5 文档</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.6.5 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="9. 최상위 요소들" href="toplevel_components.html" />
    <link rel="prev" title="7. 단순문(Simple statements)" href="simple_stmts.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.org/3/reference/compound_stmts.html" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="toplevel_components.html" title="9. 최상위 요소들"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. 단순문(Simple statements)"
             accesskey="P">上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh</span>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">도큐멘테이션 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 언어 레퍼런스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="compound-statements">
<span id="compound"></span><h1>8. 복합문(Compound statements)<a class="headerlink" href="#compound-statements" title="永久链接至标题">¶</a></h1>
<p id="index-0">복합문은 다른 문장들(의 그룹들)을 포함한다; 어떤 방법으로 그 다른 문장들의 실행에 영향을 주거나 제어한다. 간단하게 표현할 때, 전체 복합문을 한 줄로 쓸 수 있기는 하지만, 일반적으로 복합문은 여러 줄에 걸친다.</p>
<p><a class="reference internal" href="#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>, <a class="reference internal" href="#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a>, <a class="reference internal" href="#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 문장은 전통적인 제어 흐름 구조를 구현한다. 문장들의 그룹에 대해 <a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 는 예외 처리기나 정리(cleanup) 코드 또는 그 둘 모두를 지정하는 반면, <a class="reference internal" href="#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문은 코드 블록 주변으로 초기화와 파이널리제이션 코드를 실행할 수 있도록 한다. 함수와 클래스 정의 또한 문법적으로 복합문이다.</p>
<p id="index-1">복합문은 하나나 그 이상의 '절'로 구성된다. 절은 헤더와 '스위트(suite)'로 구성된다. 특정 복합문의 절 헤더들은 모두 같은 들여쓰기 수준을 갖는다. 각 절 헤더는 특별하게 식별되는 키워드로 시작하고 콜론으로 끝난다. 스위트는 절에 의해 제어되는 문장들의 그룹이다. 스위트는 헤더의 콜론 뒤에서 같은 줄에 세미콜론으로 분리된 하나나 그 이상의 단순문일 수 있다. 또는 그다음 줄에 들여쓰기 된 하나나 그 이상의 문장들일 수도 있다. 오직 후자의 형태만 중첩된 복합문을 포함할 수 있다; 다음과 같은 것은 올바르지 않은데, 대체로 뒤따르는 <a class="reference internal" href="#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> 절이 있다면 어떤 <a class="reference internal" href="#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 절에 속하는지 명확하지 않기 때문이다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">test1</span><span class="p">:</span> <span class="k">if</span> <span class="n">test2</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>또한, 이 문맥에서 세미콜론이 콜론보다 더 강하게 결합해서, 다음과 같은 예에서, <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 호출들은 모두 실행되거나 어느 하나도 실행되지 않는다는 것에 주의해야 한다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">);</span> <span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>요약하면:</p>
<pre>
<strong id="grammar-token-compound_stmt">compound_stmt</strong> ::=  <a class="reference internal" href="#grammar-token-if_stmt"><code class="xref docutils literal notranslate"><span class="pre">if_stmt</span></code></a>
                   | <a class="reference internal" href="#grammar-token-while_stmt"><code class="xref docutils literal notranslate"><span class="pre">while_stmt</span></code></a>
                   | <a class="reference internal" href="#grammar-token-for_stmt"><code class="xref docutils literal notranslate"><span class="pre">for_stmt</span></code></a>
                   | <a class="reference internal" href="#grammar-token-try_stmt"><code class="xref docutils literal notranslate"><span class="pre">try_stmt</span></code></a>
                   | <a class="reference internal" href="#grammar-token-with_stmt"><code class="xref docutils literal notranslate"><span class="pre">with_stmt</span></code></a>
                   | <a class="reference internal" href="#grammar-token-funcdef"><code class="xref docutils literal notranslate"><span class="pre">funcdef</span></code></a>
                   | <a class="reference internal" href="#grammar-token-classdef"><code class="xref docutils literal notranslate"><span class="pre">classdef</span></code></a>
                   | <a class="reference internal" href="#grammar-token-async_with_stmt"><code class="xref docutils literal notranslate"><span class="pre">async_with_stmt</span></code></a>
                   | <a class="reference internal" href="#grammar-token-async_for_stmt"><code class="xref docutils literal notranslate"><span class="pre">async_for_stmt</span></code></a>
                   | <a class="reference internal" href="#grammar-token-async_funcdef"><code class="xref docutils literal notranslate"><span class="pre">async_funcdef</span></code></a>
<strong id="grammar-token-suite">suite        </strong> ::=  <a class="reference internal" href="#grammar-token-stmt_list"><code class="xref docutils literal notranslate"><span class="pre">stmt_list</span></code></a> NEWLINE | NEWLINE INDENT <a class="reference internal" href="#grammar-token-statement"><code class="xref docutils literal notranslate"><span class="pre">statement</span></code></a>+ DEDENT
<strong id="grammar-token-statement">statement    </strong> ::=  <a class="reference internal" href="#grammar-token-stmt_list"><code class="xref docutils literal notranslate"><span class="pre">stmt_list</span></code></a> NEWLINE | <a class="reference internal" href="#grammar-token-compound_stmt"><code class="xref docutils literal notranslate"><span class="pre">compound_stmt</span></code></a>
<strong id="grammar-token-stmt_list">stmt_list    </strong> ::=  <a class="reference internal" href="simple_stmts.html#grammar-token-simple_stmt"><code class="xref docutils literal notranslate"><span class="pre">simple_stmt</span></code></a> (&quot;;&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-simple_stmt"><code class="xref docutils literal notranslate"><span class="pre">simple_stmt</span></code></a>)* [&quot;;&quot;]
</pre>
<p id="index-2">문장들이 항상 <code class="docutils literal notranslate"><span class="pre">NEWLINE</span></code> 으로 끝나고 <code class="docutils literal notranslate"><span class="pre">DEDENT</span></code> 가 그 뒤를 따를 수 있음에 주목해야 한다. 또한, 생략 가능한 연결 절들이 항상 문장을 시작시킬 수 없는 키워드로 시작하기 때문에, 모호함이 없다는 것도 주목하라 (파이썬에서는 중첩된 <a class="reference internal" href="#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 문이 들여쓰기 되는 것을 요구함으로써 '매달린(dangling) <a class="reference internal" href="#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a>' 문제를 해결한다).</p>
<p>명확함을 위해 다음에 오는 절들에서 나오는 문법 규칙들은 각 절을 별도의 줄에 놓도록 포매팅한다.</p>
<div class="section" id="the-if-statement">
<span id="else"></span><span id="elif"></span><span id="if"></span><h2>8.1. <a class="reference internal" href="#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 문<a class="headerlink" href="#the-if-statement" title="永久链接至标题">¶</a></h2>
<p id="index-3"><a class="reference internal" href="#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 문은 조건부 실행에 사용된다:</p>
<pre>
<strong id="grammar-token-if_stmt">if_stmt</strong> ::=  &quot;if&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
             ( &quot;elif&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a> )*
             [&quot;else&quot; &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>]
</pre>
<p>참이 되는 것을 발견할 때까지 표현식들의 값을 하나씩 차례대로 구해서 정확히 하나의 스위트를 선택한다 (참과 거짓의 정의는 <a class="reference internal" href="expressions.html#booleans"><span class="std std-ref">논리 연산(Boolean operations)</span></a> 섹션을 보라); 그런 다음 그 스위트를 실행한다 (그리고는 <a class="reference internal" href="#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 문의 다른 어떤 부분도 실행되거나 값이 구해지지 않는다). 모든 표현식들이 거짓이면 <a class="reference internal" href="#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> 절의 스위트가 (있다면) 실행된다.</p>
</div>
<div class="section" id="the-while-statement">
<span id="while"></span><h2>8.2. <a class="reference internal" href="#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> 문<a class="headerlink" href="#the-while-statement" title="永久链接至标题">¶</a></h2>
<p id="index-4"><a class="reference internal" href="#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> 문은 표현식이 참인 동안 실행을 반복하는 데 사용된다:</p>
<pre>
<strong id="grammar-token-while_stmt">while_stmt</strong> ::=  &quot;while&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
                [&quot;else&quot; &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>]
</pre>
<p>이것은 표현식을 반복적으로 검사하고, 참이면, 첫 번째 스위트를 실행한다; 표현식이 거짓이면 (처음부터 거짓일 수도 있다) <a class="reference internal" href="#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> 절의 스위트가 (있다면) 실행되고 루프를 종료한다.</p>
<p id="index-5">첫 번째 스위트에서 실행되는 <a class="reference internal" href="simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> 문은 <a class="reference internal" href="#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> 절을 실행하지 않고 루프를 종료한다. 첫 번째 스위트에서 실행되는 <a class="reference internal" href="simple_stmts.html#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> 문은 스위트의 나머지 부분을 건너뛰고 표현식의 검사로 돌아간다.</p>
</div>
<div class="section" id="the-for-statement">
<span id="for"></span><h2>8.3. <a class="reference internal" href="#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 문<a class="headerlink" href="#the-for-statement" title="永久链接至标题">¶</a></h2>
<p id="index-6"><a class="reference internal" href="#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 문은 (문자열, 튜플, 리스트 같은) 시퀀스 나 다른 이터러블 객체의 요소들을 이터레이트하는데 사용된다:</p>
<pre>
<strong id="grammar-token-for_stmt">for_stmt</strong> ::=  &quot;for&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-target_list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a> &quot;in&quot; <a class="reference internal" href="expressions.html#grammar-token-expression_list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
              [&quot;else&quot; &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>]
</pre>
<p>표현식 목록은 한 번만 값이 구해진다; 이터러블 객체가 나와야 한다. <code class="docutils literal notranslate"><span class="pre">expression_list</span></code> 의 결과로 이터레이터가 만들어진다. 그런 다음 이터레이터가 제공하는 항목마다, 이터레이터가 돌려주는 순서대로, 스위트가 한 번씩 실행된다. 순환마다 각 항목이 대입의 표준 규칙 (<a class="reference internal" href="simple_stmts.html#assignment"><span class="std std-ref">대입문</span></a> 을 보라) 으로 타깃 목록에 대입된 다음, 스위트가 실행된다. 항목들이 소진되었을 때 (이터레이터가 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 예외를 일으킬 때나 빈 시퀀스인 경우는 즉시 발생한다), the <a class="reference internal" href="#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> 절의 스위트가 (있다면) 실행되고 루프를 종료한다.</p>
<p id="index-7">첫 번째 스위트에서 실행되는 <a class="reference internal" href="simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> 문은 <a class="reference internal" href="#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> 절을 실행하지 않고 루프를 종료한다. 첫 번째 스위트에서 실행되는 <a class="reference internal" href="simple_stmts.html#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> 문은 스위트의 나머지 부분을 건너뛰고 다음 항목으로 넘어가거나, 다음 항목이 없으면 <a class="reference internal" href="#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> 절로 간다.</p>
<p>for-루프는 타깃 목록의 변수들에 대입한다. for-루프의 스위트에서 이루어진 것들도 포함해서, 그 변수에 앞서 대입된 값들을 모두 덮어쓴다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span>             <span class="c1"># this will not affect the for-loop</span>
                      <span class="c1"># because i will be overwritten with the next</span>
                      <span class="c1"># index in the range</span>
</pre></div>
</div>
<p id="index-8">타깃 목록의 이름들은 루프가 종료될 때 삭제되지 않지만, 시퀀스가 비어있다면, 루프에 의해 전혀 대입이 일어나지 않을 수도 있다. 힌트: 내장 함수 <a class="reference internal" href="../library/stdtypes.html#range" title="range"><code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code></a> 는 파스칼의 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">:=</span> <span class="pre">a</span> <span class="pre">to</span> <span class="pre">b</span> <span class="pre">do</span></code> 의 효과를 흉내 내는데 적합한 정수의 이터레이터를 돌려준다; 예를 들어, <code class="docutils literal notranslate"><span class="pre">list(range(3))</span></code> 는 리스트 <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2]</span></code> 를 돌려준다.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p id="index-9">시퀀스가 루프에 의해 수정될 때는 미묘한 점이 있다 (이것은 오직 가변 시퀀스에서만 일어난다, 즉 리스트). 다음에 어떤 항목이 사용될지를 추적하는 내부 카운터가 사용되고, 각 이터레이션마다 증가한다. 이 카운터가 시퀀스의 길이에 도달하면 루프가 종료된다. 이것은 만약 스위트가 시퀀스에서 현재 (또는 그 이전의) 항목을 삭제하면, 다음 항목을 건너뛰게 된다는 뜻이다 (다음 항목이 이미 다뤄진 현재 항목의 인덱스를 갖게 되기 때문이다). 마찬가지로, 스위트가 현재 항목 앞으로 시퀀스에 항목을 삽입하면, 현재 항목은 루프의 다음 순환에서 현재 항목이 한 번 더 다뤄지게 된다. 이것은 고약한 버그로 이어질 수 있는데, 전체 시퀀스의 슬라이스로 임시 사본을 만듦으로써 피할 수 있다, 예를 들어</p>
<div class="last highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">[:]:</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-try-statement">
<span id="finally"></span><span id="except"></span><span id="try"></span><h2>8.4. <a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 문<a class="headerlink" href="#the-try-statement" title="永久链接至标题">¶</a></h2>
<span class="target" id="index-10"></span><p id="index-11"><a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 문은 문장 그룹에 대한 예외 처리기나 정리(cleanup) 코드 또는 그 둘 모두를 지정하는 데 사용된다.</p>
<pre>
<strong id="grammar-token-try_stmt">try_stmt </strong> ::=  try1_stmt | try2_stmt
<strong id="grammar-token-try1_stmt">try1_stmt</strong> ::=  &quot;try&quot; &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
               (&quot;except&quot; [<a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> [&quot;as&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>]] &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>)+
               [&quot;else&quot; &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>]
               [&quot;finally&quot; &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>]
<strong id="grammar-token-try2_stmt">try2_stmt</strong> ::=  &quot;try&quot; &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
               &quot;finally&quot; &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
</pre>
<p><a class="reference internal" href="#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 절(들)은 하나나 그 이상의 예외 처리기를 지정한다. <a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 절에서 예외가 발생하지 않으면 아무런 예외 처리기도 실행되지 않는다. <a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 스위트에서 예외가 발생할 때, 예외 처리기 검색이 시작된다. 이 검색은 그 예외에 매치되는 것을 발견할 때까지 except 절을 차례대로 들여다본다. 표현식이 없는 except 절이 있다면 가장 마지막에 와야 한다; 모든 예외와 매치된다. 표현식이 있는 except 절의 경우, 표현식의 값을 구하고, 결과 객체가 예외와 &quot;호환&quot; 되면 그 절이 예외에 매치된다. 객체는 예외 객체의 클래스나 베이스 클래스일 때, 또는 예외와 호환되는 항목을 포함한 튜플일 때 예외와 호환된다.</p>
<p>except 절 중 어느 것도 예외와 매치되지 않으면, 예외 처리기 검색은 둘러싼 코드와 호출 스택에서 계속된다. <a class="footnote-reference" href="#id5" id="id1">[1]</a></p>
<p>만약 except 절의 헤더에 있는 표현식의 값을 구할 때 예외가 발생하면, 원래의 처리기 검색은 취소되고 둘러싼 코드와 호출 스택에서 새 예외에 대해 검사가 시작된다 (<a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 문 전체가 예외를 일으킨 것으로 취급된다).</p>
<p>매치되는 except 절이 발견되면, 예외는 그 except 절에 있는 <a class="reference internal" href="#as"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code></a> 키워드 (가 있다면) 뒤에 지정된 타깃에 대입되고, except 절의 스위트가 실행된다. 모든 except 절은 실행 가능한 블록을 가져야 한다. 블록의 끝에 도달하면, try 문 전체의 뒤에서 일반적인 실행이 계속된다. (이것은 같은 예외에 대해 두 개의 중첩된 처리기가 있고, 예외가 안쪽 처리기의 try 절에서 발생했다면, 바깥 처리기는 예외를 처리하지 않게 된다는 뜻이 된다.)</p>
<p>예외가 <code class="docutils literal notranslate"><span class="pre">as</span> <span class="pre">target</span></code> 을 사용해서 대입될 때, except 절 끝에서 삭제된다. 이것은 마치</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">except</span> <span class="n">E</span> <span class="k">as</span> <span class="n">N</span><span class="p">:</span>
    <span class="n">foo</span>
</pre></div>
</div>
<p>가 이렇게 변환되는 것 같다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">except</span> <span class="n">E</span> <span class="k">as</span> <span class="n">N</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">foo</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">N</span>
</pre></div>
</div>
<p>이것은 except 절 후에 참조하려면 예외를 다른 이름에 대입해야 한다는 뜻이다. 예외를 제거하는 이유는, 그것에 첨부된 트레이스백으로 인해, 스택 프레임과 참조 순환을 형성해서 다음 가비지 수거가 일어나기 전까지 그 프레임의 모든 지역 변수들을 잡아두기 때문이다.</p>
<p id="index-12">except 절의 스위트가 실행되기 전에, 예외의 상세 내용이 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 모듈에 저장되는데, <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 를 통해 액세스할 수 있다. <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 는 예외 클래스, 예외 인스턴스, 예외가 프로그램의 어디에서 발생했는지를 알려주는 트레이스백 객체 (<a class="reference internal" href="datamodel.html#types"><span class="std std-ref">표준형 계층</span></a> 를 보라) 로 이루어진 3-튜플을 돌려준다. <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 값들은 예외를 처리한 함수로부터 복귀할 때 이전 값으로 복구된다.</p>
<p id="index-13">생략 가능한 <a class="reference internal" href="#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> 절은 제어 흐름이 <a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 절의 끝으로 빠져나갈 때 실행된다. <a class="footnote-reference" href="#id6" id="id2">[2]</a> <a class="reference internal" href="#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> 절에서 발생하는 예외는 앞에 나오는 <a class="reference internal" href="#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 절에서 처리되지 않는다.</p>
<p id="index-14"><a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 가 있으면, '정리(cleanup)' 처리기를 지정한다. <a class="reference internal" href="#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 와 <a class="reference internal" href="#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> 절을 포함해서, 먼저 <a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 절이 실행된다. 이 절들의 어디에서건 예외가 일어나면, 예외는 임시 저장된다. <a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절이 실행된다. 만약 저장된 예외가 있으면, <a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절의 끝에서 다시 발생시킨다. <a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절이 다른 예외를 일으키면, 저장된 예외는 새 예외의 컨텍스트(context) 로 설정된다. <a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절이 <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 이나 <a class="reference internal" href="simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> 문을 실행하면, 저장된 예외는 버린다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
<span class="gp">... </span>    <span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">42</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">()</span>
<span class="go">42</span>
</pre></div>
</div>
<p><a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절을 실행하는 동안 예외 정보는 프로그램에 제공되지 않는다.</p>
<p id="index-15"><a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>...<a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 문의 <a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 스위트에서 <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>, <a class="reference internal" href="simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a>, <a class="reference internal" href="simple_stmts.html#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> 문이 실행될 때, <a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절도 '나가는 길에' 실행된다. <a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절에서는 <a class="reference internal" href="simple_stmts.html#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> 문을 사용할 수 없다. (그 이유는 현재 구현에 있는 문제 때문이다 --- 이 제약은 미래에 제거될 수 있다).</p>
<p>함수의 반환 값은 마지막에 실행된 <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 문으로 결정된다. <a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절이 항상 실행되기 때문에, <a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절에서 실행되는 <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 문이 항상 마지막에 실행되는 것이 된다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s1">&#39;try&#39;</span>
<span class="gp">... </span>    <span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s1">&#39;finally&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">()</span>
<span class="go">&#39;finally&#39;</span>
</pre></div>
</div>
<p>예외에 관한 추가의 정보는 <a class="reference internal" href="executionmodel.html#exceptions"><span class="std std-ref">예외</span></a> 섹션에서 찾을 수 있고, 예외를 일으키기 위해 <a class="reference internal" href="simple_stmts.html#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> 문을 사용하는 것에 관한 정보는 <a class="reference internal" href="simple_stmts.html#raise"><span class="std std-ref">raise 문</span></a> 섹션에서 찾을 수 있다.</p>
</div>
<div class="section" id="the-with-statement">
<span id="as"></span><span id="with"></span><h2>8.5. <a class="reference internal" href="#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문<a class="headerlink" href="#the-with-statement" title="永久链接至标题">¶</a></h2>
<p id="index-16"><a class="reference internal" href="#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문은 블록의 실행을 컨텍스트 매니저 (<a class="reference internal" href="datamodel.html#context-managers"><span class="std std-ref">with 문 컨텍스트 매니저</span></a> 섹션을 보라) 가 정의한 메서드들로 감싸는 데 사용된다. 이것은 흔한 <a class="reference internal" href="#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>...<a class="reference internal" href="#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a>...<a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 사용 패턴을 편리하게 재사용할 수 있도록 캡슐화할 수 있도록 한다.</p>
<pre>
<strong id="grammar-token-with_stmt">with_stmt</strong> ::=  &quot;with&quot; with_item (&quot;,&quot; with_item)* &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
<strong id="grammar-token-with_item">with_item</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> [&quot;as&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-target"><code class="xref docutils literal notranslate"><span class="pre">target</span></code></a>]
</pre>
<p>하나의 &quot;item&quot; 을 사용하는 <a class="reference internal" href="#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문의 실행은 다음과 같이 진행된다:</p>
<ol class="arabic">
<li><p class="first">컨텍스트 매니저를 얻기 위해 컨텍스트 표현식 (<a class="reference internal" href="#grammar-token-with_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">with_item</span></code></a> 에 주어진 expression) 의 값을 구한다.</p>
</li>
<li><p class="first">나중에 사용하기 위해 컨텍스트 매니저의 <a class="reference internal" href="datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 가 로드된다.</p>
</li>
<li><p class="first">컨텍스트 매니저의 <a class="reference internal" href="datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 메서드를 호출한다.</p>
</li>
<li><p class="first"><a class="reference internal" href="#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문에 타깃이 포함되었으면, 그것에 <a class="reference internal" href="datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 의 반환 값을 대입한다.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><a class="reference internal" href="#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문은 <a class="reference internal" href="datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 메서드가 에러 없이 돌아왔을 때, <a class="reference internal" href="datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 가 항상 호출됨을 보장한다. 그래서, 타깃에 대입하는 동안 에러가 발생하면, 스위트 안에서 에러가 발생한 것과 같이 취급된다. 아래의 6단계를 보라.</p>
</div>
</li>
<li><p class="first">스위트가 실행된다.</p>
</li>
<li><p class="first">컨텍스트 매니저의 <a class="reference internal" href="datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 메서드를 호출한다. 예외가 스위트를 종료되도록 만들었다면, 그것의 형, 값, 트레이스백이 <a class="reference internal" href="datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 의 인자로 전달된다. 그렇지 않으면 세 개의 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 이 인자로 공급된다.</p>
<p>스위트가 예외 때문에 종료되었고, <a class="reference internal" href="datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 메서드의 반환 값이 거짓이면, 그 예외를 다시 일으킨다. 반환 값이 참이면, 예외를 억누르고, <a class="reference internal" href="#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문 뒤에 오는 문장으로 실행을 계속한다.</p>
<p>스위트가 예외 이외의 이유로 종료되면, <a class="reference internal" href="datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 의 반환 값은 무시되고, 해당 종료의 종류에 맞는 위치에서 실행을 계속한다.</p>
</li>
</ol>
<p>하나 보다 많은 항목을 주면, 컨텍스트 매니저는 <a class="reference internal" href="#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문이 중첩된 것처럼 진행한다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">A</span><span class="p">()</span> <span class="k">as</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="p">()</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
    <span class="n">suite</span>
</pre></div>
</div>
<p>는 다음과 동등하다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">A</span><span class="p">()</span> <span class="k">as</span> <span class="n">a</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">B</span><span class="p">()</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
        <span class="n">suite</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.1 版更改: </span>다중 컨텍스트 표현식의 지원</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<dl class="last docutils">
<dt><span class="target" id="index-39"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a> - &quot;with&quot; 문</dt>
<dd>파이썬 <a class="reference internal" href="#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문의 규격, 배경, 예.</dd>
</dl>
</div>
</div>
<div class="section" id="function-definitions">
<span id="def"></span><span id="function"></span><span id="index-18"></span><h2>8.6. 함수 정의<a class="headerlink" href="#function-definitions" title="永久链接至标题">¶</a></h2>
<p id="index-19">함수 정의는 사용자 정의 함수 객체 (<a class="reference internal" href="datamodel.html#types"><span class="std std-ref">표준형 계층</span></a> 섹션을 보라) 를 정의한다:</p>
<pre>
<strong id="grammar-token-funcdef">funcdef                </strong> ::=  [<a class="reference internal" href="#grammar-token-decorators"><code class="xref docutils literal notranslate"><span class="pre">decorators</span></code></a>] &quot;def&quot; <a class="reference internal" href="#grammar-token-funcname"><code class="xref docutils literal notranslate"><span class="pre">funcname</span></code></a> &quot;(&quot; [<a class="reference internal" href="#grammar-token-parameter_list"><code class="xref docutils literal notranslate"><span class="pre">parameter_list</span></code></a>] &quot;)&quot; [&quot;-&gt;&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>] &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
<strong id="grammar-token-decorators">decorators             </strong> ::=  <a class="reference internal" href="#grammar-token-decorator"><code class="xref docutils literal notranslate"><span class="pre">decorator</span></code></a>+
<strong id="grammar-token-decorator">decorator              </strong> ::=  &quot;&#64;&quot; <a class="reference internal" href="#grammar-token-dotted_name"><code class="xref docutils literal notranslate"><span class="pre">dotted_name</span></code></a> [&quot;(&quot; [<a class="reference internal" href="expressions.html#grammar-token-argument_list"><code class="xref docutils literal notranslate"><span class="pre">argument_list</span></code></a> [&quot;,&quot;]] &quot;)&quot;] NEWLINE
<strong id="grammar-token-dotted_name">dotted_name            </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> (&quot;.&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>)*
<strong id="grammar-token-parameter_list">parameter_list         </strong> ::=  <a class="reference internal" href="#grammar-token-defparameter"><code class="xref docutils literal notranslate"><span class="pre">defparameter</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-defparameter"><code class="xref docutils literal notranslate"><span class="pre">defparameter</span></code></a>)* [&quot;,&quot; [<a class="reference internal" href="#grammar-token-parameter_list_starargs"><code class="xref docutils literal notranslate"><span class="pre">parameter_list_starargs</span></code></a>]]
                             | <a class="reference internal" href="#grammar-token-parameter_list_starargs"><code class="xref docutils literal notranslate"><span class="pre">parameter_list_starargs</span></code></a>
<strong id="grammar-token-parameter_list_starargs">parameter_list_starargs</strong> ::=  &quot;*&quot; [<a class="reference internal" href="#grammar-token-parameter"><code class="xref docutils literal notranslate"><span class="pre">parameter</span></code></a>] (&quot;,&quot; <a class="reference internal" href="#grammar-token-defparameter"><code class="xref docutils literal notranslate"><span class="pre">defparameter</span></code></a>)* [&quot;,&quot; [&quot;**&quot; <a class="reference internal" href="#grammar-token-parameter"><code class="xref docutils literal notranslate"><span class="pre">parameter</span></code></a> [&quot;,&quot;]]]
                             | &quot;**&quot; <a class="reference internal" href="#grammar-token-parameter"><code class="xref docutils literal notranslate"><span class="pre">parameter</span></code></a> [&quot;,&quot;]
<strong id="grammar-token-parameter">parameter              </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> [&quot;:&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
<strong id="grammar-token-defparameter">defparameter           </strong> ::=  <a class="reference internal" href="#grammar-token-parameter"><code class="xref docutils literal notranslate"><span class="pre">parameter</span></code></a> [&quot;=&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
<strong id="grammar-token-funcname">funcname               </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
</pre>
<p>함수 정의는 실행할 수 있는 문장이다. 실행하면 현재 지역 이름 공간의 함수 이름을 함수 객체 (함수의 실행 가능한 코드를 둘러싼 래퍼(wrapper)). 이 함수 객체는 현재의 이름 공간에 대한 참조를 포함하는데, 함수가 호출될 때 전역 이름 공간으로 사용된다.</p>
<p>함수 정의는 함수의 바디를 실행하지 않는다. 함수가 호출될 때 실행된다. <a class="footnote-reference" href="#id7" id="id3">[3]</a></p>
<p id="index-20">함수 정의는 하나나 그 이상의 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">데코레이터</span></a> 표현식으로 감싸질 수 있다. 데코레이터 표현식은 함수가 정의될 때, 함수 정의를 포함하는 스코프에서 값을 구한다. 그 결과는 콜러블이어야 하는데, 함수 객체만을 인자로 사용해서 호출된다. 반환 값이 함수 객체 대신 함수의 이름에 연결된다. 여러 개의 데코레이터는 중첩되는 방식으로 적용된다. 예를 들어, 다음과 같은 코드</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@f1</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
<span class="nd">@f2</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">():</span> <span class="k">pass</span>
</pre></div>
</div>
<p>는 대략 다음과 동등하다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">():</span> <span class="k">pass</span>
<span class="n">func</span> <span class="o">=</span> <span class="n">f1</span><span class="p">(</span><span class="n">arg</span><span class="p">)(</span><span class="n">f2</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>
</pre></div>
</div>
<p>원래의 함수가 임시로 이름 <code class="docutils literal notranslate"><span class="pre">func</span></code> 에 연결되지 않는다는 점만 다르다.</p>
<p id="index-21">하나나 그 이상의 <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">파라미터</span></a> 들이 <em>parameter</em> <code class="docutils literal notranslate"><span class="pre">=</span></code> <em>expression</em> 형태를 가질 때, 함수가 &quot;기본 파라미터값&quot;을 갖는다고 말한다. 기본값이 있는 파라미터의 경우, 호출할 때 대응하는 <a class="reference internal" href="../glossary.html#term-argument"><span class="xref std std-term">인자</span></a> 를 생략할 수 있고, 그럴 때 파라미터의 기본값이 적용된다. 만약 파라미터가 기본값을 가지면, &quot;<code class="docutils literal notranslate"><span class="pre">*</span></code>&quot; 까지 그 뒤를 따르는 모든 파라미터도 기본값을 가져야 한다 --- 이것은 문법 규칙에서 표현되지 않는 문법적 제약이다.</p>
<p><strong>함수 정의가 실행될 때, 기본 파라미터값은 왼쪽에서 오른쪽으로 값이 구해진다.</strong> 이것은 표현식이 함수가 정의될 때 한 번 값이 구해지고, 호출마다 같은 &quot;미리 계산된&quot; 값이 사용된다는 것을 뜻한다. 이것을 이해하는 것은 특히 기본값이 리스트나 딕셔너리와 같은 가변 객체일 때 중요하다: 만약 함수가 그 객체를 수정하면 (가령, 리스트에 항목을 추가한다), 그 결과 기본값이 수정된다. 이것은 일반적으로 의도하고 있는 것이 아니다. 이 문제를 회피하는 방법은 기본값으로 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 사용하고, 함수 바디에서 명시적으로 검사하는 것이다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">whats_on_the_telly</span><span class="p">(</span><span class="n">penguin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">penguin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">penguin</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">penguin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;property of the zoo&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">penguin</span>
</pre></div>
</div>
<p id="index-22">함수 호출의 의미는 섹션 <a class="reference internal" href="expressions.html#calls"><span class="std std-ref">호출</span></a> 에서 더 자세히 설명된다. 함수 호출은 항상 파라미터 목록에서 언급하는 모든 파라미터에 값을 대입하는데, 위치 인자들에서 올 수도, 키워드 인자들에서 올 수도, 기본값에서 올 수도 있다. &quot;<code class="docutils literal notranslate"><span class="pre">*identifier</span></code>&quot; 형태가 존재하면, 남는 위치 파라미터들을 받는 튜플로 초기화된다. 기본값은 빈 튜플이다. &quot;<code class="docutils literal notranslate"><span class="pre">**identifier</span></code>&quot; 형태가 존재하면, 남는 키워드 인자들을 받는 순서 있는 매핑으로 초기화된다. 기본값은 빈 매핑이다. &quot;<code class="docutils literal notranslate"><span class="pre">*</span></code>&quot; 나 &quot;<code class="docutils literal notranslate"><span class="pre">*identifier</span></code>&quot; 뒤에 오는 파라미터들은 키워드 전용 파라미터들이고, 키워드 인자로만 전달될 수 있다.</p>
<p id="index-23">파라미터들은 파라미터 이름 뒤에 오는 &quot;<code class="docutils literal notranslate"><span class="pre">:</span> <span class="pre">expression</span></code>&quot; 형태의 어노테이션을 가질 수 있다. 모든 파라미터는 어노테이션을 가질 수 있는데, <code class="docutils literal notranslate"><span class="pre">*identifier</span></code> 나 <code class="docutils literal notranslate"><span class="pre">**identifier</span></code> 형태조차 그렇다. 함수는 파라미터 목록 뒤에 오는 &quot;<code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">expression</span></code>&quot; 형태의 반환(&quot;return&quot;) 어노테이션을 가질 수 있다. 이 어노테이션들은 올바른 파이썬 표현식이면 어떤 것이건 될 수 있고, 함수 정의가 실행될 때 값이 구해진다. 어노테이션은 소스 코드에 등장하는 것과 다른 순서로 값이 구해질 수 있다. 어노테이션의 존재는 함수의 의미를 바꾸지 않는다. 어노테이션 값들은 함수 객체의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> 어트리뷰트에서 파라미터의 이름을 키로 하는 딕셔너리의 값으로 제공된다.</p>
<p id="index-24">표현식에서 즉시 사용하기 위해, 이름 없는 함수(이름에 연결되지 않은 함수)를 만드는 것도 가능하다. 이것은 람다 표현식을 사용하는데, <a class="reference internal" href="expressions.html#lambda"><span class="std std-ref">람다(Lambdas)</span></a> 섹션에서 설명한다. 람다 표현식은 단순화된 함수 정의를 위한 줄임 표현에 지나지 않는다는 것에 주의하라; &quot;<a class="reference internal" href="#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a>&quot; 문장에서 정의된 함수는 람다 표현식으로 정의된 함수처럼 전달되거나 다른 이름에 대입될 수 있다. 여러 개의 문장을 실행하는 것과 어노테이션을 허락하기 때문에, &quot;<a class="reference internal" href="#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a>&quot; 형태가 사실 더 강력하다.</p>
<p><strong>프로그래머 유의 사항:</strong> 함수는 퍼스트 클래스(first-class) 객체다. 함수 정의 안에서 실행되는 &quot;<code class="docutils literal notranslate"><span class="pre">def</span></code>&quot; 문은 돌려주거나 전달할 수 있는 지역 함수를 정의한다. 중첩된 함수에서 사용되는 자유 변수들은 그 def 를 포함하는 함수의 지역 변수들을 액세스할 수 있다. 더 자세한 내용은 <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">이름과 연결(binding)</span></a> 섹션을 보라.</p>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<dl class="last docutils">
<dt><span class="target" id="index-40"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3107"><strong>PEP 3107</strong></a> - 함수 어노테이션</dt>
<dd>함수 어노테이션의 최초 규격.</dd>
</dl>
</div>
</div>
<div class="section" id="class-definitions">
<span id="class"></span><h2>8.7. 클래스 정의<a class="headerlink" href="#class-definitions" title="永久链接至标题">¶</a></h2>
<p id="index-26">클래스 정의는 클래스 객체(<a class="reference internal" href="datamodel.html#types"><span class="std std-ref">표준형 계층</span></a> 섹션을 보라)를 정의한다:</p>
<pre>
<strong id="grammar-token-classdef">classdef   </strong> ::=  [<a class="reference internal" href="#grammar-token-decorators"><code class="xref docutils literal notranslate"><span class="pre">decorators</span></code></a>] &quot;class&quot; <a class="reference internal" href="#grammar-token-classname"><code class="xref docutils literal notranslate"><span class="pre">classname</span></code></a> [<a class="reference internal" href="#grammar-token-inheritance"><code class="xref docutils literal notranslate"><span class="pre">inheritance</span></code></a>] &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
<strong id="grammar-token-inheritance">inheritance</strong> ::=  &quot;(&quot; [<a class="reference internal" href="expressions.html#grammar-token-argument_list"><code class="xref docutils literal notranslate"><span class="pre">argument_list</span></code></a>] &quot;)&quot;
<strong id="grammar-token-classname">classname  </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
</pre>
<p>클래스 정의는 실행 가능한 문장이다. 계승(inheritance) 목록은 보통 베이스 클래스들의 목록을 제공하는데 (더 고급 사용에 대해서는 <a class="reference internal" href="datamodel.html#metaclasses"><span class="std std-ref">메타 클래스</span></a> 를 보라), 목록의 각 항목은 값을 구할 때 서브클래싱을 허락하는 클래스 객체가 되어야 한다. 계승 목록이 없는 클래스는, 기본적으로, 베이스 클래스 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 를 계승한다; 그래서</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>는 다음과 동등하다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>클래스의 스위트는 새로 만들어진 지역 이름 공간과 원래의 전역 이름 공간을 사용하는 새 실행 프레임 (<a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">이름과 연결(binding)</span></a> 을 보라)에서 실행된다. (보통, 스위트는 대부분 함수 정의들을 포함한다.) 클래스의 스위트가 실행을 마치면, 실행 프레임은 파기하지만, 그것의 지역 이름 공간은 보존한다. <a class="footnote-reference" href="#id8" id="id4">[4]</a> 그런 다음, 계승 목록을 베이스 클래스들로, 보존된 지역 이름 공간을 어트리뷰트 딕셔너리로 사용해서 새 클래스 객체를 만든다. 클래스의 이름은 원래의 지역 이름 공간에서 이 클래스 객체와 연결된다.</p>
<p>클래스 바디에서 어트리뷰트가 정의되는 순서는, 새 클래스의 <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> 에 보존된다. 이것은 클래스가 만들어진 직후에, 정의 문법을 사용해서 정의되는 클래스들에서만 신뢰할 수 있다는 것에 주의해야 한다.</p>
<p>클래스 생성은 <a class="reference internal" href="datamodel.html#metaclasses"><span class="std std-ref">메타 클래스</span></a> 를 사용해서 심하게 커스터마이즈할 수 있다.</p>
<p>클래스 역시 함수를 데코레이팅할 때처럼 테코레이트할 수 있다,</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@f1</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
<span class="nd">@f2</span>
<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span> <span class="k">pass</span>
</pre></div>
</div>
<p>는 대략 다음과 동등하다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span> <span class="k">pass</span>
<span class="n">Foo</span> <span class="o">=</span> <span class="n">f1</span><span class="p">(</span><span class="n">arg</span><span class="p">)(</span><span class="n">f2</span><span class="p">(</span><span class="n">Foo</span><span class="p">))</span>
</pre></div>
</div>
<p>데코레이터 표현식의 값을 구하는 규칙은 함수 데코레이터와 같다. 그런 다음 그 결과가 클래스 이름에 연결된다.</p>
<p><strong>프로그래머 유의 사항:</strong> 클래스 정의에서 정의되는 변수들은 클래스 어트리뷰트다; 이것들은 인스턴스 간에 공유된다. 인스턴스 어트리뷰트는 메서드에서 <code class="docutils literal notranslate"><span class="pre">self.name</span> <span class="pre">=</span> <span class="pre">value</span></code> 로 설정될 수 있다. 클래스와 인스턴스 어트리뷰트 모두 &quot;<code class="docutils literal notranslate"><span class="pre">self.name</span></code>&quot; 표기법으로 액세스할 수 있고, 이런 식으로 액세스할 때 인스턴스 어트리뷰트는 같은 이름의 클래스 어트리뷰트를 가린다. 클래스 어트리뷰트는 인스턴스 어트리뷰트의 기본값으로 사용될 수 있지만, 가변 값을 사용하는 것은 예상하지 않은 결과를 줄 수 있다. <a class="reference internal" href="datamodel.html#descriptors"><span class="std std-ref">디스크립터</span></a> 를 다른 구현 상세를 갖는 인스턴스 변수를 만드는데 사용할 수 있다.</p>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<p class="last"><span class="target" id="index-41"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3115"><strong>PEP 3115</strong></a> - 파이썬 3의 메타 클래스 <span class="target" id="index-42"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3129"><strong>PEP 3129</strong></a> - 클래스 데코레이터</p>
</div>
</div>
<div class="section" id="coroutines">
<h2>8.8. 코루틴<a class="headerlink" href="#coroutines" title="永久链接至标题">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">3.5 新版功能.</span></p>
</div>
<div class="section" id="coroutine-function-definition">
<span id="async-def"></span><span id="index-29"></span><h3>8.8.1. 코루틴 함수 정의<a class="headerlink" href="#coroutine-function-definition" title="永久链接至标题">¶</a></h3>
<pre>
<strong id="grammar-token-async_funcdef">async_funcdef</strong> ::=  [<a class="reference internal" href="#grammar-token-decorators"><code class="xref docutils literal notranslate"><span class="pre">decorators</span></code></a>] &quot;async&quot; &quot;def&quot; <a class="reference internal" href="#grammar-token-funcname"><code class="xref docutils literal notranslate"><span class="pre">funcname</span></code></a> &quot;(&quot; [<a class="reference internal" href="#grammar-token-parameter_list"><code class="xref docutils literal notranslate"><span class="pre">parameter_list</span></code></a>] &quot;)&quot; [&quot;-&gt;&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>] &quot;:&quot; <a class="reference internal" href="#grammar-token-suite"><code class="xref docutils literal notranslate"><span class="pre">suite</span></code></a>
</pre>
<p id="index-30">파이썬 코루틴의 실행은 여러 지점에서 일시 중지되거나 재개될 수 있다 (<a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">코루틴</span></a> 을 보라.). 코루틴의 바디에서, <code class="docutils literal notranslate"><span class="pre">await</span></code> 와 <code class="docutils literal notranslate"><span class="pre">async</span></code> 식별자는 예약 키워드가 된다; 어웨이트(<a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>) 표현식, <a class="reference internal" href="#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>, <a class="reference internal" href="#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 는 코루틴 바디에서만 사용할 수 있다.</p>
<p><code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> 문법으로 정의된 함수는 항상 코루틴 함수인데, <code class="docutils literal notranslate"><span class="pre">await</span></code> 나 <code class="docutils literal notranslate"><span class="pre">async</span></code> 키워드를 포함하지 않는 경우도 그렇다.</p>
<p><code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> 코루틴에서 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 표현식을 사용하는 것은 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 다.</p>
<p>코루틴 함수의 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">param1</span><span class="p">,</span> <span class="n">param2</span><span class="p">):</span>
    <span class="n">do_stuff</span><span class="p">()</span>
    <span class="k">await</span> <span class="n">some_coroutine</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="the-async-for-statement">
<span id="async-for"></span><span id="index-31"></span><h3>8.8.2. <a class="reference internal" href="#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 문<a class="headerlink" href="#the-async-for-statement" title="永久链接至标题">¶</a></h3>
<pre>
<strong id="grammar-token-async_for_stmt">async_for_stmt</strong> ::=  &quot;async&quot; <a class="reference internal" href="#grammar-token-for_stmt"><code class="xref docutils literal notranslate"><span class="pre">for_stmt</span></code></a>
</pre>
<p><a class="reference internal" href="../glossary.html#term-asynchronous-iterable"><span class="xref std std-term">비동기 이터러블</span></a> 은 <em>iter</em> 구현에서 비동기 코드를 호출할 수 있고, <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">비동기 이터레이터</span></a> 는 <em>next</em> 메서드에서 비동기 코드를 호출할 수 있다.</p>
<p><code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 문은 비동기 이터레이터에 대한 편리한 이터레이션을 허락한다.</p>
<p>다음과 같은 코드는:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">for</span> <span class="n">TARGET</span> <span class="ow">in</span> <span class="n">ITER</span><span class="p">:</span>
    <span class="n">BLOCK</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">BLOCK2</span>
</pre></div>
</div>
<p>의미상으로 다음과 동등하다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">iter</span> <span class="o">=</span> <span class="p">(</span><span class="n">ITER</span><span class="p">)</span>
<span class="nb">iter</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span><span class="o">.</span><span class="fm">__aiter__</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span>
<span class="n">running</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">while</span> <span class="n">running</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">TARGET</span> <span class="o">=</span> <span class="k">await</span> <span class="nb">type</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span><span class="o">.</span><span class="fm">__anext__</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">StopAsyncIteration</span><span class="p">:</span>
        <span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">BLOCK</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">BLOCK2</span>
</pre></div>
</div>
<p>더 자세한 내용은 <a class="reference internal" href="datamodel.html#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> 를 <a class="reference internal" href="datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> 보면 된다.</p>
<p><a class="reference internal" href="#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 함수 밖에서 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 문을 사용하는 것은 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 다.</p>
</div>
<div class="section" id="the-async-with-statement">
<span id="async-with"></span><span id="index-32"></span><h3>8.8.3. <a class="reference internal" href="#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 문<a class="headerlink" href="#the-async-with-statement" title="永久链接至标题">¶</a></h3>
<pre>
<strong id="grammar-token-async_with_stmt">async_with_stmt</strong> ::=  &quot;async&quot; <a class="reference internal" href="#grammar-token-with_stmt"><code class="xref docutils literal notranslate"><span class="pre">with_stmt</span></code></a>
</pre>
<p><a class="reference internal" href="../glossary.html#term-asynchronous-context-manager"><span class="xref std std-term">비동기 컨텍스트 매니저</span></a> 는 <em>enter</em> 와 <em>exit</em> 메서드에서 실행을 일시 중지할 수 있는 <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">컨텍스트 매니저</span></a> 다.</p>
<p>다음과 같은 코드는:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">with</span> <span class="n">EXPR</span> <span class="k">as</span> <span class="n">VAR</span><span class="p">:</span>
    <span class="n">BLOCK</span>
</pre></div>
</div>
<p>의미상으로 다음과 동등하다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">mgr</span> <span class="o">=</span> <span class="p">(</span><span class="n">EXPR</span><span class="p">)</span>
<span class="n">aexit</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span><span class="o">.</span><span class="fm">__aexit__</span>
<span class="n">aenter</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span><span class="o">.</span><span class="fm">__aenter__</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span>

<span class="n">VAR</span> <span class="o">=</span> <span class="k">await</span> <span class="n">aenter</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">BLOCK</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="k">await</span> <span class="n">aexit</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="o">*</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()):</span>
        <span class="k">raise</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">await</span> <span class="n">aexit</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>더 자세한 내용은 <a class="reference internal" href="datamodel.html#object.__aenter__" title="object.__aenter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aenter__()</span></code></a> 와 <a class="reference internal" href="datamodel.html#object.__aexit__" title="object.__aexit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code></a> 를 보면 된다.</p>
<p><a class="reference internal" href="#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 함수 밖에서 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 문을 사용하는 것은 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 다.</p>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<p class="last"><span class="target" id="index-43"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> - async 와 await 문법을 사용하는 코루틴</p>
</div>
<p class="rubric">각주</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>다른 예외를 일으키는 <a class="reference internal" href="#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절이 있지 않은 한 예외는 호출 스택으로 퍼진다. 그 새 예외는 예전의 것을 잃어버리게 만든다.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>현재, 예외나, <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>, <a class="reference internal" href="simple_stmts.html#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a>, <a class="reference internal" href="simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> 문의 실행을 제외하고는 &quot;제어 흐름이 try 절의 끝으로 빠져나간다&quot;.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>함수 바디의 첫 번째 문장으로 등장하는 문자열 리터럴은 함수의 <code class="docutils literal notranslate"><span class="pre">__doc__</span></code> 어트리뷰트로 변환되어 함수의 <a class="reference internal" href="../glossary.html#term-docstring"><span class="xref std std-term">독스트링</span></a> 이 된다.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>클래스 바디의 첫 번째 문장으로 등장하는 문자열 리터럴은 그 이름 공간의 <code class="docutils literal notranslate"><span class="pre">__doc__</span></code> 항목으로 변환되어 클래스의 <a class="reference internal" href="../glossary.html#term-docstring"><span class="xref std std-term">독스트링</span></a> 이 된다.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">8. 복합문(Compound statements)</a><ul>
<li><a class="reference internal" href="#the-if-statement">8.1. <code class="docutils literal notranslate"><span class="pre">if</span></code> 문</a></li>
<li><a class="reference internal" href="#the-while-statement">8.2. <code class="docutils literal notranslate"><span class="pre">while</span></code> 문</a></li>
<li><a class="reference internal" href="#the-for-statement">8.3. <code class="docutils literal notranslate"><span class="pre">for</span></code> 문</a></li>
<li><a class="reference internal" href="#the-try-statement">8.4. <code class="docutils literal notranslate"><span class="pre">try</span></code> 문</a></li>
<li><a class="reference internal" href="#the-with-statement">8.5. <code class="docutils literal notranslate"><span class="pre">with</span></code> 문</a></li>
<li><a class="reference internal" href="#function-definitions">8.6. 함수 정의</a></li>
<li><a class="reference internal" href="#class-definitions">8.7. 클래스 정의</a></li>
<li><a class="reference internal" href="#coroutines">8.8. 코루틴</a><ul>
<li><a class="reference internal" href="#coroutine-function-definition">8.8.1. 코루틴 함수 정의</a></li>
<li><a class="reference internal" href="#the-async-for-statement">8.8.2. <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 문</a></li>
<li><a class="reference internal" href="#the-async-with-statement">8.8.3. <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 문</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="simple_stmts.html"
                        title="上一章">7. 단순문(Simple statements)</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="toplevel_components.html"
                        title="下一章">9. 최상위 요소들</a></p>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/reference/compound_stmts.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="toplevel_components.html" title="9. 최상위 요소들"
             >下一页</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. 단순문(Simple statements)"
             >上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh</span>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">도큐멘테이션 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 언어 레퍼런스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    파이썬 소프트웨어 재단은 비영리 법인입니다.
    <a href="https://www.python.org/psf/donations/">기부를 부탁합니다.</a>
    <br />
    4月 21, 2018 에 마지막으로 업데이트되었습니다.
    <a href="../bugs.html">버그를 찾았나요?</a>
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.7.2 를 사용해서 만들었습니다.
    </div>

  </body>
</html>