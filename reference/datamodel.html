
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>3. 데이터 모델 &#8212; Python 3.6.5 文档</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.6.5 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="4. 실행 모델" href="executionmodel.html" />
    <link rel="prev" title="2. 구문 분석" href="lexical_analysis.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.org/3/reference/datamodel.html" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 실행 모델"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. 구문 분석"
             accesskey="P">上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh</span>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">도큐멘테이션 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 언어 레퍼런스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="data-model">
<span id="datamodel"></span><h1>3. 데이터 모델<a class="headerlink" href="#data-model" title="永久链接至标题">¶</a></h1>
<div class="section" id="objects-values-and-types">
<span id="objects"></span><h2>3.1. 객체, 값, 형<a class="headerlink" href="#objects-values-and-types" title="永久链接至标题">¶</a></h2>
<p id="index-0">객체(<em class="dfn">Objects</em>)는 파이썬이 데이터(data)를 추상화한 것(abstraction)이다. 파이썬 프로그램의 모든 데이터는 객체나 객체 간의 관계로 표현된다. (폰 노이만(Von Neumann)의 &quot;프로그램 내장식 컴퓨터(stored program computer)&quot; 모델을 따르고, 또 그 관점에서 코드 역시 객체로 표현된다.)</p>
<span class="target" id="index-1"></span><p>모든 객체는 아이덴티티(identity), 형(type), 값(value)을 갖는다. 객체의 <em>아이덴티티</em> 는 한 번 만들어진 후에는 변경되지 않는다. 메모리상에서의 객체의 주소로 생각해도 좋다. '<a class="reference internal" href="expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a>' 연산자는 두 객체의 아이덴티티를 비교한다; <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> 함수는 아이덴티티를 정수로 표현한 값을 돌려준다.</p>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> CPython 의 경우, <code class="docutils literal notranslate"><span class="pre">id(x)</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span></code> 가 저장된 메모리의 주소다.</p>
</div>
<p>객체의 형은 객체가 지원하는 연산들을 정의하고 (예를 들어, &quot;길이를 갖고 있나?&quot;) 그 형의 객체들이 가질 수 있는 가능한 값들을 정의한다. <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 함수는 객체의 형(이것 역시 객체다)을 돌려준다. 아이덴티티와 마찬가지로, 객체의 형(<em class="dfn">type</em>) 역시 변경되지 않는다. <a class="footnote-reference" href="#id8" id="id1">[1]</a></p>
<p>어떤 객체들의 <em>값</em> 은 변경할 수 있다. 값을 변경할 수 있는 객체들을 <em>가변(mutable)</em> 이라고 한다. 일단 만들어진 후에 값을 변경할 수 없는 객체들을 <em>불변(immutable)</em> 이라고 한다. (가변 객체에 대한 참조를 저장하고 있는 불변 컨테이너의 값은 가변 객체의 값이 변할 때 변경된다고 볼 수도 있다; 하지만 저장하고 있는 객체들의 집합이 바뀔 수 없으므로 컨테이너는 여전히 불변이라고 여겨진다. 따라서 불변성은 엄밀하게는 변경 불가능한 값을 갖는 것과는 다르다. 좀 더 미묘하다.) 객체의 가변성(mutability)은 그것의 형에 의해 결정된다; 예를 들어 숫자, 문자열, 튜플(tuple)은 불변이지만, 딕셔너리(dictionary) 와 리스트(list)는 가변이다.</p>
<p id="index-2">객체는 결코 명시적으로 파괴되지 않는다; 더 참조되지 않을 때(unreachable) 가비지 수거(garbage collect)된다. 구현이 가비지 수거를 지연시키거나 아예 생략하는 것이 허락된다 --- 아직 참조되는 객체들을 수거하지 않는 이상 가비지 수거가 어떤 식으로 구현되는지는 구현의 품질 문제다.</p>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> CPython 은 현재 참조 횟수 계산(reference-counting) 방식을 사용하는데, (선택 사항으로) 순환적으로 연결된 가비지의 지연된 감지가 추가된다. 이 방법으로 대부분 객체를 참조가 제거되자마자 수거할 수 있다. 하지만 순환 참조가 있는 가비지들을 수거한다는 보장은 없다. 순환적 가비지 수거의 제어에 관한 정보는 <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> 모듈 문서를 참조하면 된다. 다른 구현들은 다른 식으로 동작하고, CPython 도 변경될 수 있다. 참조가 제거될 때 즉각적으로 파이널리제이션(finalization)되는 것에 의존하지 말아야 한다 (그래서 항상 파일을 명시적으로 닫아주어야 한다).</p>
</div>
<p>구현이 제공하는 추적이나 디버깅 장치의 사용은 그렇지 않으면 수거될 수 있는 객체들을 살아있도록 만들 수 있음에 주의해야 한다. 또한 '<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>...<a class="reference internal" href="compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a>' 문으로 예외를 잡는 것도 객체를 살아있게 만들 수 있다.</p>
<p>어떤 객체들은 열린 파일이나 창 같은 &quot;외부(external)&quot; 자원들에 대한 참조를 포함한다. 이 자원들은 객체가 가비지 수거될 때 반납된다고 이해되지만, 가비지 수거는 보장되는 것이 아니므로, 그런 객체들은 외부자원을 반납하는 명시적인 방법 또한 제공한다. 보통 <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> 메서드다. 프로그램을 작성할 때는 그러한 객체들을 항상 명시적으로 닫아야(close) 한다. '<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>...<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a>' 문과 '<a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 문은 이렇게 하는 편리한 방법을 제공한다.</p>
<p id="index-3">어떤 객체들은 다른 객체에 대한 참조를 포함하고 있다. 이런 것들을 <em>컨테이너(container)</em> 라고 부른다. 튜플, 리스트, 딕셔너리등이 컨테이너의 예다. 이 참조들은 컨테이너의 값의 일부다. 대부분은, 우리가 컨테이너의 값을 논할 때는, 들어있는 객체들의 아이덴티티 보다는 값을 따진다. 하지만, 컨테이너의 가변성에 대해 논할 때는 직접 가진 객체들의 아이덴티티만을 따진다. 그래서, (튜플 같은) 불변 컨테이너가 가변 객체로의 참조를 하고 있다면, 그 가변 객체가 변경되면 컨테이너의 값도 변경된다.</p>
<p>형은 거의 모든 측면에서 객체가 동작하는 방법에 영향을 준다. 객체의 아이엔티디가 갖는 중요성조차도 어떤 면에서는 영향을 받는다: 불변형의 경우, 새 값을 만드는 연산은 실제로는 이미 존재하는 객체 중에서 같은 형과 값을 갖는 것을 돌려줄 수 있다. 반면에 가변 객체에서는 이런 것이 허용되지 않는다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1;</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">1</span></code> 후에, <code class="docutils literal notranslate"><span class="pre">a</span></code> 와 <code class="docutils literal notranslate"><span class="pre">b</span></code> 는 값 1을 갖는 같은 객체일 수도 있고, 아닐 수도 있다. 하지만 <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">[];</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code> 후에, <code class="docutils literal notranslate"><span class="pre">c</span></code> 와 <code class="docutils literal notranslate"><span class="pre">d</span></code> 는 두 개의 서로 다르고, 독립적이고, 새로 만들어진 빈 리스트임이 보장된다. (<code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code> 는 객은 객체를 <code class="docutils literal notranslate"><span class="pre">c</span></code> 와 <code class="docutils literal notranslate"><span class="pre">d</span></code> 에 대입한다.)</p>
</div>
<div class="section" id="the-standard-type-hierarchy">
<span id="types"></span><h2>3.2. 표준형 계층<a class="headerlink" href="#the-standard-type-hierarchy" title="永久链接至标题">¶</a></h2>
<p id="index-4">아래에 파이썬에 내장된 형들의 목록이 있다. (구현에 따라 C 나 자바나 다른 언어로 작성된) 확장 모듈들은 추가의 형을 정의할 수 있다. 파이썬의 미래 버전 역시 형 계층에 형을 더할 수 있는데 (예를 들어, 유리수, 효율적으로 저장된 정수 배열 등등), 표준 라이브러리를 통해 추가될 가능성이 더 크기는 하다.</p>
<p id="index-5">아래에 나오는 몇몇 형에 대한 설명은 '특수 어트리뷰트(special attribute)' 를 나열하는 문단을 포함한다. 이것들은 구현에 접근할 방법을 제공하는데, 일반적인 사용을 위한 것이 아니다. 정의는 앞으로 변경될 수 있다.</p>
<dl class="docutils">
<dt>None</dt>
<dd><p class="first last" id="index-6">이 형은 하나의 값만을 갖는다. 이 값을 갖는 하나의 객체가 존재한다. 이 객체에는 내장된 이름 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 통해 접근한다. 여러 가지 상황에서 값의 부재를 알리는 데 사용된다. 예를 들어, 명시적으로 뭔가를 돌려주지 않는 함수의 반환 값이다. 논리값은 거짓이다.</p>
</dd>
<dt>NotImplemented</dt>
<dd><p class="first" id="index-7">이 형은 하나의 값만을 갖는다. 이 값을 갖는 하나의 객체가 존재한다. 이 객체에는 내장된 이름 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 을 통해 접근한다. 숫자 메서드(numeric method)와 비교(rich comparison) 메서드는 제공된 피연산자에 대해 연산이 구현되지 않으면 이 값을 돌려줘야 한다. (그러면 인터프리터는 연산자에 따라 뒤집힌 연산이나, 어떤 다른 대안을 시도한다.) 논리값은 참이다.</p>
<p class="last">더 자세한 내용은 <a class="reference internal" href="../library/numbers.html#implementing-the-arithmetic-operations"><span class="std std-ref">Implementing the arithmetic operations</span></a> 을 참고하라.</p>
</dd>
<dt>Ellipsis</dt>
<dd><p class="first last" id="index-8">이 형은 하나의 값만을 갖는다. 이 값을 갖는 하나의 객체가 존재한다. 이 객체에는 리터럴 <code class="docutils literal notranslate"><span class="pre">...</span></code> 이나 내장된 이름 <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code> 을 통해 접근한다. 논리값은 참이다.</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Number" title="numbers.Number"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a></dt>
<dd><p class="first" id="index-9">이것들은 숫자 리터럴에 의해 만들어지고, 산순 연산과 내장 산술 함수들이 결과로 돌려준다. 숫자 객체는 불변이다; 한 번 값이 만들어지면 절대 변하지 않는다. 파이썬의 숫자는 당연히 수학적인 숫자들과 밀접하게 관련되어 있다, 하지만 컴퓨터의 숫자 표현상의 제약을 받고 있다.</p>
<p>파이썬은 정수, 실수, 복소수를 구분한다:</p>
<dl class="last docutils">
<dt><a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a></dt>
<dd><p class="first" id="index-10">이것들은 수학적인 정수 집합(양과 음)에 속하는 요소들을 나타낸다.</p>
<p>두 가지 종류의 정수가 있다:</p>
<p>정수 (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>)</p>
<blockquote>
<div>이것은 (가상) 메모리가 허락하는 한, 제약 없는 범위의 숫자를 표현한다. 시프트(shift)와 마스크(mask) 연산이 목적일 때는 이진 표현이 가정되고, 음수는 일종의 2의 보수(2's complement)로 표현되는데, 부호 비트가 왼쪽으로 무한히 확장된 것과 같은 효과를 준다.</div></blockquote>
<dl class="docutils">
<dt>불린 (<a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>)</dt>
<dd><p class="first last" id="index-11">이것은 논리값 거짓과 참을 나타낸다. <code class="docutils literal notranslate"><span class="pre">False</span></code> 와 <code class="docutils literal notranslate"><span class="pre">True</span></code> 두 객체만 불린 형 객체다. 불린 형은 int 형의 자식형(subtype)이고, 대부분 상황에서 각기 0과1처럼 동작한다. 예외는 문자열로 변환되는 경우인데, 각기 문자열 <code class="docutils literal notranslate"><span class="pre">&quot;False&quot;</span></code> 와 <code class="docutils literal notranslate"><span class="pre">&quot;True&quot;</span></code> 가 반환된다.</p>
</dd>
</dl>
<p class="last" id="index-12">정수 표현 규칙은 음수가 포함된 시프트와 마스크 연산에 가장 의미 있는 해석을 제공하기 위한 것이다.</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code></a> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>)</dt>
<dd><p class="first last" id="index-13">이것들은 기계 수준의 배정도(double precision) 부동 소수점 수를 나타낸다. 허락되는 값의 범위와 오버플로의 처리에 관해서는 하부 기계의 설계(와 C 나 자바 구현)에 따르는 수밖에 없다. 파이썬은 단정도(single precision) 부동 소수점 수를 지원하지 않는다; 이것들을 사용하는 이유가 되는 프로세서와 메모리의 절감은 파이썬에서 객체를 사용하는데 들어가는 비용과 상쇄되어 미미해진다. 그 때문에 두 가지 종류의 부동 소수점 수로 언어를 복잡하게 만들만한 가치가 없다.</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Complex" title="numbers.Complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Complex</span></code></a> (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>)</dt>
<dd><p class="first last" id="index-14">이것들은 기계 수준 배정도 부동 소수점 수의 쌍으로 복소수를 나타낸다. 부동 소수점 수와 한계와 문제점을 공유한다. 복소수 <code class="docutils literal notranslate"><span class="pre">z</span></code> 의 실수부와 허수부는, 읽기 전용 어트리뷰트 <code class="docutils literal notranslate"><span class="pre">z.real</span></code> 와 <code class="docutils literal notranslate"><span class="pre">z.imag</span></code> 로 꺼낼 수 있다.</p>
</dd>
</dl>
</dd>
<dt>시퀀스들</dt>
<dd><p class="first" id="index-15">음이 아닌 정수로 인덱싱(indexing)될 수 있는 유한한 길이의 순서 있는 집합을 나타낸다. 내장함수 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 은 시퀀스가 가진 항목들의 개수를 돌려준다. 시퀀스의 길이가 <em>n</em> 일 때, 인덱스(index) 집합은 숫자 0, 1, ..., <em>n</em>-1을 포함한다. 시퀀스 <em>a</em> 의 항목 <em>i</em> 는 <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> 로 선택된다.</p>
<p id="index-16">시퀀스는 슬라이싱도 지원한다: <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> 는 <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>k</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em> 를 만족하는 모든 항목 <em>k</em> 를 선택한다. 표현식에서 사용될 때, 슬라이스는 같은 형의 시퀀스다. 인덱스 집합은 0에서 시작되도록 다시 번호 매겨진다.</p>
<p>어떤 시퀀스는 세 번째 &quot;스텝(step)&quot; 파라미터를 사용하는 &quot;확장 슬라이싱(extended slicing)&quot;도 지원한다: <code class="docutils literal notranslate"><span class="pre">a[i:j:k]</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code>, <em>n</em> <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> <code class="docutils literal notranslate"><span class="pre">0</span></code>, <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>x</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em> 를 만족하는 모든 항목 <em>x</em> 를 선택한다.</p>
<p>시퀀스는 불변성에 따라 구분된다</p>
<dl class="last docutils">
<dt>불변 시퀀스</dt>
<dd><p class="first" id="index-17">불변 시퀀스 형의 객체는 일단 만들어진 후에는 변경될 수 없다. (만약 다른 객체로의 참조를 포함하면, 그 객체는 가변일 수 있고, 변경될 수 있다; 하지만, 불변 객체로부터 참조되는 객체의 집합 자체는 변경될 수 없다.)</p>
<p>다음과 같은 형들은 불변 시퀀스다:</p>
<dl class="last docutils" id="index-18">
<dt>문자열(Strings)</dt>
<dd><p class="first last" id="index-19">문자열은 유니코드 코드 포인트(Unicode code point)들을 표현하는 값들의 시퀀스다. <code class="docutils literal notranslate"><span class="pre">U+0000</span> <span class="pre">-</span> <span class="pre">U+10FFFF</span></code> 범위의 모든 코드 포인트들은 문자열로 표현될 수 있다. 파이썬에는 <code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code> 형이 없다. 대신에 문자열에 있는 각 코드 포인트는 길이 <code class="docutils literal notranslate"><span class="pre">1</span></code> 인 문자열 객체로 표현된다. 내장 함수 <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a> 는 코드 포인트를 문자열 형식에서 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code> 범위의 정수로 변환한다; <a class="reference internal" href="../library/functions.html#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a> 은 범위 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code> 의 정수를 해당하는 길이 <code class="docutils literal notranslate"><span class="pre">1</span></code> 의 문자열 객체로 변환한다. <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> 는 주어진 텍스트 인코딩을 사용해서 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 을 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 로 변환하고, <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> 는 그 반대 작업을 수행한다.</p>
</dd>
<dt>튜플(Tuples)</dt>
<dd><p class="first last" id="index-20">튜플의 항목은 임의의 파이썬 객체다. 두 개 이상의 항목으로 구성되는 튜플은 콤마로 분리된 표현식의 목록으로 만들 수 있다. 하나의 항목으로 구성된 튜플(싱글턴,singleton)은 표현식에 콤마를 붙여서 만들 수 있다(괄호로 표현식을 묶을 수 있으므로, 표현식 만으로는 튜플을 만들지 않는다). 빈 튜플은 한 쌍의 빈 괄호로 만들 수 있다.</p>
</dd>
<dt>바이트열(Bytes)</dt>
<dd><p class="first last" id="index-21">바이트열(bytes) 객체는 불변 배열이다. 항목은 8-비트 바이트인데, 0 &lt;= x &lt; 256 범위의 정수로 표현된다. 바이트 객체를 만들 때는 바이트열 리터럴(<code class="docutils literal notranslate"><span class="pre">b'abc'</span></code> 와 같은) 과 내장 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes()</span></code></a> 생성자(constructor)를 사용할 수 있다. 또한, 바이트열 객체는 <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> 메서드를 통해 문자열로 디코딩될 수 있다.</p>
</dd>
</dl>
</dd>
<dt>가변 시퀀스</dt>
<dd><p class="first" id="index-22">가변 시퀀스는 만들어진 후에 변경될 수 있다. 서브스크립션(subscription)과 슬라이싱은 대입문과 <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> (삭제) 문의 대상으로 사용될 수 있다.</p>
<p>현재 두 개의 내장 가변 시퀀스형이 있다:</p>
<dl class="docutils">
<dt>리스트(Lists)</dt>
<dd><p class="first last" id="index-23">리스트의 항목은 임의의 파이썬 객체다. 리스트는 콤마로 분리된 표현식을 꺾쇠괄호 안에 넣어서 만들 수 있다. (길이 0이나 1의 리스트를 만드는데 별도의 규칙이 필요 없다.)</p>
</dd>
<dt>바이트 배열(Byte Arrays)</dt>
<dd><p class="first last" id="index-24">비이트 배열(bytearray) 객체는 가변 배열이다. 내장 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a> 생성자로 만들어진다. 가변이라는 것(그래서 해싱 불가능하다는 것)을 제외하고, 바이트 배열은 불변 바이트열( <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>) 객체와 같은 인터페이스와 기능을 제공한다.</p>
</dd>
</dl>
<p class="last" id="index-25">확장 모듈 <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> 는 추가의 가변 시퀀스 형을 제공하는데, <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 모듈 역시 마찬가지다.</p>
</dd>
</dl>
</dd>
<dt>집합 형들(Set types)</dt>
<dd><p class="first" id="index-26">이것들은 중복 없는 불변 객체들의 순서 없고 유한한 집합을 나타낸다. 인덱싱할 수 없다. 하지만 이터레이트할 수 있고, 내장 함수 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 은 집합 안에 있는 항목들의 개수를 돌려준다. 집합의 일반적인 용도는 빠른 멤버십 검사(fast membership testing), 시퀀스에서 중복된 항목 제거, 교집합(intersection), 합집합(union), 차집합(difference), 대칭차집합(symmetric difference)과 같은 집합 연산을 계산하는 것이다.</p>
<p>집합의 원소들에는 딕셔너리 키와 같은 불변성 규칙이 적용된다. 숫자 형의 경우는 숫자 비교에 관한 일반 원칙이 적용된다는 점에 주의해야 한다: 만약 두 숫자가 같다고 비교되면(예를 들어, <code class="docutils literal notranslate"><span class="pre">1``과</span> <span class="pre">``1.0</span></code>), 그중 하나만 집합에 들어갈 수 있다.</p>
<p>현재 두 개의 내장 집합 형이 있다:</p>
<dl class="last docutils">
<dt>집합(Sets)</dt>
<dd><p class="first last" id="index-27">이것들은 가변 집합을 나타낸다. 내장 <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal notranslate"><span class="pre">set()</span></code></a> 생성자로 만들 수 있고, <code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code> 같은 메서드들을 사용해서 나중에 수정할 수 있다.</p>
</dd>
<dt>불변 집합(Frozen sets)</dt>
<dd><p class="first last" id="index-28">이것들은 불변 집합을 나타낸다. 내장 <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-func docutils literal notranslate"><span class="pre">frozenset()</span></code></a> 생성자로 만들 수 있다. 불변 집합(frozenset)은 불변이고 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">해시 가능</span></a> 하므로, 다른 집합의 원소나, 딕셔너리의 키로 사용될 수 있다.</p>
</dd>
</dl>
</dd>
<dt>매핑(Mappings)</dt>
<dd><p class="first" id="index-29">이것들은 임의의 인덱스 집합으로 인덱싱되는 객체들의 유한한 집합을 나타낸다. 인덱스 표기법(subscript notation) <code class="docutils literal notranslate"><span class="pre">a[k]</span></code> 는 매핑 <code class="docutils literal notranslate"><span class="pre">a</span></code> 에서 <code class="docutils literal notranslate"><span class="pre">k</span></code> 로 인덱스 되는 항목을 선택한다; 이것은 표현식에 사용될 수도 있고, 대입이나 <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> 문장의 대상이 될 수도 있다. 내장 함수 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 은 매핑에 포함된 항목들의 개수를 돌려준다.</p>
<p>현재 한 개의 내장 매핑 형이 있다:</p>
<dl class="last docutils">
<dt>딕셔너리(Dictionaries)</dt>
<dd><p class="first" id="index-30">이것들은 거의 임의의 인덱스 집합으로 인덱싱되는 객체들의 유한한 집합을 나타낸다. 키로 사용할 수 없는 것들은 리스트, 딕셔너리나 그 외의 가변형 중에서 아이덴티티가 아니라 값으로 비교되는 것들뿐이다. 딕셔너리의 효율적인 구현이, 키의 해시값이 도중에 변경되지 않고 계속 같은 값으로 유지되도록 요구하고 있기 때문이다. 키로 사용되는 숫자 형의 경우는 숫자 비교에 관한 일반 원칙이 적용된다: 만약 두 숫자가 같다고 비교되면(예를 들어, <code class="docutils literal notranslate"><span class="pre">1``과</span> <span class="pre">``1.0</span></code>), 둘 다 같은 딕셔너리 항목을 인덱싱하는데 사용될 수 있다.</p>
<p>딕셔너리는 가변이다; <code class="docutils literal notranslate"><span class="pre">{...}</span></code> 표기법으로 만들 수 있다 (<a class="reference internal" href="expressions.html#dict"><span class="std std-ref">딕셔너리 디스플레이</span></a> 섹션을 참고하라).</p>
<p class="last" id="index-31">확장 모듈 <a class="reference internal" href="../library/dbm.html#module-dbm.ndbm" title="dbm.ndbm: The standard &quot;database&quot; interface, based on ndbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.ndbm</span></code></a> 과 <a class="reference internal" href="../library/dbm.html#module-dbm.gnu" title="dbm.gnu: GNU's reinterpretation of dbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.gnu</span></code></a> 는 추가의 매핑 형을 제공하는데, <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 모듈 역시 마찬가지다.</p>
</dd>
</dl>
</dd>
<dt>콜러블(Callable types)</dt>
<dd><p class="first" id="index-32">이것들은 함수 호출 연산(<a class="reference internal" href="expressions.html#calls"><span class="std std-ref">호출</span></a> 섹션 참고)이 적용될 수 있는 형들이다:</p>
<dl class="last docutils">
<dt>사용자 정의 함수</dt>
<dd><p class="first" id="index-33">사용자 정의 함수 객체는 함수 정의를 통해 만들어진다 (<a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">함수 정의</span></a> 섹션 참고). 함수의 형식 파라미터(formal parameter) 목록과 같은 개수의 항목을 포함하는 인자(argument) 목록으로 호출되어야 한다.</p>
<p>특수 어트리뷰트들(Special attributes):</p>
<table border="1" class="docutils" id="index-34">
<colgroup>
<col width="37%" />
<col width="46%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">어트리뷰트</th>
<th class="head">의미</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></td>
<td>함수를 설명하는 문자열 또는 없는 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code>; 서브 클래스로 상속되지 않는다</td>
<td>쓰기 가능</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></td>
<td>함수의 이름</td>
<td>쓰기 가능</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../library/stdtypes.html#definition.__qualname__" title="definition.__qualname__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__qualname__</span></code></a></td>
<td><p class="first">함수의 <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">정규화된 이름</span></a></p>
<div class="last versionadded">
<p><span class="versionmodified">3.3 新版功能.</span></p>
</div>
</td>
<td>쓰기 가능</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code></td>
<td>함수가 정의된 모듈의 이름 또는 (없는 경우) <code class="docutils literal notranslate"><span class="pre">None</span></code></td>
<td>쓰기 가능</td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal notranslate"><span class="pre">__defaults__</span></code></td>
<td>인자의 기본값 또는 (없는 경우) <cite>None</cite> 으로 만들어진 튜플</td>
<td>쓰기 가능</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-attr docutils literal notranslate"><span class="pre">__code__</span></code></td>
<td>컴파일된 함수의 바디(body) 를 나타내는 코드 객체</td>
<td>쓰기 가능</td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal notranslate"><span class="pre">__globals__</span></code></td>
<td>함수의 전역 변수들을 가진 딕셔너리에 대한 참조 --- 함수가 정의된 모듈의 전역 이름 공간(namespace)</td>
<td>읽기 전용</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a></td>
<td>임의의 함수 어트리뷰트를 지원하는 이름 공간.</td>
<td>쓰기 가능</td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal notranslate"><span class="pre">__closure__</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">None</span></code> 또는 함수의 자유 변수(free variable)들에 대한 연결을 가진 셀(cell)들의 튜플.</td>
<td>읽기 전용</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></td>
<td>파라미터의 어노테이션을 가진 dict. dict 의 키는 파라미터의 이름인데, 반환 값 어노테이션이 있다면 <code class="docutils literal notranslate"><span class="pre">'return'</span></code> 을 키로 사용한다.</td>
<td>쓰기 가능</td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal notranslate"><span class="pre">__kwdefaults__</span></code></td>
<td>키워드 형태로만 전달 가능한 파라미터들의 기본값을 가진 dict.</td>
<td>쓰기 가능</td>
</tr>
</tbody>
</table>
<p>&quot;쓰기 가능&quot; 하다고 표시된 대부분의 어트리뷰트들은 값이 대입될 때 형을 검사한다.</p>
<p>함수 객체는 임의의 어트리뷰트를 읽고 쓸 수 있도록 지원하는데, 예를 들어 함수에 메타데이터(metadata)를 붙이는데 사용될 수 있다. 어트리뷰트를 읽거나 쓸 때는 일반적인 점 표현법(dot-notation)이 사용된다. <em>현재 구현은 오직 사용자 정의 함수만 함수 어트리뷰트를 지원함에 주의해야 한다. 내장 함수의 함수 어트리뷰트는 미래에 지원될 수 있다.</em></p>
<p class="last">함수 정의에 관한 추가적인 정보를 코드 객체로부터 얻을 수 있다. 아래에 나오는 내부 형의 기술을 참고하라.</p>
</dd>
<dt>인스턴스 메서드(Instance methods)</dt>
<dd><p class="first" id="index-35">인스턴스 메서드는 클래스, 클래스 인스턴스와 모든 콜러블 객체 (보통 사용자 정의 함수)을 결합한다.</p>
<p id="index-36">특수 읽기 전용 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 는 클래스 인스턴스 객체, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> 는 함수 객체; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 은 메서드의 설명 (<code class="docutils literal notranslate"><span class="pre">__func__.__doc__</span></code> 과 같다); <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 은 메서드의 이름 (<code class="docutils literal notranslate"><span class="pre">__func__.__name__</span></code> 과 같다); <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> 은 메서드가 정의된 모듈의 이름이거나 없는 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>메서드는 기반 함수의 모든 함수 어트리뷰트들을 읽을 수 있도록 지원한다(하지만 쓰기는 지원하지 않는다).</p>
<p>어트리뷰트가 사용자 정의 함수 객체이거나 클래스 메서드 객체면, 사용자 정의 메서드 객체는 클래스의 어트리뷰트를 읽을 때 만들어질 수 있다 (아마도 그 클래스의 인스턴스를 통해서).</p>
<p>인스턴스 메서드 객체가 클래스 인스턴스를 통해 클래스의 사용자 정의 함수 객체를 읽음으로써 만들어질 때, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 어트리뷰트는 인스턴스이고, 메서드 객체는 결합(bound)하였다고 말한다. 새 메서드의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> 어트리뷰트는 원래의 함수 객체다.</p>
<p>클래스나 인스턴스로부터 다른 메서드 객체를 읽음으로써 사용자 정의 메서드 객체가 만들어질 때, 새 인스턴스의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> 어트리뷰트가 원래의 메서드 객체가 아니라, 그것의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> 어트리뷰트라는 점만 제외하고는 함수 객체의 경우와 같은 방식으로 동작한다.</p>
<p>인스턴스 메서드 객체가 클래스나 인스턴스로부터 클래스 메서드 객체를 읽음으로써 만들어질 때, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 어트리뷰트는 클래스 자신이고, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> 어트리뷰트는 클래스 메서드가 기반을 두는 함수 객체다.</p>
<p>인스턴스 메서드 객체가 호출될 때, 기반을 두는 함수 (<code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code>) 가 호출되는데, 인자 목록의 앞에 클래스 인스턴스 (<code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code>) 가 삽입된다. 예를 들어, <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 가 함수 <code class="xref py py-meth docutils literal notranslate"><span class="pre">f()</span></code> 의 정의를 포함하는 클래스이고, <code class="docutils literal notranslate"><span class="pre">x</span></code> 가 <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 의 인스턴스일 때, <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> 를 호출하는 것은 <code class="docutils literal notranslate"><span class="pre">C.f(x,</span> <span class="pre">1)</span></code> 을 호출하는 것과 같다.</p>
<p>인스턴스 메서드 객체가 클래스 메서드 객체로부터 올 때, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 에 저장된 &quot;클래스 인스턴스&quot; 는 실제로는 클래스 자신이다. 그래서 <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> 이나 <code class="docutils literal notranslate"><span class="pre">C.f(1)</span></code> 을 호출하는 것은 <code class="docutils literal notranslate"><span class="pre">f(C,1)</span></code> 를 호출하는 것과 같다 (<code class="docutils literal notranslate"><span class="pre">f</span></code> 는 기반 함수다).</p>
<p class="last">함수 객체에서 인스턴스 객체로의 변환은 인스턴스로부터 어트리뷰트를 읽을 때마다 일어남에 주의해야 한다. 어떤 경우에, 어트리뷰트를 지역 변수에 대입하고, 그 지역 변수를 호출하는 것이 효과적인 최적화가 된다. 또한, 이 변환이 사용자 정의 함수에 대해서만 발생함에 주의해야 한다; 다른 콜러블 객체 (그리고 콜러블이 아닌 모든 객체)는 변환 없이 읽힌다. 클래스 인스턴스의 어트리뷰트인 사용자 정의 함수는 결합한 메서드로 변환되지 않는다는 것도 중요하다; 이 변환은 함수가 클래스 어트리뷰트일 때만 일어난다.</p>
</dd>
<dt>제너레이터 함수(Generator functions)</dt>
<dd><p class="first last" id="index-37"><a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 문(<a class="reference internal" href="simple_stmts.html#yield"><span class="std std-ref">yield 문</span></a> 절 참조)을 사용하는 함수나 메서드를 <em class="dfn">제너레이터 함수 (generator function)</em> 라고 부른다. 이런 함수를 호출하면 항상 이터레이터(iterator) 객체를 돌려주는데, 함수의 바디(body)를 실행하는 데 사용된다: 이터레이터의 <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterator.__next__()</span></code></a> 메서드를 호출하면 <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 문이 값을 제공할 때까지 함수가 실행된다. 함수가 <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 문을 실행하거나 끝에 도달하면 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 예외를 일으키고, 이터레이터는 반환하는 값들의 끝에 도달하게 된다.</p>
</dd>
<dt>코루틴 함수(Coroutine functions)</dt>
<dd><p class="first last" id="index-38"><a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 를 사용해서 정의되는 함수나 메서드를 <em class="dfn">코루틴 함수 (coroutine function)</em> 라고 부른다. 이런 함수를 호출하면 <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">코루틴</span></a> 객체를 돌려준다. <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식을 비롯해, <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 와 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 문을 사용할 수 있다. <a class="reference internal" href="#coroutine-objects"><span class="std std-ref">코루틴 객체(Coroutine Objects)</span></a> 섹션을 참조.</p>
</dd>
<dt>비동기 제너레이터 함수(Asynchronous generator functions)</dt>
<dd><p class="first" id="index-39"><a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 를 사용해서 정의되는 함수가 <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 문을 사용하면 <em class="dfn">비동기 제너레이터 함수 (asynchronous generator function)</em> 라고 부른다. 이런 함수를 호출하면 항상 비동기 이터레이터(asynchronous iterator) 객체를 돌려주는데, 함수의 바디(body)를 실행하기 위해 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 문에서 사용된다.</p>
<p class="last">비동기 이터레이터의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">aiterator.__anext__()</span></code> 메서드를 호출하면 <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a> 을 돌려주는데, await 할 때 <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 문이 값을 제공할 때까지 함수가 실행된다. 함수가 빈 <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 문을 실행하거나 끝에 도달하면 <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 예외를 일으키고, 비동기 이터레이터는 반환하는 값들의 끝에 도달하게 된다.</p>
</dd>
<dt>내장 함수(Built-in functions)</dt>
<dd><p class="first last" id="index-40">내장 함수 객체는 C 함수를 둘러싸고 있다(wrapper). 내장 함수의 예로는 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 과 <a class="reference internal" href="../library/math.html#math.sin" title="math.sin"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.sin()</span></code></a> (<a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 는 표준 내장 모듈이다) 가 있다. 인자의 개수와 형은 C 함수에 의해 결정된다. 특수 읽기 전용 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 은 함수의 설명 문자열 또는 없는 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이다; <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 은 함수의 이름이다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 는 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정된다 (하지만 다음 항목을 보라); <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> 은 함수가 정의된 모듈의 이름이거나 없는 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이다.</p>
</dd>
<dt>내장 메서드(Built-in methods)</dt>
<dd><p class="first last" id="index-41">이것은 사실 내장 함수의 다른 모습이다. 이번에는 묵시적인 추가의 인자로 C 함수에 전달되는 객체를 갖고 있다. 내장 메서드의 예로는 <code class="docutils literal notranslate"><span class="pre">alist.append()</span></code> 가 있는데, <em>alist</em> 는 리스트 객체다. 이 경우에, 특수 읽기 전용 어트리뷰트 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 는 <em>alist</em> 로 표현된 객체로 설정된다.</p>
</dd>
<dt>클래스(Classes)</dt>
<dd>클래스는 콜러블이다. 이 객체들은 보통 자신의 새로운 인스턴스를 만드는 팩토리(factory)로 동작하는데, <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 메서드를 재정의(override) 하는 클래스 형에서는 달라질 수도 있다. 호출 인자는 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 로 전달되고, 일반적으로, 새 인스턴스를 초기화하기 위해 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 로도 전달된다.</dd>
<dt>클래스 인스턴스(Class Instances)</dt>
<dd>클래스에서 <a class="reference internal" href="#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> 메서드를 정의함으로써, 클래스 인스턴스를 콜러블로 만들 수 있다.</dd>
</dl>
</dd>
<dt>모듈(Modules)</dt>
<dd><p class="first" id="index-42">모듈은 파이썬 코드의 기본적인 조직화 단위이고, <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문(<a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 를 참고)이나, <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 과 내장 <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수를 호출해서 구동할 수 있는 <a class="reference internal" href="import.html#importsystem"><span class="std std-ref">임포트 시스템</span></a> 에 의해 만들어진다. 모듈 객체는 딕셔너리 객체로 구현되는 이름 공간을 갖는다(이 딕셔너리 객체는 모듈에서 정의되는 함수들의 <code class="docutils literal notranslate"><span class="pre">__globals__</span></code> 어트리뷰트로 참조된다). 어트리뷰트 참조는 이 딕셔너리에 대한 조회로 변환된다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">m.x</span></code> 는 <code class="docutils literal notranslate"><span class="pre">m.__dict__[&quot;x&quot;]</span></code> 와 같다. 모듈 객체는 모듈을 초기화하는데 사용된 코드 객체를 갖고 있지 않다 (일단 초기화가 끝나면 필요 없으므로).</p>
<p>어트리뷰트 대입은 모듈의 이름 공간 딕셔너리를 갱신한다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">m.x</span> <span class="pre">=</span> <span class="pre">1</span></code> 은 <code class="docutils literal notranslate"><span class="pre">m.__dict__[&quot;x&quot;]</span> <span class="pre">=</span> <span class="pre">1</span></code> 과 같다.</p>
<p id="index-43">미리 정의된 (쓰기 가능한) 어트리뷰트들: <a class="reference internal" href="import.html#__name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 은 모듈의 이름이다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 은 모듈의 설명 문자열 또는 없는 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이다; (없을 수도 있는) <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> 는 모듈의 바디를 실행하면서 수집된 <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">변수 어노테이션</span></a> 들을 담은 딕셔너리다; <a class="reference internal" href="import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> 은 모듈이 로드된 파일의 경로명이다. 인터프리터에 정적으로 연결된 C 모듈과 같은 어떤 종류의 모듈들에서는 <a class="reference internal" href="import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> 어트리뷰트가 제공되지 않는다; 공유 라이브러리(shared library)로부터 동적으로 로딩되는 확장 모듈의 경우 공유 라이브러리의 경로명이 제공된다.</p>
<p id="index-44">특수 읽기 전용 어트리뷰트들: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 는 딕셔너리로 표현되는 모듈의 이름 공간이다.</p>
<div class="impl-detail last compound">
<p><strong>CPython 구현 상세:</strong> CPython 이 모듈 딕셔너리를 비우는 방법 때문에, 딕셔너리에 대한 참조가 남아있더라도, 모듈이 스코프를 벗어나면 모듈 딕셔너리는 비워진다. 이것을 피하려면, 딕셔너리를 복사하거나 딕셔너리를 직접 이용하는 동안은 모듈을 잡아두어야 한다.</p>
</div>
</dd>
<dt>사용자 정의 클래스(Custom classes)</dt>
<dd><p class="first">사용자 정의 클래스 형들은 보통 클래스 정의 때문에 만들어진다 (<a class="reference internal" href="compound_stmts.html#class"><span class="std std-ref">클래스 정의</span></a> 섹션 참조). 클래스는 딕셔너리로 구현된 이름 공간을 갖는다. 클래스 어트리뷰트 참조는 이 딕셔너리에 대한 조회로 변환된다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">C.x</span></code> 는 <code class="docutils literal notranslate"><span class="pre">C.__dict__[&quot;x&quot;]</span></code> 로 변환된다 (하지만 어트리뷰트에 접근하는 다른 방법들을 허락하는 여러 가지 훅(hook)이 있다.). 거기에서 어트리뷰트 이름이 발견되지 않으면, 어트리뷰트 검색은 부모 클래스들에서 계속된다. 이 부모 클래스 검색은 C3 메서드 결정 순서(method resolution order)를 사용하는데, 다중 상속이 같은 부모 클래스로 모이는 '다이아몬드(diamond)' 계승 구조가 존재해도 올바르게 동작한다. 파이썬이 사용하는 C3 MRO에 관한 좀 더 자세한 내용은 2.3 배포에 첨부된 문서 <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a> 에서 찾아볼 수 있다.</p>
<p id="index-45">클래스 어트리뷰트 참조가 (클래스 <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 라고 하자) 클래스 메서드 객체로 귀결될 때는, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 어트리뷰트가 <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 인 인스턴스 메서드 객체로 변환된다. 스태틱 메서드로 귀결될 때는, 스태틱 메서드 객체가 감싸고 있는 객체로 변환된다. 클래스로부터 얻은 어트리뷰트가 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 에 저장된 값과 달라지도록 만드는 다른 방법이 <a class="reference internal" href="#descriptors"><span class="std std-ref">디스크립터 구현하기</span></a> 섹션에 나온다.</p>
<p id="index-46">클래스 어트리뷰트 대입은 클래스의 딕셔너리를 갱신할 뿐, 어떤 경우도 부모 클래스의 딕셔너리를 건드리지는 않는다.</p>
<p id="index-47">클래스 객체는 클래스 인스턴스를 돌려주도록(아래를 보라) 호출될 수 있다(위를 보라).</p>
<p class="last" id="index-48">특수 어트리뷰트들:<a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 은 클래스의 이름이다. <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> 은 클래스가 정의된 모듈의 이름이다. <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 는 클래스의 이름 공간을 저장하는 딕셔너리다; <a class="reference internal" href="../library/stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code></a> 는 부모 클래스들을 저장하는 튜플이다; 부모 클래스 목록에 나타나는 순서를 유지한다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 은 클래스의 설명 문자열 이거나 정의되지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이다; (없을 수 있는) <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> 는 클래스의 바디를 실행하면서 수집된 <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">변수 어노테이션</span></a> 들을 담은 딕셔너리다.</p>
</dd>
<dt>클래스 인스턴스(Class instances)</dt>
<dd><p class="first" id="index-49">클래스 인스턴스는 클래스 객체를 호출해서 (위를 보라) 만들어진다. 클래스 인스턴스는 딕셔너리로 구현되는 이름 공간을 갖는데, 어트리뷰트를 참조할 때 가장 먼저 검색되는 곳이다. 그곳에서 어트리뷰트가 발견되지 않고, 인스턴스의 클래스가 그 이름의 어트리뷰트를 갖고 있으면, 클래스 어트리뷰트로 검색이 계속된다. 만약 발견된 클래스 어트리뷰트가 사용자 정의 함수면, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 어트리뷰트가 인스턴스인 인스턴스 메서드로 변환된다. 스태틱 메서드와 클래스 메서드 객체 또한 변환된다. 위의 &quot;사용자 정의 클래스(Custom Classes)&quot; 부분을 보라. 클래스로부터 얻은 어트리뷰트가 클래스의 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 에 저장된 값과 달라지도록 만드는 다른 방법이 <a class="reference internal" href="#descriptors"><span class="std std-ref">디스크립터 구현하기</span></a> 섹션에 나온다. 만약 클래스 어트리뷰트도 발견되지 않고, 클래스가 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 메서드를 가지면, 조회를 만족시키기 위해 그 메서드를 호출한다.</p>
<p id="index-50">어트리뷰트 대입과 삭제는 인스턴스의 딕셔너리를 갱신할 뿐, 결코 클래스의 딕셔너리를 건드리지 않는다. 만약 클래스가 <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 이나 <a class="reference internal" href="#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code></a> 메서드를 가지면, 인스턴스의 딕셔너리를 갱신하는 대신에 그 메서드들을 호출한다.</p>
<p id="index-51">어떤 특별한 이름들의 메서드들을 가지면, 클래스 인스턴스는 숫자, 시퀀스, 매핑인 척할 수 있다. <a class="reference internal" href="#specialnames"><span class="std std-ref">특수 메서드 이름들</span></a> 섹션을 보라.</p>
<p class="last" id="index-52">특수 어트리뷰트들: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 는 어트리뷰트 딕셔너리다; <a class="reference internal" href="../library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> 는 인스턴스의 클래스다.</p>
</dd>
<dt>I/O 객체 (파일 객체라고도 알려져 있다)</dt>
<dd><p class="first" id="index-53"><a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a> 는 열린 파일을 나타낸다. 파일 객체를 만드는 여러 가지 단축법이 있다: <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 내장 함수, <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.popen()</span></code></a>, <a class="reference internal" href="../library/os.html#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fdopen()</span></code></a> 과 소켓 객체의 <a class="reference internal" href="../library/socket.html#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a> 메서드 (그리고, 아마도 확장 모듈들이 제공하는 다른 함수들이나 메서드들).</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> 는 인터프리터의 표준 입력, 출력, 에러 스트림으로 초기화된 파일 객체들이다; 모두 텍스트 모드로 열려서 <a class="reference internal" href="../library/io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a> 추상 클래스에 의해 정의된 인터페이스를 따른다.</p>
</dd>
<dt>내부 형(Internal types)</dt>
<dd><p class="first" id="index-54">인터프리터가 내부적으로 사용하는 몇몇 형들은 사용자에게 노출된다. 인터프리터의 미래 버전에서 이들의 정의는 변경될 수 있지만, 완전함을 위해 여기서 언급한다.</p>
<dl class="docutils" id="index-55">
<dt>코드 객체(Code objects)</dt>
<dd><p class="first">코드 객체는 <em>바이트로 컴파일된(byte-compiled)</em> 실행 가능한 파이썬 코드를 나타내는데, 그냥 <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">바이트 코드</span></a> 라고도 부른다. 코드 객체와 함수 객체 간에는 차이가 있다; 함수 객체는 함수의 전역 공간(globals) (함수가 정의된 모듈)을 명시적으로 참조하고 있지만, 코드 객체는 어떤 문맥(context)도 갖고 있지 않다; 또한 기본 인자값들이 함수 객체에 저장되어 있지만 코드 객체에는 들어있지 않다 (실행 시간에 계산되는 값들을 나타내기 때문이다). 함수 객체와는 달리, 코드 객체는 불변이고 가변 객체들에 대한 어떤 참조도 (직접 혹은 간접적으로도) 갖고 있지 않다.</p>
<p id="index-56">특수 읽기 전용 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_name</span></code> 은 함수의 이름이다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_argcount</span></code> 는 위치 인자들 (기본값이 있는 인자들도 포함된다)의 개수다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_nlocals</span></code> 는 함수가 사용하는 지역 변수들 (인자들을 포함한다)의 개수다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_varnames</span></code> 는 지역 변수들의 이름을 담고 있는 튜플이다(인자들의 이름이 먼저 나온다); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_cellvars</span></code> 는 중첩된 함수들이 참조하는 지역 변수들의 이름을 담고 있는 튜플이다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_freevars</span></code> 는 자유 변수(free variables)들의 이름을 담고 있는 튜플이다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_code</span></code> 는 바이트 코드 명령 시퀀스를 나타내는 문자열이다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_consts</span></code> 는 바이트 코드가 사용하는 리터럴을 포함하는 튜플이다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_names</span></code> 는 바이트 코드가 사용하는 이름들을 담고 있는 튜플이다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_filename</span></code> 은 컴파일된 코드를 제공한 파일의 이름이다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_firstlineno</span></code> 는 함수의 첫 번째 줄 번호다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_lnotab</span></code> 은 바이트 코드에서의 위치를 줄 번호로 매핑하는 법을 문자열로 인코딩한 값이다 (자세한 내용은 인터프리터의 소스 코드를 참고하라); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_stacksize</span></code> 는 필요한 스택의 크기다 (지역 변수를 포함한다); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> 는 인터프리터의 여러 플래그(flag)들을 정수로 인코딩한 값이다.</p>
<p id="index-57">다음과 같은 값들이 <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> 를 위해 정의되어 있다: 함수가 가변 개수의 위치 인자를 받아들이기 위해 사용되는 <code class="docutils literal notranslate"><span class="pre">*arguments</span></code> 문법을 사용하면 비트 <code class="docutils literal notranslate"><span class="pre">0x04</span></code> 가 1이 된다; 임의의 키워드 인자를 받아들이기 위해 사용하는 <code class="docutils literal notranslate"><span class="pre">**keywords</span></code> 문법을 사용하면 비트 <code class="docutils literal notranslate"><span class="pre">0x08</span></code> 이 1이 된다; 비트 <code class="docutils literal notranslate"><span class="pre">0x20</span></code> 은 함수가 제너레이터일 때 설정된다.</p>
<p>퓨처 기능 선언 (<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code>) 또한 코드 객체가 특정 기능이 활성화된 상태에서 컴파일되었는지를 나타내기 위해 <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> 의 비트들을 사용한다: 함수가 퓨처 division이 활성화된 상태에서 컴파일되었으면 비트 <code class="docutils literal notranslate"><span class="pre">0x2000</span></code> 이 설정된다; 비트 <code class="docutils literal notranslate"><span class="pre">0x10</span></code> 과 <code class="docutils literal notranslate"><span class="pre">0x1000</span></code> 는 예전 버전의 파이썬에서 사용되었다.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> 의 다른 비트들은 내부 사용을 위해 예약되어 있다.</p>
<p class="last" id="index-58">만약 코드 객체가 함수를 나타낸다면, <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_consts</span></code> 의 첫 번째 항목은 설명 문자열이거나 정의되지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이다.</p>
</dd>
</dl>
<dl class="last docutils" id="frame-objects">
<dt>프레임 객체(Frame objects)</dt>
<dd><p class="first" id="index-59">프레임 객체는 실행 프레임(execution frame)을 나타낸다. 트레이스백 객체에 등장할 수 있다 (아래를 보라).</p>
<p id="index-60">특수 읽기 전용 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_back</span></code> 은 이전 스택 프레임 (호출자 방향으로)을 가리키거나 이게 스택의 바닥이라면 <code class="docutils literal notranslate"><span class="pre">None</span></code>; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_code</span></code> 는 이 프레임에서 실행되는 코드 객체; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_locals</span></code> 는 지역 변수를 조회하는데 사용되는 딕셔너리; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_globals</span></code> 는 전역 변수에 사용된다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_builtins</span></code> 는 내장된(intrinsic) 이름들에 사용된다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lasti</span></code> 는 정확한 바이트 코드 명령(instruction)을 제공한다 (코드 객체의 바이트 코드 문자열에 대한 인덱스다).</p>
<p id="index-61">특수 쓰기 가능 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace</span></code> 는, <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 아니면, 각 소스 코드 줄을 시작할 때 호출되는 함수다 (디버거에서 사용된다); <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lineno</span></code> 는 프레임의 현재 줄 번호다 --- 트레이스 함수(f_trace)에서 이 값을 쓰면 해당 줄로 점프한다 (오직 가장 바닥 프레임에서만 가능하다). 디버거는 f_lineno 를 쓰기 위한 점프 명령을 구현할 수 있다 (소위 Set Next Statement).</p>
<p>프레임 객체는 한가지 메서드를 지원한다:</p>
<dl class="last method">
<dt id="frame.clear">
<code class="descclassname">frame.</code><code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frame.clear" title="永久链接至目标">¶</a></dt>
<dd><p>이 메서드는 프레임이 잡은 지역 변수들에 대한 모든 참조를 제거한다. 또한, 만약 프레임이 제너레이터에 속하면, 제너레이터가 종료된다(finalize). 이것은 프레임 객체가 관련된 참조 순환을 깨는 데 도움을 준다 (예를 들어, 예외를 잡아서 트레이스백을 추후 사용을 위해 저장할 때).</p>
<p>만약 프레임이 현재 실행 중이면 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 예외가 발생한다.</p>
<div class="versionadded">
<p><span class="versionmodified">3.4 新版功能.</span></p>
</div>
</dd></dl>

</dd>
<dt>트레이스백 객체(Traceback objects)</dt>
<dd><p class="first" id="index-62">트레이스백 객체는 예외의 스택 트레이스를 나타낸다. 트레이스백 객체는 예외가 발생할 때 만들어진다. 예외 처리기를 찾아서 실행 스택을 되감을 때, 각각 되감기 단계마다 현재 트레이스백의 앞에 트레이스백 객체를 삽입한다. 예외 처리기에 들어가면, 스택 트레이스를 프로그램이 사용할 수 있다. (<a class="reference internal" href="compound_stmts.html#try"><span class="std std-ref">try 문</span></a> 섹션 참조.) <code class="docutils literal notranslate"><span class="pre">sys.exc_info()</span></code> 가 돌려주는 튜플의 세 번째 항목에 있다. 프로그램이 적절한 처리기를 제공하지 않는 경우, 스택 트레이스는 표준 에러 스트림으로 (보기 좋게 포맷되어) 출력된다; 만약 인터프리터가 대화형이면, <code class="docutils literal notranslate"><span class="pre">sys.last_traceback</span></code> 으로 사용자에게 제공한다.</p>
<p class="last" id="index-63">특수 읽기 전용 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_next</span></code> 는 스택 트레이스의 다음 단계 (예외가 발생한 프레임 방향으로)이거나 다음 단계가 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이다. <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_frame</span></code> 은 현 단계에서의 실행 프레임이다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_lineno</span></code> 는 예외가 발생한 줄의 번호를 준다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_lasti</span></code> 정확한 바이트 코드 명령을 가리킨다. 만약 예외가 except 절이나 finally 절이 없는 <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 문에서 발생하면, 줄 번호와 트레이스백의 마지막 명령(last instruction)은 프레임 객체의 줄 번호와 다를 수 있다.</p>
</dd>
<dt>슬라이스 객체(Slice objects)</dt>
<dd><p class="first" id="index-64">슬라이스 객체는 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 메서드를 위한 슬라이스를 나타낸다. 내장 함수 <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a> 로 만들 수도 있다.</p>
<p id="index-65">특수 읽기 전용 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code> 는 하한(lower bound) 이다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code> 은 상한(upper bound) 이다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code> 은 스텝 값이다; 각 값은 생략될 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이다. 이 어트리뷰트들은 임의의 형이 될 수 있다.</p>
<p>슬라이스 객체는 하나의 메서드를 지원한다.</p>
<dl class="last method">
<dt id="slice.indices">
<code class="descclassname">slice.</code><code class="descname">indices</code><span class="sig-paren">(</span><em>self</em>, <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#slice.indices" title="永久链接至目标">¶</a></dt>
<dd><p>이 메서드는 하나의 정수 인자 <em>length</em> 를 받아서 슬라이스 객체가 길이 <em>length</em> 인 시퀀스에 적용되었을 때 그 슬라이스에 대한 정보를 계산한다. 세 개의 정수로 구성된 튜플을 돌려준다: 이것들은 각각 <em>start</em> 와 <em>stop</em> 인덱스와, <em>step</em> 또는 슬라이스의 스트라이드(stride) 길이다. 생략되었거나 범위를 벗어난 인덱스들은 일반적인 슬라이스와 같은 방법으로 다뤄진다.</p>
</dd></dl>

</dd>
<dt>스태틱 메서드 객체(Static method objects)</dt>
<dd>스태틱 메서드 객체는 위에서 설명한 함수 객체를 메서드 객체로 변환하는 과정을 방지하는 방법을 제공한다. 스태틱 메서드 객체는 다른 임의의 객체, 보통 사용자 정의 메서드를 둘러싼다. 스태틱 메서드가 클래스나 클래스 인스턴스로부터 읽힐 때 객체가 실제로 돌려주는 것은 둘러싸여 있던 객체인데, 다른 어떤 변환도 적용되지 않은 상태다. 둘러싸는 객체는 그렇더라도, 스태틱 메서드 객체 자체는 콜러블이 아니다. 스태틱 메서드 객체는 내장 <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a> 생성자로 만든다.</dd>
<dt>클래스 메서드 객체(Class method objects)</dt>
<dd>스태틱 메서드 객체처럼, 클래스 메서드 객체 역시 다른 객체를 둘러싸는데, 클래스와 클래스 인스턴스로부터 그 객체를 꺼내는 방식에 변화를 준다. 그런 조회에서 클래스 메서드 객체가 동작하는 방식에 대해서는 위 &quot;사용자 정의 메서드(User-defined methods)&quot; 에서 설명했다. 클래스 메서드 객체는 내장 <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> 생성자로 만든다.</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="special-method-names">
<span id="specialnames"></span><h2>3.3. 특수 메서드 이름들<a class="headerlink" href="#special-method-names" title="永久链接至标题">¶</a></h2>
<p id="index-66">클래스는 특별한 이름의 메서드들을 정의함으로써 특별한 문법 (산술 연산이나 인덱싱이나 슬라이딩 같은)에 의해 시작되는 어떤 연산들을 구현할 수 있다. 이것이 연산자 오버 로딩(<em class="dfn">operator overloading</em>) 에 대한 파이썬의 접근법인데, 클래스가 언어의 연산자에 대해 자기 자신의 동작을 정의할 수 있도록 한다. 예를 들어, 클래스가 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 이라는 이름의 메서드를 정의하고, <code class="docutils literal notranslate"><span class="pre">x</span></code> 가 이 클래스의 인스턴스라면, <code class="docutils literal notranslate"><span class="pre">x[i]</span></code> 는 대략 <code class="docutils literal notranslate"><span class="pre">type(x).__getitem__(x,</span> <span class="pre">i)</span></code> 와 동등하다. 언급된 경우를 제외하고, 적절한 메서드가 정의되지 않았을 때 연산은 예외를 일으킨다 (보통 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 나 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>).</p>
<p>특수 메서드를 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정하는 것은 해당 연산이 제공되지 않는다는 것을 가리킨다. 예를 들어, 만약 클래스가 <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 를 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정하면, 클래스는 이터러블이 아니다. 따라서 이 인스턴스에 <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 를 호출하면 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 가 발생한다. (<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 을 대안으로 시도하지 않는다.) <a class="footnote-reference" href="#id9" id="id2">[2]</a></p>
<p>내장형을 흉내 내는 클래스를 구현할 때, 모방은 모형화하는 객체에 말이 되는 수준까지만 구현하는 것이 중요하다. 예를 들어, 어떤 시퀀스는 개별 항목들을 꺼내는 것만으로도 잘 동작할 수 있다. 하지만 슬라이스를 꺼내는 것은 말이 안 될 수 있다. (이런 한가지 예는 W3C의 Document Object Model의 <code class="xref py py-class docutils literal notranslate"><span class="pre">NodeList</span></code> 인터페이스다.)</p>
<div class="section" id="basic-customization">
<span id="customization"></span><h3>3.3.1. 기본적인 커스터마이제이션<a class="headerlink" href="#basic-customization" title="永久链接至标题">¶</a></h3>
<dl class="method">
<dt id="object.__new__">
<code class="descclassname">object.</code><code class="descname">__new__</code><span class="sig-paren">(</span><em>cls</em><span class="optional">[</span>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__new__" title="永久链接至目标">¶</a></dt>
<dd><p id="index-67">클래스 <em>cls</em> 의 새 인스턴스를 만들기 위해 호출된다. <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 는 스태틱 메서드다 (그렇게 선언하지 않아도 되는 특별한 경우다)인데, 첫 번째 인자로 만들려고 하는 인스턴스의 클래스가 전달된다. 나머지 인자들은 객체 생성자 표현(클래스 호출)에 전달된 것들이다. <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 의 반환 값은 새 객체 인스턴스이어야 한다 (보통 <em>cls</em> 의 인스턴스).</p>
<p>일반적인 구현은 <code class="docutils literal notranslate"><span class="pre">super().__new__(cls[,</span> <span class="pre">...])</span></code> 에 적절한 인자들을 전달하는 방법으로 슈퍼 클래스의 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 를 호출해서 새 인스턴스를 만든 후에, 돌려주기 전에 필요한 수정을 가한다.</p>
<p>만약 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 가 <em>cls</em> 의 인스턴스를 돌려준다면, 새 인스턴스의 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드가 <code class="docutils literal notranslate"><span class="pre">__init__(self[,</span> <span class="pre">...])</span></code> 처럼 호출되는데, <em>self</em> 는 새 인스턴스이고, 나머지 인자들은 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 로 전달된 것들과 같다.</p>
<p>만약 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 가 <em>cls</em> 의 인스턴스를 돌려주지 않으면, 새 인스턴스의 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 는 호출되지 않는다.</p>
<p><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 는 주로 불변형(int, str, tuple과 같은)의 서브 클래스가 인스턴스 생성을 커스터마이즈할 수 있도록 하는 데 사용된다. 또한, 사용자 정의 메타 클래스에서 클래스 생성을 커스터마이즈하기 위해 자주 사용된다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__init__">
<code class="descclassname">object.</code><code class="descname">__init__</code><span class="sig-paren">(</span><em>self</em><span class="optional">[</span>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__init__" title="永久链接至目标">¶</a></dt>
<dd><p id="index-68">(<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 에 의해) 인스턴스가 만들어진 후에, 하지만 호출자에게 돌려주기 전에 호출된다. 인자들은 클래스 생성자 표현으로 전달된 것들이다. 만약 베이스 클래스가 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드를 갖고 있다면, 서브 클래스의 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드는, 있다면, 인스턴스에서 베이스 클래스가 차지하는 부분이 올바르게 초기화됨을 확실히 하기 위해 명시적으로 호출해주어야 한다; 예를 들어: <code class="docutils literal notranslate"><span class="pre">super().__init__([args...])</span></code>.</p>
<p>객체를 만드는데 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 와 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 가 협력하고 있으므로 (<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 는 만들고, <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 는 그것을 커스터마이즈한다), <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이외의 값을 돌려주면 실행시간에 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으킨다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__del__">
<code class="descclassname">object.</code><code class="descname">__del__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__del__" title="永久链接至目标">¶</a></dt>
<dd><p id="index-69">Called when the instance is about to be destroyed.  This is also called a
finalizer or (improperly) a destructor.  If a base class has a
<a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> method, the derived class's <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> method,
if any, must explicitly call it to ensure proper deletion of the base
class part of the instance.</p>
<p>It is possible (though not recommended!) for the <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> method
to postpone destruction of the instance by creating a new reference to
it.  This is called object <em>resurrection</em>.  It is implementation-dependent
whether <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> is called a second time when a resurrected object
is about to be destroyed; the current <a class="reference internal" href="../glossary.html#term-cpython"><span class="xref std std-term">CPython</span></a> implementation
only calls it once.</p>
<p>It is not guaranteed that <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> methods are called for objects
that still exist when the interpreter exits.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x</span></code> doesn't directly call <code class="docutils literal notranslate"><span class="pre">x.__del__()</span></code> --- the former decrements
the reference count for <code class="docutils literal notranslate"><span class="pre">x</span></code> by one, and the latter is only called when
<code class="docutils literal notranslate"><span class="pre">x</span></code>'s reference count reaches zero.</p>
</div>
<div class="impl-detail compound">
<p class="compound-first"><strong>CPython 구현 상세:</strong> It is possible for a reference cycle to prevent the reference count
of an object from going to zero.  In this case, the cycle will be
later detected and deleted by the <a class="reference internal" href="../glossary.html#term-garbage-collection"><span class="xref std std-term">cyclic garbage collector</span></a>.  A common cause of reference cycles is when
an exception has been caught in a local variable.  The frame's
locals then reference the exception, which references its own
traceback, which references the locals of all frames caught in the
traceback.</p>
<div class="compound-last admonition seealso">
<p class="first admonition-title">参见</p>
<p class="last">Documentation for the <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> module.</p>
</div>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>Due to the precarious circumstances under which <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> methods are
invoked, exceptions that occur during their execution are ignored, and a warning
is printed to <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> instead.  In particular:</p>
<ul class="last simple">
<li><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> can be invoked when arbitrary code is being executed,
including from any arbitrary thread.  If <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> needs to take
a lock or invoke any other blocking resource, it may deadlock as
the resource may already be taken by the code that gets interrupted
to execute <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a>.</li>
<li><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> can be executed during interpreter shutdown.  As a
consequence, the global variables it needs to access (including other
modules) may already have been deleted or set to <code class="docutils literal notranslate"><span class="pre">None</span></code>. Python
guarantees that globals whose name begins with a single underscore
are deleted from their module before other globals are deleted; if
no other references to such globals exist, this may help in assuring
that imported modules are still available at the time when the
<a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> method is called.</li>
</ul>
</div>
<span class="target" id="index-70"></span></dd></dl>

<dl class="method">
<dt id="object.__repr__">
<code class="descclassname">object.</code><code class="descname">__repr__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__repr__" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 내장 함수에 의해 호출되어 객체의 &quot;형식적인(official)&quot; 문자열 표현을 계산한다. 만약 가능하다면, 이것은 같은 (적절한 환경이 주어질 때) 값을 갖는 객체를 새로 만들 수 있는 올바른 파이썬 표현식처럼 보여야 한다. 가능하지 않다면, <code class="docutils literal notranslate"><span class="pre">&lt;...쓸모있는</span> <span class="pre">설명...&gt;</span></code> 형태의 문자열을 돌려줘야 한다. 반환 값은 반드시 문자열이어야 한다. 만약 클래스가 <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a> 없이 <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 만 정의한다면, <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 은 그 클래스 인스턴스의 &quot;비형식적인(informal)&quot; 문자열 표현이 요구될 때 사용될 수 있다.</p>
<p>이것은 디버깅에 사용되기 때문에, 표현이 풍부한 정보를 담고 모호하지 않게 하는 것이 중요하다.</p>
<span class="target" id="index-71"></span></dd></dl>

<dl class="method">
<dt id="object.__str__">
<code class="descclassname">object.</code><code class="descname">__str__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__str__" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str(object)</span></code></a> 와 내장 함수 <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a>, <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 에 의해 호출되어 객체의 &quot;비형식적인(informal)&quot; 또는 보기 좋게 인쇄 가능한 문자열 표현을 계산한다. 반환 값은 반드시 <a class="reference internal" href="../library/stdtypes.html#textseq"><span class="std std-ref">문자열</span></a> 객체여야 한다.</p>
<p>이 메서드는 <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a> 이 올바른 파이썬 표현식을 돌려줄 것이라고 기대되지 않는다는 점에서 <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a> 과 다르다: 더 편리하고 간결한 표현이 사용될 수 있다.</p>
<p>내장형 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 에 정의된 기본 구현은 <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a> 을 호출한다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__bytes__">
<code class="descclassname">object.</code><code class="descname">__bytes__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bytes__" title="永久链接至目标">¶</a></dt>
<dd><p id="index-72"><a class="reference internal" href="../library/functions.html#func-bytes"><span class="std std-ref">bytes</span></a> 에 의해 호출되어 객체의 바이트열 표현을 계산한다. 반환 값은 반드시 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체여야 한다.</p>
<span class="target" id="index-73"></span></dd></dl>

<dl class="method">
<dt id="object.__format__">
<code class="descclassname">object.</code><code class="descname">__format__</code><span class="sig-paren">(</span><em>self</em>, <em>format_spec</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__format__" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 내장 함수, 확대하면, <a class="reference internal" href="lexical_analysis.html#f-strings"><span class="std std-ref">포맷 문자열 리터럴(formatted string literals)</span></a> 의 계산과 <a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 메서드에 의해 호출되어, 객체의 &quot;포맷된&quot; 문자열 표현을 만들어낸다. <code class="docutils literal notranslate"><span class="pre">format_spec</span></code> 인자는 요구되는 포맷 옵션들을 포함하는 문자열이다. <code class="docutils literal notranslate"><span class="pre">format_spec</span></code> 인자의 해석은 <a class="reference internal" href="#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a> 을 구현하는 형에 달려있으나, 대부분 클래스는 포매팅을 내향형들의 하나로 위임하거나, 비슷한 포맷 옵션 문법을 사용한다.</p>
<p>표준 포매팅 문법에 대해서는 <a class="reference internal" href="../library/string.html#formatspec"><span class="std std-ref">Format Specification Mini-Language</span></a> 를 참고하면 된다.</p>
<p>반환 값은 반드시 문자열이어야 한다.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.4 版更改: </span><code class="docutils literal notranslate"><span class="pre">object</span></code> 의 __format__ 메서드 자신은, 빈 문자열이 아닌 인자가 전달되면 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 발생시킨다.</p>
</div>
</dd></dl>

<span class="target" id="richcmpfuncs"></span><dl class="method">
<dt id="object.__lt__">
<code class="descclassname">object.</code><code class="descname">__lt__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lt__" title="永久链接至目标">¶</a></dt>
<dt id="object.__le__">
<code class="descclassname">object.</code><code class="descname">__le__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__le__" title="永久链接至目标">¶</a></dt>
<dt id="object.__eq__">
<code class="descclassname">object.</code><code class="descname">__eq__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__eq__" title="永久链接至目标">¶</a></dt>
<dt id="object.__ne__">
<code class="descclassname">object.</code><code class="descname">__ne__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ne__" title="永久链接至目标">¶</a></dt>
<dt id="object.__gt__">
<code class="descclassname">object.</code><code class="descname">__gt__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__gt__" title="永久链接至目标">¶</a></dt>
<dt id="object.__ge__">
<code class="descclassname">object.</code><code class="descname">__ge__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ge__" title="永久链接至目标">¶</a></dt>
<dd><p id="index-74">이것들은 소위 &quot;풍부한 비교(rich comparison)&quot; 메서드다. 연산자 기호와 메서드 이름 간의 관계는 다음과 같다: <code class="docutils literal notranslate"><span class="pre">x&lt;y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__lt__(y)</span></code> 를 호출한다, <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__le__(y)</span></code> 를 호출한다, <code class="docutils literal notranslate"><span class="pre">x==y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__eq__(y)</span></code> 를 호출한다, <code class="docutils literal notranslate"><span class="pre">x!=y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__ne__(y)</span></code> 를 호출한다, <code class="docutils literal notranslate"><span class="pre">x&gt;y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__gt__(y)</span></code> 를 호출한다, <code class="docutils literal notranslate"><span class="pre">x&gt;=y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__ge__(y)</span></code> 를 호출한다.</p>
<p>풍부한 비교 메서드는 주어진 한 쌍의 인자에게 해당 연산을 구현하지 않는 경우 단일자(singleton) <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 를 돌려줄 수 있다. 관례상, 성공적인 비교면 <code class="docutils literal notranslate"><span class="pre">False</span></code> 나 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 돌려준다. 하지만, 이 메서드는 어떤 형의 값이건 돌려줄 수 있다, 그래서 비교 연산자가 논리 문맥(Boolean context) (예를 들어 <code class="docutils literal notranslate"><span class="pre">if</span></code> 문의 조건)에서 사용되면, 파이썬은 결과의 참 거짓을 파악하기 위해 값에 대해 <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a> 을 호출한다.</p>
<p>기본적으로, <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> 는 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 호출한 후 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 가 아니라면 그 결과를 뒤집는다. 비교 연산자 간의 다른 암시적인 관계는 없다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">(x&lt;y</span> <span class="pre">or</span> <span class="pre">x==y)</span></code> 가 참이라고 해서 <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code> 가 참일 필요는 없다. 하나의 기본 연산으로부터 대소관계 연산을 자동으로 만들어내려면 <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.total_ordering()</span></code></a> 를 보면 된다.</p>
<p>사용자 정의 비교 연산자를 지원하고 딕셔너리 키로 사용될 수 있는 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">해시 가능</span></a> 객체를 만드는 것에 관한 몇 가지 중요한 내용이 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 에 관한 문단에 나온다.</p>
<p>이 메서드들에 대한 (왼편의 인자는 연산을 지원하지 않지만, 오른편 인자가 지원할 때 사용되는) 뒤집힌 버전은 따로 없다; 대신에 <a class="reference internal" href="#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> 와 <a class="reference internal" href="#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a> 는 서로의 뒤집힌 연산이다; <a class="reference internal" href="#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a> 와 <a class="reference internal" href="#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a> 는 서로의 뒤집힌 연산이다; <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 와 <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> 는 서로의 뒤집힌 연산이다; 만약 피연산자가 서로 다른 형이고, 오른편 피연산자의 형이 왼편 피연산자의 형의 직간접적인 서브 클래스면, 오른편 피연산자의 뒤집힌 버전이 우선순위가 높다; 그렇지 않으면 왼편 피연산자의 메서드가 우선순위가 높다. 가상 서브클래싱(virtual subclassing)은 고려되지 않는다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__hash__">
<code class="descclassname">object.</code><code class="descname">__hash__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__hash__" title="永久链接至目标">¶</a></dt>
<dd><p id="index-75">내장 함수 <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 와 <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 와 같은 해시형 컬렉션의 멤버에 대한 연산에서 호출된다. <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 는 정수를 돌려줘야 한다. 같다고 비교되는 객체들이 같은 해시값을 가져야 한다는 성질만 요구된다. 객체의 비교에 사용되는 요소들로 튜플을 구성하고, 그 튜플의 해시값을 취함으로써 요소들의 해시값을 섞는 것을 권한다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nick</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 는 객체가 정의한 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드가 돌려주는 값을 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code> 의 크기로 자른다(truncate). 이것은 보통 64-bit 빌드에서는 8바이트고, 32-bit 빌드에서는 4바이트다. 만약 객체의 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 가 서로 다른 비트 크기를 갖는 빌드들 사이에서 함께 사용되어야 한다면, 모든 지원할 빌드들에서의 폭을 검사해야 한다. 이렇게 하는 쉬운 방법은 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-c</span> <span class="pre">&quot;import</span> <span class="pre">sys;</span> <span class="pre">print(sys.hash_info.width)&quot;</span></code> 이다.</p>
</div>
<p>만약 클래스가 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 정의하지 않으면 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 역시 정의하지 말아야 한다. 만약 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 정의하지만 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 를 정의하지 않는다면, 그것의 인스턴스는 해시 가능 컬렉션에서 사용될 수 없다. 만약 클래스가 가변형 객체를 정의하고 있고 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 구현한다면, <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 를 구현하지 말아야 하는데, 해시 가능 컬렉션들의 구현이 키의 해시값이 불변이도록 요구하고 있기 때문이다(만약 객체의 해시값이 변하면, 잘못된 해시 버킷(hash bucket)에 있게 된다).</p>
<p>사용자 정의 클래스는 기본적으로 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 와 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드를 갖는다; 모든 객체는 (자기 자신을 제외하고) 같지 않다고 비교되고, <code class="docutils literal notranslate"><span class="pre">x.__hash__()</span></code> 는 적절한 값을 돌려주어, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> 일 때 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> 와 <code class="docutils literal notranslate"><span class="pre">hash(x)</span> <span class="pre">==</span> <span class="pre">hash(y)</span></code> 가 동시에 성립할 수 있도록 한다.</p>
<p><a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 재정의하고 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 를 정의하지 않는 클래스는 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정된다. 클래스의 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, 클래스의 인스턴스는 프로그램이 해시값을 얻으려 시도할 때 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으키고, <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.Hashable)</span></code> 로 검사할 때 해시 가능하지 않다고 올바로 감지된다.</p>
<p>만약 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 재정의하는 클래스가 부모 클래스로부터 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 의 구현을 물려받고 싶으면 인터프리터에게 명시적으로 이렇게 지정해주어야 한다: <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">&lt;ParentClass&gt;.__hash__</span></code>.</p>
<p>만약 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 재정의하지 않는 클래스가 해시 지원을 멈추고 싶으면, 클래스 정의에 <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> 을 포함해야 한다. 자신의 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 을 정의한 후에 직접 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으키는 경우는 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.Hashable)</span></code> 호출이 해시 가능하다고 잘못 인식한다.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>기본적으로, str, bytes, datetime 객체들의 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 값은 예측할 수 없는 난수값으로 &quot;솔트되어(salted)&quot; 있다. 개별 파이썬 프로세스 내에서는 변하지 않는 값으로 유지되지만, 파이썬을 반복적으로 실행할 때는 예측할 수 없게 된다.</p>
<p>이것은 dict 삽입의 최악의 경우 성능(worst case performance), O(n^2) 복잡도, 을 활용하기 위해 주의 깊게 선택한 입력에 의한 서비스 거부(denial-of-service) 공격에 대한 방어를 제공하기 위한 목적이다. 자세한 내용은 <a class="reference external" href="http://www.ocert.org/advisories/ocert-2011-003.html">http://www.ocert.org/advisories/ocert-2011-003.html</a> 에 있다.</p>
<p>해시값의 변경은 딕셔너리와 집합과 그 밖의 다른 매핑들의 이터레이션 순서에 영향을 준다, 파이썬은 이 순서에 대해 어떤 보장도 하지 않는다 (그리고 보통 32-bit 와 64-bit 빌드 사이에서도 다르다).</p>
<p class="last"><span class="target" id="index-106"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code></a> 를 참고하라.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>해시 난수 화는 기본적으로 활성화된다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__bool__">
<code class="descclassname">object.</code><code class="descname">__bool__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bool__" title="永久链接至目标">¶</a></dt>
<dd><p id="index-77">논리값 검사와 내장 연산 <code class="docutils literal notranslate"><span class="pre">bool()</span></code> 구현을 위해 호출된다; <code class="docutils literal notranslate"><span class="pre">False</span></code> 나 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 돌려줘야 한다. 이 메서드가 정의되지 않는 경우, 정의되어 있다면 <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 이 호출되어, 값이 0 이 아니면 참으로 인식한다. 만약 클래스가 <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 과 <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> 모두 정의하지 않는다면, 모든 인스턴스는 참으로 취급된다.</p>
</dd></dl>

</div>
<div class="section" id="customizing-attribute-access">
<span id="attribute-access"></span><h3>3.3.2. 어트리뷰트 액세스 커스터마이제이션<a class="headerlink" href="#customizing-attribute-access" title="永久链接至标题">¶</a></h3>
<p>클래스 인스턴스의 어트리뷰트 참조(읽기, 대입하기, <code class="docutils literal notranslate"><span class="pre">x.name</span></code> 을 삭제하기)의 의미를 변경하기 위해 다음과 같은 메서드들이 정의될 수 있다.</p>
<dl class="method">
<dt id="object.__getattr__">
<code class="descclassname">object.</code><code class="descname">__getattr__</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattr__" title="永久链接至目标">¶</a></dt>
<dd><p>Called when the default attribute access fails with an <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>
(either <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> raises an <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> because
<em>name</em> is not an instance attribute or an attribute in the class tree
for <code class="docutils literal notranslate"><span class="pre">self</span></code>; or <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> of a <em>name</em> property raises
<a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>).  This method should either return the (computed)
attribute value or raise an <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> exception.</p>
<p>일반적인 메커니즘을 통해 어트리뷰트가 발견되면 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 이 호출되지 않음에 주의해야 한다 (이것은 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 과 <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 간의 의도된 비대칭이다). 이렇게 하는 이유는 효율 때문이기도 하고, 그렇게 하지 않으면 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 가 인스턴스의 다른 어트리뷰트에 접근할 방법이 없기 때문이기도 하다. 적어도 인스턴스 변수의 경우, 어떤 값도 인스턴스 어트리뷰트 딕셔너리에 넣지 않음으로써 (대신에 그것들을 다른 객체에 넣는다) 완전한 제어인 것처럼 조작할 수 있다. 어트리뷰트 액세스를 실제로 완전히 조작하는 방법에 대해서는 아래에 나오는 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 에서 다룬다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__getattribute__">
<code class="descclassname">object.</code><code class="descname">__getattribute__</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattribute__" title="永久链接至目标">¶</a></dt>
<dd><p>클래스 인스턴스의 어트리뷰트 액세스를 구현하기 위해 조건 없이 호출된다. 만약 클래스가 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 도 함께 구현하면, <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 가 명시적으로 호출하거나 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 일으키지 않는 이상 <cite>__getattr__</cite> 는 호출되지 않는다. 이 메서드는 어트리뷰트의 (계산된) 값을 돌려주거나 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 예외를 일으켜야 한다. 이 메서드에서 무한 재귀(infinite recursion)가 발생하는 것을 막기 위해, 구현은 언제나 필요한 어트리뷰트에 접근하기 위해 같은 이름의 베이스 클래스의 메서드를 호출해야 한다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">object.__getattribute__(self,</span> <span class="pre">name)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">언어 문법이나 내장 함수에 의한 묵시적인 호출이 결과로 특수 메서드를 참조하는 경우에는 이 메서드를 거치지 않을 수 있다. 자세한 내용은 <a class="reference internal" href="#special-lookup"><span class="std std-ref">특수 메서드 조회</span></a> 에서 다룬다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__setattr__">
<code class="descclassname">object.</code><code class="descname">__setattr__</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setattr__" title="永久链接至目标">¶</a></dt>
<dd><p>어트리뷰트 대입이 시도될 때 호출된다. 일반적인 메커니즘(즉 인스턴스 딕셔너리에 값을 저장하는 것) 대신에 이것이 호출된다. <em>name</em> 은 어트리뷰트 이름이고, <em>value</em> 는 그것에 대입하려는 값이다.</p>
<p><a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 에서 인스턴스 어트리뷰트에 대입하려고 할 때는, 같은 이름의 베이스 클래스의 메서드를 호출해야 한다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">object.__setattr__(self,</span> <span class="pre">name,</span> <span class="pre">value)</span></code></p>
</dd></dl>

<dl class="method">
<dt id="object.__delattr__">
<code class="descclassname">object.</code><code class="descname">__delattr__</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delattr__" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 과 비슷하지만 어트리뷰트를 대입하는 대신에 삭제한다. 이것은 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">obj.name</span></code> 이 객체에 의미가 있는 경우에만 구현되어야 한다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__dir__">
<code class="descclassname">object.</code><code class="descname">__dir__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__dir__" title="永久链接至目标">¶</a></dt>
<dd><p>객체에 <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 이 호출될 때 호출된다. 시퀀스를 돌려줘야 한다. <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 은 돌려준 시퀀스를 리스트로 변환한 후 정렬한다.</p>
</dd></dl>

<div class="section" id="customizing-module-attribute-access">
<h4>3.3.2.1. Customizing module attribute access<a class="headerlink" href="#customizing-module-attribute-access" title="永久链接至标题">¶</a></h4>
<p id="index-78">For a more fine grained customization of the module behavior (setting
attributes, properties, etc.), one can set the <code class="docutils literal notranslate"><span class="pre">__class__</span></code> attribute of
a module object to a subclass of <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a>. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="k">import</span> <span class="n">ModuleType</span>

<span class="k">class</span> <span class="nc">VerboseModule</span><span class="p">(</span><span class="n">ModuleType</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span><span class="s1">&#39;Verbose </span><span class="si">{self.__name__}</span><span class="s1">&#39;</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Setting </span><span class="si">{attr}</span><span class="s1">...&#39;</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">VerboseModule</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">Setting module <code class="docutils literal notranslate"><span class="pre">__class__</span></code> only affects lookups made using the attribute
access syntax -- directly accessing the module globals (whether by code
within the module, or via a reference to the module's globals dictionary)
is unaffected.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.5 版更改: </span><code class="docutils literal notranslate"><span class="pre">__class__</span></code> module attribute is now writable.</p>
</div>
</div>
<div class="section" id="implementing-descriptors">
<span id="descriptors"></span><h4>3.3.2.2. 디스크립터 구현하기<a class="headerlink" href="#implementing-descriptors" title="永久链接至标题">¶</a></h4>
<p>다음에 오는 메서드들은 메서드를 가진 클래스(소위 <em>디스크립터(descriptor)</em> 클래스)의 인스턴스가 <em>소유자(owner)</em> 클래스에 등장할 때만 적용된다(디스크립터는 소유자 클래스의 딕셔너리나 그 부모 클래스 중 하나의 딕셔너리에 있어야 한다). 아래의 예에서, &quot;어트리뷰트&quot; 는 이름이 소유자 클래스의 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 의 키로 사용되고 있는 어트리뷰트를 가리킨다.</p>
<dl class="method">
<dt id="object.__get__">
<code class="descclassname">object.</code><code class="descname">__get__</code><span class="sig-paren">(</span><em>self</em>, <em>instance</em>, <em>owner</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__get__" title="永久链接至目标">¶</a></dt>
<dd><p>소유자 클래스(클래스 어트리뷰트 액세스) 나 그 클래스의 인스턴스(인스턴스 어트리뷰트 액세스)의 어트리뷰트를 취하려고 할 때 호출된다. <em>owner</em> 는 항상 소유자 클래스다. 반면에 <em>instance</em> 는 어트리뷰트 참조가 일어나고 있는 인스턴스이거나, 어트리뷰트가 <em>owner</em> 를 통해 액세스 되는 경우 <cite>None</cite> 이다. 이 메서드는 (계산된) 어트리뷰트 값을 돌려주거나 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 예외를 일으켜야 한다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__set__">
<code class="descclassname">object.</code><code class="descname">__set__</code><span class="sig-paren">(</span><em>self</em>, <em>instance</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set__" title="永久链接至目标">¶</a></dt>
<dd><p>소유자 클래스의 인스턴스 <em>instance</em> 의 어트리뷰트를 새 값 <em>value</em> 로 설정할 때 호출된다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__delete__">
<code class="descclassname">object.</code><code class="descname">__delete__</code><span class="sig-paren">(</span><em>self</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delete__" title="永久链接至目标">¶</a></dt>
<dd><p>소유자 클래스의 인스턴스 <em>instance</em> 의 어트리뷰트를 삭제할 때 호출된다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__set_name__">
<code class="descclassname">object.</code><code class="descname">__set_name__</code><span class="sig-paren">(</span><em>self</em>, <em>owner</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set_name__" title="永久链接至目标">¶</a></dt>
<dd><p>소유자 클래스 <em>owner</em> 가 만들어질 때 호출된다. 이 디스크립터가 <em>name</em> 에 대입되었다.</p>
<div class="versionadded">
<p><span class="versionmodified">3.6 新版功能.</span></p>
</div>
</dd></dl>

<p>어트리뷰트 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__objclass__</span></code> 는 <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 모듈에 의해 이 객체가 정의된 클래스를 지정하는 것으로 해석된다(이 값을 적절히 설정하면 동적인 클래스 어트리뷰트의 실행시간 인트로스펙션(introspection)을 지원할 수 있다). 콜러블의 경우, 첫 번째 위치 인자에, 주어진 형(또는 서브 클래스)의 인스턴스가 기대되거나 요구됨을 가리킬 수 있다(예를 들어, CPython 은 C로 구현된 연결되지 않은 메서드(unbound method)에 이 어트리뷰트를 설정한다).</p>
</div>
<div class="section" id="invoking-descriptors">
<span id="descriptor-invocation"></span><h4>3.3.2.3. 디스크립터 호출하기<a class="headerlink" href="#invoking-descriptors" title="永久链接至标题">¶</a></h4>
<p>일반적으로, 디스크립터는 &quot;결합한 동작(binding behavior)&quot;을 가진 객체 어트리뷰트다. 어트리뷰트 액세스가 디스크립터 프로토콜(descriptor protocol)의 메서드들에 의해 재정의된다: <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a>, <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>. 이 메서드들 중 하나라도 정의되어 있으면, 디스크립터라고 부른다.</p>
<p>어트리뷰트 액세스의 기본 동작은 객체의 딕셔너리에서 어트리뷰트를 읽고, 쓰고, 삭제하는 것이다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">a.x</span></code> 는 <code class="docutils literal notranslate"><span class="pre">a.__dict__['x']</span></code> 에서 시작해서 <code class="docutils literal notranslate"><span class="pre">type(a).__dict__['x']</span></code> 를 거쳐 <code class="docutils literal notranslate"><span class="pre">type(a)</span></code> 의 메타 클래스를 제외한 베이스 클래스들을 거쳐 가는 일련의 조회로 구성된다.</p>
<p>그러나, 만약 조회한 값이 디스크립터 메서드를 구현한 객체면, 파이썬은 기본 동작 대신에 디스크립터 메서드를 호출할 수 있다. 우선순위 목록의 어느 위치에서 이런 일이 일어나는지는 어떤 디스크립터 메서드가 정의되어 있고 어떤 식으로 호출되는지에 따라 다르다.</p>
<p>디스크립터 호출의 시작점은 결합(binding)이다, <code class="docutils literal notranslate"><span class="pre">a.x</span></code>. 어떻데 인자들이 조합되는지는 <code class="docutils literal notranslate"><span class="pre">a</span></code> 에 따라 다르다:</p>
<dl class="docutils">
<dt>직접 호출</dt>
<dd>가장 간단하면서도 가장 덜 사용되는 호출은 사용자의 코드가 디스크립터 메서드를 직접 호출할 때다: <code class="docutils literal notranslate"><span class="pre">x.__get__(a)</span></code></dd>
<dt>인스턴스 결합</dt>
<dd>객체 인스턴스에 결합하면, <code class="docutils literal notranslate"><span class="pre">a.x</span></code> 는 이런 호출로 변환된다: <code class="docutils literal notranslate"><span class="pre">type(a).__dict__['x'].__get__(a,</span> <span class="pre">type(a))</span></code>.</dd>
<dt>클래스 결합</dt>
<dd>클래스에 결합하면, <code class="docutils literal notranslate"><span class="pre">A.x</span></code> 는 이런 호출로 변환된다: <code class="docutils literal notranslate"><span class="pre">A.__dict__['x'].__get__(None,</span> <span class="pre">A)</span></code>.</dd>
<dt>Super 결합</dt>
<dd><a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-class docutils literal notranslate"><span class="pre">super</span></code></a> 의 인스턴스에 결합하면, 결합 <code class="docutils literal notranslate"><span class="pre">super(B,</span> <span class="pre">obj).m()</span></code> 은 <code class="docutils literal notranslate"><span class="pre">obj.__class__.__mro__</span></code> 를 검색해서 <code class="docutils literal notranslate"><span class="pre">B</span></code> 바로 다음에 나오는 베이스 클래스 <code class="docutils literal notranslate"><span class="pre">A</span></code> 를 찾은 후에 이렇게 디스크립터를 호출한다: <code class="docutils literal notranslate"><span class="pre">A.__dict__['m'].__get__(obj,</span> <span class="pre">obj.__class__)</span></code>.</dd>
</dl>
<p>인스턴스 결합의 경우, 디스크립터 호출의 우선순위는 어떤 디스크립터 메서드가 정의되어있는지에 따라 다르다. 디스크립터는 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a>, <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a> 를 어떤 조합으로도 정의할 수 있다. 만약 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> 를 정의하지 않는다면, 어트리뷰트 액세스는, 객체의 인스턴스 딕셔너리에 값이 있지 않은 이상 디스크립터 객체 자신을 돌려준다. 만약 디스크립터가 <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> 이나 <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a> 중 어느 하나나 둘 다 정의하면, 데이터 디스크립터(data descriptor)다. 둘 다 정의하지 않는다면 비데이터 디스크립터다(non-data descriptor).  보통, 데이터 디스크립터가 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> 과 <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> 을 모두 정의하는 반면, 비데이터 디스크립터는 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> 메서드만 정의한다. <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> 과 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> 이 있는 데이터 디스크립터는 이스턴스 딕셔너리에 있는 값에 우선한다. 반면에 비데이터 디스크립터는 인스턴스보다 우선순위가 낮다.</p>
<p>파이썬 메서드 (<a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a> 와 <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> 를 포함해서) 는 비데이터 디스크립터로 구현된다. 이 때문에, 인스턴스는 메서드를 새로 정의하거나 덮어쓸 수 있다. 이것은 개별 인스턴스가 같은 클래스의 다른 인스턴스들과는 다른 동작을 얻을 수 있도록 만든다.</p>
<p><a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> 함수는 데이터 디스크립터로 구현된다. 이 때문에, 인스턴스는 프로퍼티(property)의 동작을 변경할 수 없다.</p>
</div>
<div class="section" id="slots">
<span id="id3"></span><h4>3.3.2.4. __slots__<a class="headerlink" href="#slots" title="永久链接至标题">¶</a></h4>
<p><em>__slots__</em> allow us to explicitly declare data members (like
properties) and deny the creation of <em>__dict__</em> and <em>__weakref__</em>
(unless explicitly declared in <em>__slots__</em> or available in a parent.)</p>
<p>The space saved over using <em>__dict__</em> can be significant.</p>
<dl class="data">
<dt id="object.__slots__">
<code class="descclassname">object.</code><code class="descname">__slots__</code><a class="headerlink" href="#object.__slots__" title="永久链接至目标">¶</a></dt>
<dd><p>이 클래스 변수에는 인스턴스에 의해 사용되는 변수들의 이름을 제공하는 문자열, 이터러블(iterable), 문자열의 시퀀스가 대입될 수 있다. <em>__slots__</em> 은 선언된 변수들을 위한 공간을 예약하고, 간 인스턴스마다 <em>__dict__</em> 와 <em>__weakref__</em> 가 만들어지는 것을 막는다.</p>
</dd></dl>

<div class="section" id="notes-on-using-slots">
<h5>3.3.2.4.1. <em>__slots__</em> 사용에 관한 노트<a class="headerlink" href="#notes-on-using-slots" title="永久链接至标题">¶</a></h5>
<ul class="simple">
<li>When inheriting from a class without <em>__slots__</em>, the <em>__dict__</em> and
<em>__weakref__</em> attribute of the instances will always be accessible.</li>
<li><em>__dict__</em> 변수가 없으므로 인스턴스는 <em>__slots__</em> 정의에 나열되지 않은 새 변수를 대입할 수 없다. 나열되지 않은 변수명으로 대입하려고 하면 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 일으킨다. 만약 동적으로 새 변수를 대입하는 것이 필요하다면, <em>__slots__</em> 선언의 문자열 시퀀스에 <code class="docutils literal notranslate"><span class="pre">'__dict__'</span></code> 를 추가한다.</li>
<li>인스턴스마다 <em>__weakref__</em> 변수가 없으므로, <em>__slots__</em> 를 정의하는 클래스는 인스턴스에 대한 약한 참조(weak reference)를 지원하지 않는다. 만약 약한 참조 지원이 필요하다면, <em>__slots__</em> 선언의 문자열 시퀀스에 <code class="docutils literal notranslate"><span class="pre">'__weakref__'</span></code> 를 추가한다.</li>
<li><em>__slots__</em> 는 각 변수 이름마다 디스크립터를 만드는 방식으로 클래스 수준에서 구현된다(<a class="reference internal" href="#descriptors"><span class="std std-ref">디스크립터 구현하기</span></a>). 결과적으로, 클래스 어트리뷰트는 <em>__slots__</em> 로 정의된 인스턴스 변수들을 위한 기본값을 제공할 목적으로 사용될 수 없다. 클래스 어트리뷰트는 디스크립터 대입을 무효로 한다.</li>
<li>The action of a <em>__slots__</em> declaration is not limited to the class
where it is defined.  <em>__slots__</em> declared in parents are available in
child classes. However, child subclasses will get a <em>__dict__</em>  and
<em>__weakref__</em> unless they also define <em>__slots__</em> (which should only
contain names of any <em>additional</em> slots).</li>
<li>클래스가 베이스 클래스의 <em>__slots__</em> 에 정의된 이름과 같은 이름의 변수를 <em>__slots__</em> 에 선언한다면, 베이스 클래스가 정의한 변수는 액세스할 수 없는 상태가 된다(베이스 클래스로부터 디스크립터를 직접 조회하는 경우는 예외다). 이것은 프로그램을 정의되지 않은 상태로 보내게 된다. 미래에는, 이를 방지하기 위한 검사가 추가될 것이다.</li>
<li><a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 과 같은 &quot;가변 길이(valiable-length)&quot; 의 내장형들을 계승하는 클래스에서는 오직 빈 <em>__slots__</em> 만 지원된다.</li>
<li><em>__slots__</em> 에는 문자열 이외의 이터러블을 대입할 수 있다. 매핑도 역시 사용할 수 있다. 하지만, 미래에, 각 키에 대응하는 값들의 의미가 부여될 수 있다.</li>
<li>두 클래스가 같은 <em>__slots__</em> 을 갖는 경우만 <em>__class__</em> 대입이 동작한다.</li>
<li>Multiple inheritance with multiple slotted parent classes can be used,
but only one parent is allowed to have attributes created by slots
(the other bases must have empty slot layouts) - violations raise
<a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="customizing-class-creation">
<span id="class-customization"></span><h3>3.3.3. 클래스 생성 커스터마이제이션<a class="headerlink" href="#customizing-class-creation" title="永久链接至标题">¶</a></h3>
<p>클래스가 다른 클래스를 상속할 때, 그 클래스의 <em>__init_subclass__</em> 가 호출된다. 이 방법으로, 서브 클래스의 동작을 변경하는 클래스를 쓰는 것이 가능하다. 이런 용도는 클래스 데코레이터와도 밀접히 관련되어 있다. 하지만 클래스 데코레이터는 그들을 사용하는 특정한 클래스에만 작용하지만, <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> 단독으로 그 메서드를 정의하는 클래스의 미래 서브 클래스 모두에게 작용한다.</p>
<dl class="classmethod">
<dt id="object.__init_subclass__">
<em class="property">classmethod </em><code class="descclassname">object.</code><code class="descname">__init_subclass__</code><span class="sig-paren">(</span><em>cls</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__init_subclass__" title="永久链接至目标">¶</a></dt>
<dd><p>이 메서드는 포함하는 클래스의 서브 클래스가 만들어질 때마다 호출된다. <em>cls</em> 는 새 서브 클래스다. 만약 일반적인 인스턴스 메서드로 정의되면, 이 메서드는 묵시적으로 클래스 메서드로 변경된다.</p>
<p>새 클래스에 주어진 키워드 인자들은 부모 클래스의 <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> 로 전달된다. <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> 를 사용하는 다른 클래스들과의 호환성을 위해, 필요한 키워드 인자들을 꺼낸 후에 다른 것들을 베이스 클래스로 전달해야 한다. 이런 식이다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Philosopher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">default_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">default_name</span> <span class="o">=</span> <span class="n">default_name</span>

<span class="k">class</span> <span class="nc">AustralianPhilosopher</span><span class="p">(</span><span class="n">Philosopher</span><span class="p">,</span> <span class="n">default_name</span><span class="o">=</span><span class="s2">&quot;Bruce&quot;</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>기본 구현 <code class="docutils literal notranslate"><span class="pre">object.__init_subclass__</span></code> 는 아무 일도 하지 않지만, 인자가 포함되어 호출되면 예외를 발생시킨다.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">메타 클래스 힌트 <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> 는 나머지 형 절차에 의해 소비되고, <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> 로 전달되지 않는다. 실제 메타 클래스 (명시적인 힌트 대신에) 는 <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code> 로 액세스할 수 있다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">3.6 新版功能.</span></p>
</div>
</dd></dl>

<div class="section" id="metaclasses">
<span id="id4"></span><h4>3.3.3.1. 메타 클래스<a class="headerlink" href="#metaclasses" title="永久链接至标题">¶</a></h4>
<p id="index-79">기본적으로, 클래스는 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 을 사용해서 만들어진다. 클래스의 바디는 새 이름 공간에서 실행되고, 클래스 이름은 <code class="docutils literal notranslate"><span class="pre">type(name,</span> <span class="pre">bases,</span> <span class="pre">namespace)</span></code> 의 결과에 지역적으로 연결된다.</p>
<p>클래스를 만드는 과정은 클래스 정의 줄에 <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> 키워드 인자를 전달하거나, 그런 인자를 포함한 이미 존재하는 클래스를 계승함으로써 커스터마이즈될 수 있다. 다음 예에서, <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> 와 <code class="docutils literal notranslate"><span class="pre">MySubclass</span></code> 는 모두 <code class="docutils literal notranslate"><span class="pre">Meta</span></code> 의 인스턴스다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MySubclass</span><span class="p">(</span><span class="n">MyClass</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>클래스 정의에서 지정된 다른 키워드 인자들은 아래에서 설명되는 모든 메타 클래스 연산들로 전달된다.</p>
<p>클래스 정의가 실행될 때, 다음과 같은 단계가 수행된다.:</p>
<ul class="simple">
<li>적절한 메타 클래스가 결정된다</li>
<li>클래스 이름 공간이 준비된다</li>
<li>클래스 바디가 실행된다</li>
<li>클래스 객체가 만들어진다</li>
</ul>
</div>
<div class="section" id="determining-the-appropriate-metaclass">
<h4>3.3.3.2. 적절한 메타 클래스 선택하기<a class="headerlink" href="#determining-the-appropriate-metaclass" title="永久链接至标题">¶</a></h4>
<p id="index-80">클래스 정의의 적절한 메타 클래스는 다음과 같이 결정된다:</p>
<ul class="simple">
<li>베이스와 명시적인 메타 클래스를 주지 않는 경우 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 이 사용된다</li>
<li>명시적인 메타 클래스가 지정되고, 그것이 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 의 인스턴스가 <em>아니면</em>, 그것을 메타 클래스로 사용한다</li>
<li><a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 의 인스턴스가 명시적인 메타 클래스로 주어지거나, 베이스가 정의되었으면, 가장 많이 파생된 메타 클래스가 사용된다</li>
</ul>
<p>가장 많이 파생된 메타 클래스는 명시적으로 지정된 메타 클래스(있다면)와 지정된 모든 베이스 클래스들의 메타 클래스들(즉, <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code>) 중에서 선택된다. 가장 많이 파생된 메타 클래스는 이들 <em>모두</em> 의 서브 타입(subtype)이다. 만약 어느 것도 이 조건을 만족하지 못한다면, 클래스 정의는 <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> 를 발생시키며 실패한다.</p>
</div>
<div class="section" id="preparing-the-class-namespace">
<span id="prepare"></span><h4>3.3.3.3. 클래스 이름 공간 준비하기<a class="headerlink" href="#preparing-the-class-namespace" title="永久链接至标题">¶</a></h4>
<p id="index-81">일단 적절한 메타 클래스가 식별되면, 클래스 이름 공간이 준비된다. 만약 메타 클래스가 <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> 어트리뷰트를 가지면, <code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">=</span> <span class="pre">metaclass.__prepare__(name,</span> <span class="pre">bases,</span> <span class="pre">**kwds)</span></code> 같은 식으로 호출된다(추가적인 키워드 인자가 있다면 클래스 정의에서 온 것이다).</p>
<p>만약 메타 클래스에 <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> 어트리뷰트가 없다면, 클래스 이름 공간은 빈 순서 있는 매핑(ordered mapping) 으로 초기화된다.</p>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<dl class="last docutils">
<dt><span class="target" id="index-107"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3115"><strong>PEP 3115</strong></a> - 파이썬 3000 에서의 메타 클래스</dt>
<dd><code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> 이름 공간 훅을 도입했다</dd>
</dl>
</div>
</div>
<div class="section" id="executing-the-class-body">
<h4>3.3.3.4. 클래스 바디 실행하기<a class="headerlink" href="#executing-the-class-body" title="永久链接至标题">¶</a></h4>
<p id="index-83">클래스 바디는 (대략) <code class="docutils literal notranslate"><span class="pre">exec(body,</span> <span class="pre">globals(),</span> <span class="pre">namespace)</span></code> 과같이 실행된다. 일반적인 <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 호출과 주된 차이점은 클래스 정의가 함수 내부에서 이루어질 때 구문 스코핑(lexical scoping) 이 클래스 바디(모든 메서드들을 포함해서)로 하여금 현재와 외부 스코프에 있는 이름들을 참조하도록 허락한다는 것이다.</p>
<p>하지만, 클래스 정의가 함수 내부에서 이루어질 때조차도, 클래스 내부에서 정의된 메서드들은 클래스 스코프에서 정의된 이름들을 볼 수 없다. 클래스 변수는 인스턴스나 클래스 메서드의 첫 번째 파라미터를 통해 액세스하거나 다음 섹션에서 설명하는 묵시적으로 구문 스코핑된 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 참조를 통해야 한다.</p>
</div>
<div class="section" id="creating-the-class-object">
<span id="class-object-creation"></span><h4>3.3.3.5. 클래스 객체 만들기<a class="headerlink" href="#creating-the-class-object" title="永久链接至标题">¶</a></h4>
<p id="index-84">일단 클래스 이름 공간이 클래스 바디를 실행함으로써 채워지면, 클래스 객체가 <code class="docutils literal notranslate"><span class="pre">metaclass(name,</span> <span class="pre">bases,</span> <span class="pre">namespace,</span> <span class="pre">**kwds)</span></code> 을 통해 만들어진다(여기에서 전달되는 추가적인 키워드 인자들은 <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> 에 전달된 것들과 같다).</p>
<p>이 클래스 객체는 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 에 인자를 주지 않는 경우 참조되는 것이다. <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 는 클래스 바디의 메서드들 중 어느 하나라도 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 나 <code class="docutils literal notranslate"><span class="pre">super</span></code> 를 참조할 경우 컴파일러에 의해 만들어지는 묵시적인 클로저(closure) 참조다. 이것은 인자 없는 형태의 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 가 구문 스코핑 기반으로 현재 정의되고 있는 클래스를 올바르게 찾을 수 있도록 한다. 반면에 현재의 호출에 사용된 클래스나 인스턴스는 메서드로 전달된 첫 번째 인자에 기초해서 식별된다.</p>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> CPython 3.6 이상에서, <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 셀(cell)은 클래스 이름 공간의 <code class="docutils literal notranslate"><span class="pre">__classcell__</span></code> 엔트리로 메타 클래스에 전달된다. 만약 존재한다면, 이것은 클래스가 올바르게 초기화되기 위해 <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> 호출까지 거슬러서 전파되어야 한다. 이렇게 하지 못하면 파이썬 3.6 에서는 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> 이 발생하고, 미래에는 <a class="reference internal" href="../library/exceptions.html#RuntimeWarning" title="RuntimeWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeWarning</span></code></a> 이 될 것이다.</p>
</div>
<p>기본 메타 클래스 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 을 사용할 때나 다른 메타 클래스가 결국 <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> 를 호출할 때, 클래스 객체를 만든 후에, 다음과 같은 추가의 커스터마이제이션 단계가 실행된다:</p>
<ul class="simple">
<li>첫째로, <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> 는 <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> 을 정의하는 클래스 이름 공간의 모든 디스크립터들을 수집한다;</li>
<li>둘째로, 이렇게 수집된 모든 <code class="docutils literal notranslate"><span class="pre">__set_name__</span></code> 을 호출하는데, 정의되고 있는 클래스와 디스크립터에 주어진 이름을 인자로 전달한다; 그리고</li>
<li>마지막으로, 메서드 결정 순서에 따라 가장 가까운 부모에 대해 <a class="reference internal" href="#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> 훅 이 호출된다.</li>
</ul>
<p>클래스 객체가 만들어진 후에, 클래스 정의에 포함된 클래스 데코레이터들에게 (있다면) 클래스를 전달하고, 그 결과를 클래스가 정의되는 지역 이름 공간에 연결한다.</p>
<p><code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> 로 새 클래스가 만들어질 때, 이름 공간 파라미터로 제공되는 객체는 새로 만든 순서 있는 매핑으로 복사되고, 원래의 객체는 버린다. 새 사본은 읽기 전용 프락시(read-only proxy)로 둘러싸이는데, 이것이 클래스 객체의 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 어트리뷰트가 된다.</p>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<dl class="last docutils">
<dt><span class="target" id="index-108"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3135"><strong>PEP 3135</strong></a> - 새 super</dt>
<dd>묵시적인 __class__ 클로저 참조를 설명한다</dd>
</dl>
</div>
</div>
<div class="section" id="metaclass-example">
<h4>3.3.3.6. 메타 클래스 예제<a class="headerlink" href="#metaclass-example" title="永久链接至标题">¶</a></h4>
<p>메타 클래스의 잠재적인 용도에는 한계가 없다. 탐색 된 몇 가지 아이디어들에는 enum, 로깅, 인터페이스 검사, 자동화된 위임(automatic delegation), 자동화된 프로퍼티(properety) 생성, 프락시(proxy), 프레임웍(framework), 자동화된 자원 로킹/동기화(automatic resource locking/synchronization) 등이 있다.</p>
<p>여기, 클래스 변수가 정의된 순서를 기억하기 위해 <a class="reference internal" href="../library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> 를 사용하는 메타 클래스의 예가 있다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">OrderedClass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__prepare__</span><span class="p">(</span><span class="n">metacls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">namespace</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">members</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">namespace</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">OrderedClass</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">pass</span>
    <span class="k">def</span> <span class="nf">two</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">pass</span>
    <span class="k">def</span> <span class="nf">three</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">pass</span>
    <span class="k">def</span> <span class="nf">four</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">pass</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="o">.</span><span class="n">members</span>
<span class="p">(</span><span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">,</span> <span class="s1">&#39;four&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><em>A</em> 의 클래스 정의가 실행될 때, 프로세스는 메타 클래스의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__prepare__()</span></code> 를 호출하는 것으로 시작하는데, 빈 <a class="reference internal" href="../library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> 를 돌려준다. 이 매핑은 <em>A</em> 의 메서드와 어트리뷰트들을 클래스 문의 바디에 정의된 데로 기록한다. 일단 그 정의들이 실행되면, 순서 있는 딕셔너리는 모두 채워지고, 메타 클래스의 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 메서드가 호출된다. 이 메서드가 새 형을 만들고, 순서 있는 딕셔너리의 키들은 <code class="docutils literal notranslate"><span class="pre">members</span></code> 라 불리는 어트리뷰트에 저장된다.</p>
</div>
</div>
<div class="section" id="customizing-instance-and-subclass-checks">
<h3>3.3.4. 인스턴스 및 서브 클래스 검사 커스터마이제이션<a class="headerlink" href="#customizing-instance-and-subclass-checks" title="永久链接至标题">¶</a></h3>
<p>다음 메서드들은 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 와 <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 내장 함수들의 기본 동작을 재정의하는 데 사용된다.</p>
<p>특히, 메타 클래스 <a class="reference internal" href="../library/abc.html#abc.ABCMeta" title="abc.ABCMeta"><code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABCMeta</span></code></a> 는 추상 베이스 클래스(Abstract Base Class, ABC)를 다른 ABC를 포함한 임의의 클래스나 형(내장형을 포함한다)에 &quot;가상 베이스 클래스(virtual base class)&quot;로 추가할 수 있게 하려고 이 메서드들을 구현한다.</p>
<dl class="method">
<dt id="class.__instancecheck__">
<code class="descclassname">class.</code><code class="descname">__instancecheck__</code><span class="sig-paren">(</span><em>self</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#class.__instancecheck__" title="永久链接至目标">¶</a></dt>
<dd><p><em>instance</em> 가 (직접적이거나 간접적으로) <em>class</em> 의 인스턴스로 취급될 수 있으면 참을 돌려준다. 만약 정의되면, <code class="docutils literal notranslate"><span class="pre">isinstance(instance,</span> <span class="pre">class)</span></code> 를 구현하기 위해 호출된다.</p>
</dd></dl>

<dl class="method">
<dt id="class.__subclasscheck__">
<code class="descclassname">class.</code><code class="descname">__subclasscheck__</code><span class="sig-paren">(</span><em>self</em>, <em>subclass</em><span class="sig-paren">)</span><a class="headerlink" href="#class.__subclasscheck__" title="永久链接至目标">¶</a></dt>
<dd><p><em>subclass</em> 가 (직접적이거나 간접적으로) <em>class</em> 의 서브 클래스로 취급될 수 있으면 참을 돌려준다. 만약 정의되면, <code class="docutils literal notranslate"><span class="pre">issubclass(subclass,</span> <span class="pre">class)</span></code> 를 구현하기 위해 호출된다.</p>
</dd></dl>

<p>이 메서드들은 클래스의 형(메타 클래스)에서 조회된다는 것에 주의해야 한다. 실제 클래스에서 클래스 메서드로 정의될 수 없다. 이것은 인스턴스에 대해 호출되는 특수 메서드들의 조회와 일관성 있다. 이 경우 인스턴스는 클래스 자체다.</p>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<dl class="last docutils">
<dt><span class="target" id="index-109"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3119"><strong>PEP 3119</strong></a> - 추상 베이스 클래스의 도입</dt>
<dd><a class="reference internal" href="#class.__instancecheck__" title="class.__instancecheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__instancecheck__()</span></code></a> 와 <a class="reference internal" href="#class.__subclasscheck__" title="class.__subclasscheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__subclasscheck__()</span></code></a> 를 통해 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 와 <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 의 동작을 커스터마이징하는 데 필요한 규약을 포함하는데, 이 기능의 동기는 언어에 추상 베이스 클래스 (<a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to PEP 3119."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> 모듈을 보라)를 추가하고자 하는 데 있다.</dd>
</dl>
</div>
</div>
<div class="section" id="emulating-callable-objects">
<span id="callable-types"></span><h3>3.3.5. 콜러블 객체 흉내 내기<a class="headerlink" href="#emulating-callable-objects" title="永久链接至标题">¶</a></h3>
<dl class="method">
<dt id="object.__call__">
<code class="descclassname">object.</code><code class="descname">__call__</code><span class="sig-paren">(</span><em>self</em><span class="optional">[</span>, <em>args...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__call__" title="永久链接至目标">¶</a></dt>
<dd><p id="index-87">인스턴스가 함수처럼 &quot;호출될&quot; 때 호출된다; 이 메서드가 정의되면, <code class="docutils literal notranslate"><span class="pre">x(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__call__(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> 의 줄인 표현이다.</p>
</dd></dl>

</div>
<div class="section" id="emulating-container-types">
<span id="sequence-types"></span><h3>3.3.6. 컨테이너형 흉내 내기<a class="headerlink" href="#emulating-container-types" title="永久链接至标题">¶</a></h3>
<p>컨테이너 객체를 구현하기 위해 다음과 같은 메서드들을 정의할 수 있다. 컨테이너는 보통 시퀀스(리스트와 튜플 같은)나 매핑(딕셔너리 같은)이지만, 다른 컨테이너들 역시 표현할 수 있다. 첫 번째 메서드 집합은 시퀀스나 매핑을 흉내 내는 데 사용된다; 차이점은, 시퀀스의 경우 허락되는 키는 <em>N</em> 이 시퀀스의 길이일 때 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">N</span></code> 를 만족하는 정수 <em>k</em> 와 항목들의 범위를 정의하는 슬라이스 객체만 허락된다는 것이다. 파이썬의 표준 딕셔너리 객체와 비슷하게 동작하도록, 매핑에 메서드 <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">setdefault()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> 를 제공하는 것이 좋다. <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 모듈은 <a class="reference internal" href="../library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></a> 추상 베이스 클래스를 제공하는데, 기본 집합 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>, <a class="reference internal" href="#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code> 로 부터 이들 메서드들을 만드는 데 도움을 준다. 파이썬의 표준 리스트 객체처럼, 가변 시퀀스는 메서드 <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">extend()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code> 를 제공해야 한다. 마지막으로 시퀀스 형은 아래에서 설명하는 메서드 <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>, <a class="reference internal" href="#object.__radd__" title="object.__radd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__radd__()</span></code></a>, <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a>, <a class="reference internal" href="#object.__mul__" title="object.__mul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mul__()</span></code></a>, <a class="reference internal" href="#object.__rmul__" title="object.__rmul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rmul__()</span></code></a>, <a class="reference internal" href="#object.__imul__" title="object.__imul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__imul__()</span></code></a> 를 정의해서 더하기(이어붙이기를 뜻한다)와 곱하기(반복을 뜻한다)를 구현해야 한다. 다른 숫자 연산자들은 정의하지 말아야 한다. <code class="docutils literal notranslate"><span class="pre">in</span></code> 연산자의 효과적인 사용을 허락하기 위해, 매핑과 시퀀스 모두 <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> 메서드를 구현하도록 권장한다. 매핑의 경우, <code class="docutils literal notranslate"><span class="pre">in</span></code> 은 매핑의 키를 검색해야 한다; 시퀀스의 경우, 값들을 검색해야 한다. 컨테이너의 효율적인 이터레이션을 허락하기 위해, 매핑과 시퀀스 모두 <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 메서드를 구현하는 것 또한 권장한다; 매핑의 경우, <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code> 와 같아야 한다; 시퀀스의 경우, 값들을 이터레이트해야 한다.</p>
<dl class="method">
<dt id="object.__len__">
<code class="descclassname">object.</code><code class="descname">__len__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__len__" title="永久链接至目标">¶</a></dt>
<dd><p id="index-88">내장함수 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 를 구현하기 위해 호출된다. 객체의 길이를 돌려줘야 하는데, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0인 정수다. 또한 <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> 메서드를 정의하지 않은 객체의 <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 이 0을 돌려주면 논리 문맥에서 거짓으로 취급된다.</p>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> CPython 에서, 길이는 최대 <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a> 일 것이 요구된다. 만약 길이가 <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.maxsize</span></code> 보다 크면, 어떤 기능들 (<a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 과 같은)은 <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> 를 일으킬 수 있다. 참 거짓 검사에서 <code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code> 가 일어나는 것을 막기 위해, 객체는 <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> 를 정의해야 한다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__length_hint__">
<code class="descclassname">object.</code><code class="descname">__length_hint__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__length_hint__" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="../library/operator.html#operator.length_hint" title="operator.length_hint"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.length_hint()</span></code></a> 를 구현하기 위해 호출된다. 객체의 추정된 길이를 돌려줘야 한다(실제 길이보다 크거나 작을 수 있다). 길이는 <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0인 정수여야 한다. 이 메서드는 순수하게 최적화를 위한 것이고 결코 올바름이 요구되지는 않는다.</p>
<div class="versionadded">
<p><span class="versionmodified">3.4 新版功能.</span></p>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>슬라이싱은 전적으로 다음에 나오는 세 메서드들에의해 수행된다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p>과 같은 호출은</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p class="last">로 번역되고, 다른 형태도 마찬가지다. 빠진 슬라이스 항목은 항상 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 채워진다.</p>
</div>
<dl class="method">
<dt id="object.__getitem__">
<code class="descclassname">object.</code><code class="descname">__getitem__</code><span class="sig-paren">(</span><em>self</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getitem__" title="永久链接至目标">¶</a></dt>
<dd><p id="index-89"><code class="docutils literal notranslate"><span class="pre">self[key]</span></code> 의 값을 구하기 위해 호출된다. 시퀀스형의 경우, 정수와 슬라이스 객체만 키로 허용된다. 음수 인덱스(만약 클래스가 시퀀스 형을 흉내 내길 원한다면)의 특별한 해석은 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 메서드에 달려있음에 주의해야 한다. 만약 <em>key</em> 가 적절하지 않은 형인 경우, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 가 발생할 수 있다; 만약 시퀀스의 인덱스 범위를 벗어나면(음수에 대한 특별한 해석 후에), <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 를 일으켜야 한다. 매핑 형의 경우, <em>key</em> 가 (컨테이너에) 없으면, <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> 를 일으켜야 한다.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 루프는 시퀀스의 끝을 올바로 감지하기 위해, 잘못된 인덱스에 대해 <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 가 일어날 것으로 기대하고 있다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__missing__">
<code class="descclassname">object.</code><code class="descname">__missing__</code><span class="sig-paren">(</span><em>self</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__missing__" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 이 dict 서브 클래스에서 키가 딕셔너리에 없으면 <code class="docutils literal notranslate"><span class="pre">self[key]</span></code> 를 구현하기 위해 호출한다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__setitem__">
<code class="descclassname">object.</code><code class="descname">__setitem__</code><span class="sig-paren">(</span><em>self</em>, <em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setitem__" title="永久链接至目标">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self[key]</span></code> 로의 대입을 구현하기 위해 호출된다. <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 과 같은 주의가 필요하다. 매핑의 경우에는, 객체가 키에 대해 값의 변경이나 새 키의 추가를 허락할 경우, 시퀀스의 경우는 항목이 교체될 수 있을 때만 구현되어야 한다. 잘못된 <em>key</em> 값의 경우는 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 에서와 같은 예외를 일으켜야 한다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__delitem__">
<code class="descclassname">object.</code><code class="descname">__delitem__</code><span class="sig-paren">(</span><em>self</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delitem__" title="永久链接至目标">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self[key]</span></code> 의 삭제를 구현하기 위해 호출된다. <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 과 같은 주의가 필요하다. 매핑의 경우에는, 객체가 키의 삭제를 허락할 경우, 시퀀스의 경우는 항목이 시퀀스로부터 제거될 수 있을 때만 구현되어야 한다. 잘못된 <em>key</em> 값의 경우는 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 에서와 같은 예외를 일으켜야 한다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__iter__">
<code class="descclassname">object.</code><code class="descname">__iter__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iter__" title="永久链接至目标">¶</a></dt>
<dd><p>컨테이너의 이터레이터가 필요할 때 이 메서드가 호출된다. 이 메서드는 컨테이너에 포함된 모든 객체를 이터레이트할 수 있는 이터레이터 객체를 돌려줘야 한다. 매핑의 경우, 컨테이너의 키를 이터레이트해야 한다.</p>
<p>이터레이터 객체 역시 이 메서드를 구현할 필요가 있다; 자기 자신을 돌려줘야 한다. 이터레이터 객체에 대한 추가의 정보는 <a class="reference internal" href="../library/stdtypes.html#typeiter"><span class="std std-ref">Iterator Types</span></a> 에 있다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__reversed__">
<code class="descclassname">object.</code><code class="descname">__reversed__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__reversed__" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 내장 함수가 역 이터레이션(reverse iteration)을 구현하기 위해 (있다면) 호출한다. 컨테이너에 있는 객체들을 역 순으로 탐색하는 새 이터레이터 객체를 돌려줘야 한다.</p>
<p><a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> 메서드가 제공되지 않으면, <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 내장함수는 시퀀스 프로토콜(<a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 과 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>)을 대안으로 사용한다. 시퀀스 프로토콜을 지원하는 객체들은 <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 가 제공하는 것보다 더 효율적인 구현을 제공할 수 있을 때만 <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> 를 제공해야 한다.</p>
</dd></dl>

<p>멤버십 검사 연산자들(<a class="reference internal" href="expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 과 <a class="reference internal" href="expressions.html#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>) 은 보통 시퀀스에 대한 이터레이션으로 구현된다. 하지만, 컨테이너 객체는 더 효율적인 구현을 다음과 같은 특수 메서드를 통해 제공할 수 있다. 이 경우 객체는 시퀀스일 필요도 없다.</p>
<dl class="method">
<dt id="object.__contains__">
<code class="descclassname">object.</code><code class="descname">__contains__</code><span class="sig-paren">(</span><em>self</em>, <em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__contains__" title="永久链接至目标">¶</a></dt>
<dd><p>멤버십 검사 연산자를 구현하기 위해 호출된다. <em>item</em> 이 <em>self</em> 에 있으면 참을, 그렇지 않으면 거짓을 돌려줘야 한다. 매핑 객체의 경우, 키-값 쌍이 아니라 매핑의 키가 고려되어야 한다.</p>
<p><a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> 를 정의하지 않는 객체의 경우, 멤버십 검사는 먼저 <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 를 통한 이터레이션을 시도한 후, <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 을 통한 낡은 시퀀스 이터레이션 프로토콜을 시도한다. <a class="reference internal" href="expressions.html#membership-test-details"><span class="std std-ref">membership-test-details</span></a> 섹션을 참고하라.</p>
</dd></dl>

</div>
<div class="section" id="emulating-numeric-types">
<span id="numeric-types"></span><h3>3.3.7. 숫자 형 흉내 내기<a class="headerlink" href="#emulating-numeric-types" title="永久链接至标题">¶</a></h3>
<p>숫자 형을 흉내 내기 위해 다음과 같은 메서드들을 정의할 수 있다. 구현되는 특별한 종류의 숫자에 의해 지원되지 않는 연산들(예를 들어, 정수가 아닌 숫자들에 대한 비트 연산들)에 대응하는 메서드들을 정의되지 않은 채로 남겨두어야 한다.</p>
<dl class="method">
<dt id="object.__add__">
<code class="descclassname">object.</code><code class="descname">__add__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__add__" title="永久链接至目标">¶</a></dt>
<dt id="object.__sub__">
<code class="descclassname">object.</code><code class="descname">__sub__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__sub__" title="永久链接至目标">¶</a></dt>
<dt id="object.__mul__">
<code class="descclassname">object.</code><code class="descname">__mul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mul__" title="永久链接至目标">¶</a></dt>
<dt id="object.__matmul__">
<code class="descclassname">object.</code><code class="descname">__matmul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__matmul__" title="永久链接至目标">¶</a></dt>
<dt id="object.__truediv__">
<code class="descclassname">object.</code><code class="descname">__truediv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__truediv__" title="永久链接至目标">¶</a></dt>
<dt id="object.__floordiv__">
<code class="descclassname">object.</code><code class="descname">__floordiv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floordiv__" title="永久链接至目标">¶</a></dt>
<dt id="object.__mod__">
<code class="descclassname">object.</code><code class="descname">__mod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mod__" title="永久链接至目标">¶</a></dt>
<dt id="object.__divmod__">
<code class="descclassname">object.</code><code class="descname">__divmod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__divmod__" title="永久链接至目标">¶</a></dt>
<dt id="object.__pow__">
<code class="descclassname">object.</code><code class="descname">__pow__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="optional">[</span>, <em>modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__pow__" title="永久链接至目标">¶</a></dt>
<dt id="object.__lshift__">
<code class="descclassname">object.</code><code class="descname">__lshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lshift__" title="永久链接至目标">¶</a></dt>
<dt id="object.__rshift__">
<code class="descclassname">object.</code><code class="descname">__rshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rshift__" title="永久链接至目标">¶</a></dt>
<dt id="object.__and__">
<code class="descclassname">object.</code><code class="descname">__and__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__and__" title="永久链接至目标">¶</a></dt>
<dt id="object.__xor__">
<code class="descclassname">object.</code><code class="descname">__xor__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__xor__" title="永久链接至目标">¶</a></dt>
<dt id="object.__or__">
<code class="descclassname">object.</code><code class="descname">__or__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__or__" title="永久链接至目标">¶</a></dt>
<dd><p id="index-90">이 메서드들은 이항 산술 연산들(<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>)을 구현하기 위해 호출된다. 예를 들어, <em>x</em> 가 <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a> 메서드를 가진 클래스의 인스턴스일 때, 표현식 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> 의 값을 구하기 위해, <code class="docutils literal notranslate"><span class="pre">x.__add__(y)</span></code> 가 호출된다. <a class="reference internal" href="#object.__divmod__" title="object.__divmod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__divmod__()</span></code></a> 메서드는 <a class="reference internal" href="#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code></a> 와 <a class="reference internal" href="#object.__mod__" title="object.__mod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mod__()</span></code></a> 를 사용하는 것과 동등해야 한다; <a class="reference internal" href="#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code></a> 와 연관되지 않아야 한다; 내장 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> 함수의 삼 항 버전이 지원되기 위해서는, <a class="reference internal" href="#object.__pow__" title="object.__pow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__pow__()</span></code></a> 메서드가 생략할 수 있는 세 번째 인자를 받도록 정의되어야 함에 주의해야 한다.</p>
<p>만약 이 메서드들 중 하나가 제공된 인자에 대해 연산을 지원하지 않으면, <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 를 돌려줘야 한다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__radd__">
<code class="descclassname">object.</code><code class="descname">__radd__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__radd__" title="永久链接至目标">¶</a></dt>
<dt id="object.__rsub__">
<code class="descclassname">object.</code><code class="descname">__rsub__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rsub__" title="永久链接至目标">¶</a></dt>
<dt id="object.__rmul__">
<code class="descclassname">object.</code><code class="descname">__rmul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmul__" title="永久链接至目标">¶</a></dt>
<dt id="object.__rmatmul__">
<code class="descclassname">object.</code><code class="descname">__rmatmul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmatmul__" title="永久链接至目标">¶</a></dt>
<dt id="object.__rtruediv__">
<code class="descclassname">object.</code><code class="descname">__rtruediv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rtruediv__" title="永久链接至目标">¶</a></dt>
<dt id="object.__rfloordiv__">
<code class="descclassname">object.</code><code class="descname">__rfloordiv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rfloordiv__" title="永久链接至目标">¶</a></dt>
<dt id="object.__rmod__">
<code class="descclassname">object.</code><code class="descname">__rmod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmod__" title="永久链接至目标">¶</a></dt>
<dt id="object.__rdivmod__">
<code class="descclassname">object.</code><code class="descname">__rdivmod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rdivmod__" title="永久链接至目标">¶</a></dt>
<dt id="object.__rpow__">
<code class="descclassname">object.</code><code class="descname">__rpow__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rpow__" title="永久链接至目标">¶</a></dt>
<dt id="object.__rlshift__">
<code class="descclassname">object.</code><code class="descname">__rlshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rlshift__" title="永久链接至目标">¶</a></dt>
<dt id="object.__rrshift__">
<code class="descclassname">object.</code><code class="descname">__rrshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rrshift__" title="永久链接至目标">¶</a></dt>
<dt id="object.__rand__">
<code class="descclassname">object.</code><code class="descname">__rand__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rand__" title="永久链接至目标">¶</a></dt>
<dt id="object.__rxor__">
<code class="descclassname">object.</code><code class="descname">__rxor__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rxor__" title="永久链接至目标">¶</a></dt>
<dt id="object.__ror__">
<code class="descclassname">object.</code><code class="descname">__ror__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ror__" title="永久链接至目标">¶</a></dt>
<dd><p id="index-91">이 메서드들은 뒤집힌 피연산자들에 대해 이항 산술 연산들(<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>)을 구현하기 위해 호출된다. 이 함수들은 왼쪽의 피연산자가 해당 연산을 지원하지 않고 <a class="footnote-reference" href="#id10" id="id5">[3]</a>, 피연산자들이 서로 다른 형일 때만 호출된다. <a class="footnote-reference" href="#id11" id="id6">[4]</a> 예를 들어, 표현식 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code> 의 값을 구하려고 할 때, <em>y</em> 가 <a class="reference internal" href="#object.__rsub__" title="object.__rsub__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rsub__()</span></code></a> 를 갖는 클래스의 인스턴스이고, <code class="docutils literal notranslate"><span class="pre">x.__sub__(y)</span></code> 가 <em>NotImplemented</em> 를 돌려주면 <code class="docutils literal notranslate"><span class="pre">y.__rsub__(x)</span></code> 가 호출된다.</p>
<p id="index-92">삼 항 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> 는 <a class="reference internal" href="#object.__rpow__" title="object.__rpow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rpow__()</span></code></a> 를 호출하려고 시도하지 않음에 주의해야 한다 (그렇게 하려면 코어션 규칙이 너무 복잡해진다).</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">만약 오른쪽 피연산자의 형이 왼쪽 피연산자의 형의 서브 클래스이고, 그 서브 클래스가 연산의 뒤집힌 메서드들 제공하면, 이 메서드가 왼쪽 연산자의 뒤집히지 않은 메서드보다 먼저 호출된다. 이 동작은 서브 클래스가 조상들의 연산을 재정의할 수 있도록 한다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__iadd__">
<code class="descclassname">object.</code><code class="descname">__iadd__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iadd__" title="永久链接至目标">¶</a></dt>
<dt id="object.__isub__">
<code class="descclassname">object.</code><code class="descname">__isub__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__isub__" title="永久链接至目标">¶</a></dt>
<dt id="object.__imul__">
<code class="descclassname">object.</code><code class="descname">__imul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imul__" title="永久链接至目标">¶</a></dt>
<dt id="object.__imatmul__">
<code class="descclassname">object.</code><code class="descname">__imatmul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imatmul__" title="永久链接至目标">¶</a></dt>
<dt id="object.__itruediv__">
<code class="descclassname">object.</code><code class="descname">__itruediv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__itruediv__" title="永久链接至目标">¶</a></dt>
<dt id="object.__ifloordiv__">
<code class="descclassname">object.</code><code class="descname">__ifloordiv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ifloordiv__" title="永久链接至目标">¶</a></dt>
<dt id="object.__imod__">
<code class="descclassname">object.</code><code class="descname">__imod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imod__" title="永久链接至目标">¶</a></dt>
<dt id="object.__ipow__">
<code class="descclassname">object.</code><code class="descname">__ipow__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="optional">[</span>, <em>modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__ipow__" title="永久链接至目标">¶</a></dt>
<dt id="object.__ilshift__">
<code class="descclassname">object.</code><code class="descname">__ilshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ilshift__" title="永久链接至目标">¶</a></dt>
<dt id="object.__irshift__">
<code class="descclassname">object.</code><code class="descname">__irshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__irshift__" title="永久链接至目标">¶</a></dt>
<dt id="object.__iand__">
<code class="descclassname">object.</code><code class="descname">__iand__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iand__" title="永久链接至目标">¶</a></dt>
<dt id="object.__ixor__">
<code class="descclassname">object.</code><code class="descname">__ixor__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ixor__" title="永久链接至目标">¶</a></dt>
<dt id="object.__ior__">
<code class="descclassname">object.</code><code class="descname">__ior__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ior__" title="永久链接至目标">¶</a></dt>
<dd><p>이 메서드들은 증분 산술 대입(<code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;=</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">//=</span></code>, <code class="docutils literal notranslate"><span class="pre">%=</span></code>, <code class="docutils literal notranslate"><span class="pre">**=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>, <code class="docutils literal notranslate"><span class="pre">^=</span></code>, <code class="docutils literal notranslate"><span class="pre">|=</span></code>)을 구현하기 위해 호출된다. 이 메서드는 연산을 제자리에서(<em>self</em> 를 수정해서) 하도록 시도해야 하고, 결과(반드시 그래야 하는 것은 아니지만 <em>self</em> 일 수 있다)를 돌려줘야 한다. 만약 특정 메서드가 정의되지 않으면, 중분 대입은 일반적인 메서드들을 대신 사용한다. 예를 들어, <em>x</em> 가 <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a> 메서드를 갖는 클래스의 인스턴스면, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x.__iadd__(y)</span></code> 와 동등하다. 그렇지 않으면, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> 의 값을 구할 때처럼, <code class="docutils literal notranslate"><span class="pre">x.__add__(y)</span></code> 와 <code class="docutils literal notranslate"><span class="pre">y.__radd__(x)</span></code> 가 고려된다. 어떤 상황에서, 증분 대입은 예상치 못한 에러로 이어질 수 있다. (<a class="reference internal" href="../faq/programming.html#faq-augmented-assignment-tuple-error"><span class="std std-ref">Why does a_tuple[i] += ['item'] raise an exception when the addition works?</span></a> 를 보라). 하지만 이 동작은 사실 데이터 모델의 일부다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__neg__">
<code class="descclassname">object.</code><code class="descname">__neg__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__neg__" title="永久链接至目标">¶</a></dt>
<dt id="object.__pos__">
<code class="descclassname">object.</code><code class="descname">__pos__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__pos__" title="永久链接至目标">¶</a></dt>
<dt id="object.__abs__">
<code class="descclassname">object.</code><code class="descname">__abs__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__abs__" title="永久链接至目标">¶</a></dt>
<dt id="object.__invert__">
<code class="descclassname">object.</code><code class="descname">__invert__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__invert__" title="永久链接至目标">¶</a></dt>
<dd><p id="index-93">일 항 산술 연산(<code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">~</span></code>)을 구현하기 위해 호출된다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__complex__">
<code class="descclassname">object.</code><code class="descname">__complex__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__complex__" title="永久链接至目标">¶</a></dt>
<dt id="object.__int__">
<code class="descclassname">object.</code><code class="descname">__int__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__int__" title="永久链接至目标">¶</a></dt>
<dt id="object.__float__">
<code class="descclassname">object.</code><code class="descname">__float__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__float__" title="永久链接至目标">¶</a></dt>
<dd><p id="index-94">Called to implement the built-in functions <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a>,
<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> and <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a>.  Should return a value
of the appropriate type.</p>
</dd></dl>

<dl class="method">
<dt id="object.__index__">
<code class="descclassname">object.</code><code class="descname">__index__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__index__" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="../library/operator.html#operator.index" title="operator.index"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.index()</span></code></a> 를 구현하기 위해 호출되고, 파이썬이 숫자 객체를 정수 객체로 손실 없이 변환해야 할 때(슬라이싱이나 내장 <a class="reference internal" href="../library/functions.html#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a>, <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a>, <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a> 함수들에서와같이)마다 호출된다. 이 메서드의 존재는 숫자 객체가 정수 형임을 가리킨다. 반드시 정수를 돌려줘야 한다.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">일관성 있는 정수형 클래스를 가지려고, <a class="reference internal" href="#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> 가 정의될 때는 <a class="reference internal" href="#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a> 역시 정의되어야 하고, 둘 다 같은 값을 돌려줘야 한다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__round__">
<code class="descclassname">object.</code><code class="descname">__round__</code><span class="sig-paren">(</span><em>self</em><span class="optional">[</span>, <em>ndigits</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__round__" title="永久链接至目标">¶</a></dt>
<dt id="object.__trunc__">
<code class="descclassname">object.</code><code class="descname">__trunc__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__trunc__" title="永久链接至目标">¶</a></dt>
<dt id="object.__floor__">
<code class="descclassname">object.</code><code class="descname">__floor__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floor__" title="永久链接至目标">¶</a></dt>
<dt id="object.__ceil__">
<code class="descclassname">object.</code><code class="descname">__ceil__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ceil__" title="永久链接至目标">¶</a></dt>
<dd><p id="index-95">Called to implement the built-in function <a class="reference internal" href="../library/functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> and <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a>
functions <a class="reference internal" href="../library/math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal notranslate"><span class="pre">trunc()</span></code></a>, <a class="reference internal" href="../library/math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a> and <a class="reference internal" href="../library/math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">ceil()</span></code></a>.
Unless <em>ndigits</em> is passed to <code class="xref py py-meth docutils literal notranslate"><span class="pre">__round__()</span></code> all these methods should
return the value of the object truncated to an <a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a>
(typically an <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>).</p>
<p>If <a class="reference internal" href="#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a> is not defined then the built-in function <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>
falls back to <a class="reference internal" href="#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="with-statement-context-managers">
<span id="context-managers"></span><h3>3.3.8. with 문 컨텍스트 매니저<a class="headerlink" href="#with-statement-context-managers" title="永久链接至标题">¶</a></h3>
<p><em class="dfn">컨텍스트 매니저 (context manager)</em> 는 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문을 실행할 때 자리 잡는 실행 컨텍스트(context)를 정의하는 객체다. 코드 블록의 실행을 위해, 컨텍스트 매니저는 원하는 실행시간 컨텍스트로의 진입과 탈출을 처리한다. 컨텍스트 매니저는 보통 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문(<a class="reference internal" href="compound_stmts.html#with"><span class="std std-ref">with 문</span></a> 섹션에서 설명한다)으로 시작되지만, 그들의 메서드를 호출해서 직접 사용할 수도 있다.</p>
<p id="index-96">컨텍스트 매니저의 전형적인 용도에는 다양한 종류의 전역 상태(global state)를 보관하고 복구하는 것, 자원을 로킹(locking)하고 언로킹(unlocking)하는 것, 열린 파일을 닫는 것 등이 있다.</p>
<p>컨텍스트 매니저에 대한 더 자세한 정보는 <a class="reference internal" href="../library/stdtypes.html#typecontextmanager"><span class="std std-ref">Context Manager Types</span></a> 에 나온다.</p>
<dl class="method">
<dt id="object.__enter__">
<code class="descclassname">object.</code><code class="descname">__enter__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__enter__" title="永久链接至目标">¶</a></dt>
<dd><p>이 객체와 연관된 실행시간 컨텍스트에 진입한다. <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문은 <a class="reference internal" href="compound_stmts.html#as"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code></a> 절로 지정된 대상이 있다면, 이 메서드의 반환 값을 연결한다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__exit__">
<code class="descclassname">object.</code><code class="descname">__exit__</code><span class="sig-paren">(</span><em>self</em>, <em>exc_type</em>, <em>exc_value</em>, <em>traceback</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__exit__" title="永久链接至目标">¶</a></dt>
<dd><p>이 객체와 연관된 실행시간 컨텍스트를 종료한다. 파라미터들은 컨텍스트에서 벗어나게 만든 예외를 기술한다. 만약 컨텍스트가 예외 없이 종료한다면, 세 인자 모두 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 이 된다.</p>
<p>만약 예외가 제공되고, 메서드가 예외를 중지시키고 싶으면 (즉 확산하는 것을 막으려면) 참(true)을 돌려줘야 한다. 그렇지 않으면 예외는 이 메서드가 종료한 후에 계속 진행된다.</p>
<p><a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 메서드가 전달된 예외를 다시 일으키지(reraise) 않도록 주의해야 한다; 이것은 호출자(caller)의 책임이다.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<dl class="last docutils">
<dt><span class="target" id="index-110"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a> - &quot;with&quot; 문</dt>
<dd>파이썬 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문에 대한 규격, 배경, 예.</dd>
</dl>
</div>
</div>
<div class="section" id="special-method-lookup">
<span id="special-lookup"></span><h3>3.3.9. 특수 메서드 조회<a class="headerlink" href="#special-method-lookup" title="永久链接至标题">¶</a></h3>
<p>사용자 정의 클래스의 경우, 묵시적인 특수 메서드의 호출은 객체의 인스턴스 딕셔너리가 아닌 객체의 형에 정의되어 있을 때만 올바르게 동작함이 보장된다. 이런 동작은 다음과 같은 코드가 예외를 일으키는 원인이다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">object of type &#39;C&#39; has no len()</span>
</pre></div>
</div>
<p>이런 동작의 배경에 깔린 논리는, 모든 객체(형 객체를 포함해서)들에 의해 구현되는 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 나 <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 과 같은 많은 특수 메서드들과 관련이 있다. 만약 이 메서드들에 대한 묵시적인 조회가 일반적인 조회 프로세스를 거친다면, 형 객체 자체에 대해 호출되었을 때 실패하게 된다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">descriptor &#39;__hash__&#39; of &#39;int&#39; object needs an argument</span>
</pre></div>
</div>
<p>클래스의 연결되지 않은 메서드를 호출하려는 이런 식의 잘못된 시도는 종종 '메타 클래스 혼란(metaclass confusion)' 이라고 불리고, 특수 메서드를 조회할 때 인스턴스를 우회하는 방법으로 피할 수 있다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>올바름을 추구하기 위해 인스턴스 어트리뷰트들을 우회하는 것에 더해, 묵시적인 특수 메서드 조회는 객체의 메타 클래스의 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 메서드 조차도 우회한다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Metaclass getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Class getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>                 <span class="c1"># Explicit lookup via instance</span>
<span class="go">Class getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>          <span class="c1"># Explicit lookup via type</span>
<span class="go">Metaclass getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>                      <span class="c1"># Implicit lookup</span>
<span class="go">10</span>
</pre></div>
</div>
<p>이런 식으로 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 절차를 우회하는 것은 특수 메서드 처리의 유연함을 일부 포기하는 대신(특수 메서드가 인터프리터에 의해 일관성 있게 호출되기 위해서는 <em>반드시</em> 클래스 객체에 설정되어야 한다), 인터프리터 내부에서의 속도 최적화를 위한 상당한 기회를 제공한다.</p>
</div>
</div>
<div class="section" id="coroutines">
<span id="index-98"></span><h2>3.4. 코루틴(Coroutines)<a class="headerlink" href="#coroutines" title="永久链接至标题">¶</a></h2>
<div class="section" id="awaitable-objects">
<h3>3.4.1. 어웨이터블 객체(Awaitable Objects)<a class="headerlink" href="#awaitable-objects" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a> 객체는 일반적으로 <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> 메서드를 구현한다. <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 함수가 돌려주는 <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">코루틴</span></a> 객체는 어웨이터블이다.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><a class="reference internal" href="../library/types.html#types.coroutine" title="types.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.coroutine()</span></code></a> 이나 <a class="reference internal" href="../library/asyncio-task.html#asyncio.coroutine" title="asyncio.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.coroutine()</span></code></a> 로 데코레이션된 제너레이터가 돌려주는 <a class="reference internal" href="../glossary.html#term-generator-iterator"><span class="xref std std-term">제너레이터 이터레이터</span></a> 객체 또한 어웨이터블이지만 <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> 를 구현하지 않는다.</p>
</div>
<dl class="method">
<dt id="object.__await__">
<code class="descclassname">object.</code><code class="descname">__await__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__await__" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">이터레이터</span></a> 를 돌려줘야 한다. <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a> 객체를 구현하기 위해 사용되어야 한다. 예를 들어, <a class="reference internal" href="../library/asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> 는 <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식과 호환되기 위해 이 메서드를 구현한다.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified">3.5 新版功能.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<p class="last"><span class="target" id="index-111"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 가 어웨이터블 객체에 대한 더 자세한 정보를 포함하고 있다.</p>
</div>
</div>
<div class="section" id="coroutine-objects">
<span id="id7"></span><h3>3.4.2. 코루틴 객체(Coroutine Objects)<a class="headerlink" href="#coroutine-objects" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">코루틴</span></a> 객체는 <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a> 객체다. 코루틴의 실행은 <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> 를 호출하고 그 결과를 이터레이트하는 방법으로 제어될 수 있다. 코루틴이 실행을 완료하고 복귀할 때, 이터레이터는 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 을 일으키고, 예외의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> 어트리뷰트가 반환 값을 갖고 있다. 만약 코루틴이 예외를 일으키면, 이터레이터에 의해 퍼진다. 코루틴이 직접 잡히지 않은 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 예외를 일으키지는 말아야 한다.</p>
<p>코루틴은 다음에 나열하는 메서드들 또한 갖고 있는데, 제너레이터(<a class="reference internal" href="expressions.html#generator-methods"><span class="std std-ref">제너레이터-이터레이터 메서드</span></a> 를 보라)의 것들과 닮았다. 하지만, 제너레이터와는 달리, 코루틴은 이터레이션을 직접 지원하지는 않는다.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.5.2 版更改: </span>코루틴을 두 번 await 하면 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 를 일으킨다.</p>
</div>
<dl class="method">
<dt id="coroutine.send">
<code class="descclassname">coroutine.</code><code class="descname">send</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.send" title="永久链接至目标">¶</a></dt>
<dd><p>코루틴의 실행을 시작하거나 재개한다. <em>value</em> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> 가 돌려준 이터레이터를 전진시키는 것과 같다. <em>value</em> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 아니면, 이 메서드는 코루틴이 일시 중지되도록 한 이터레이터의 <a class="reference internal" href="expressions.html#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> 메서드로 위임한다. 결과(반환 값, <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 이나 다른 예외)는 위에서 설명한 <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> 의 반환 값을 이터레이트할 때와 같다.</p>
</dd></dl>

<dl class="method">
<dt id="coroutine.throw">
<code class="descclassname">coroutine.</code><code class="descname">throw</code><span class="sig-paren">(</span><em>type</em><span class="optional">[</span>, <em>value</em><span class="optional">[</span>, <em>traceback</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.throw" title="永久链接至目标">¶</a></dt>
<dd><p>코루틴에서 지정한 예외가 발생하도록 한다. 이 메서드는 코루틴이 일시 중지되도록 한 이터레이터의 <a class="reference internal" href="expressions.html#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> 메서드로 위임한다(그런 메서드를 가지는 경우). 그렇지 않으면, 일시 중지지점에서 예외가 발생한다. 결과(반환 값, <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 이나 다른 예외)는 위에서 설명한 <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> 의 반환 값을 이터레이트할 때와 같다. 만약 예외가 코루틴에서 잡히지 않는다면 호출자에게 되돌아 전파된다.</p>
</dd></dl>

<dl class="method">
<dt id="coroutine.close">
<code class="descclassname">coroutine.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.close" title="永久链接至目标">¶</a></dt>
<dd><p>코루틴이 자신을 정리하고 종료하도록 만든다. 만약 코루틴이 일시 중지 중이면, 이 메서드는 먼저 코루틴이 일시 중지되도록 한 이터레이터의 <a class="reference internal" href="expressions.html#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 메서드로 위임한다(그런 메서드를 가지는 경우). 그런 다음 일시 중지지점에서 <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> 를 발생시키는데, 코루틴이 즉시 자신을 정리하도록 만든다. 마지막으로 코루틴에 실행을 종료했다고 표시하는데, 아직 시작하지조차 않았을 때도 그렇다.</p>
<p>코루틴 객체가 파괴될 때는 위의 프로세스에 따라 자동으로 닫힌다(closed).</p>
</dd></dl>

</div>
<div class="section" id="asynchronous-iterators">
<span id="async-iterators"></span><h3>3.4.3. 비동기 이터레이터(Asynchronous Iterators)<a class="headerlink" href="#asynchronous-iterators" title="永久链接至标题">¶</a></h3>
<p><em>비동기 이터러블(asynchronous iterable)</em> 은 자신의 <code class="docutils literal notranslate"><span class="pre">__aiter__</span></code> 구현에서 비동기 코드를 호출할 수 있고, <em>비동기 이터레이터</em> 는 자신의 <code class="docutils literal notranslate"><span class="pre">__anext__</span></code> 메서드에서 비동기 코드를 호출할 수 있다.</p>
<p>비동기 이터레이터는 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 문에서 사용될 수 있다.</p>
<dl class="method">
<dt id="object.__aiter__">
<code class="descclassname">object.</code><code class="descname">__aiter__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aiter__" title="永久链接至目标">¶</a></dt>
<dd><p><em>비동기 이터레이터</em> 객체를 돌려줘야 한다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__anext__">
<code class="descclassname">object.</code><code class="descname">__anext__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__anext__" title="永久链接至目标">¶</a></dt>
<dd><p>이터레이터의 다음 값을 주는 <em>어웨이터블</em> 을 돌려줘야 한다. 이터레이션이 끝나면 <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 에러를 일으켜야 한다.</p>
</dd></dl>

<p>비동기 이터러블 객체의 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Reader</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">__anext__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">StopAsyncIteration</span>
        <span class="k">return</span> <span class="n">val</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">3.5 新版功能.</span></p>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<div class="last versionchanged">
<p><span class="versionmodified">在 3.5.2 版更改: </span>CPython 3.5.2부터, <code class="docutils literal notranslate"><span class="pre">__aiter__</span></code> 는 <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">비동기 이터레이터</span></a> 를 직접 돌려줄 수 있다. <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a> 객체를 돌려주면 <a class="reference internal" href="../library/exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PendingDeprecationWarning</span></code></a> 이 발생한다.</p>
<p>CPython 3.5.x 와의 과거 호환성을 유지하는 코드들 작성을 위해 권장하는 방법은 <code class="docutils literal notranslate"><span class="pre">__aiter__</span></code> 에서 계속 어웨이터블을 돌려주는 것이다. 만약 PendingDeprecationWarning 를 피하면서 코드의 과거 호환성을 유지하고 싶다면, 다음과 같은 데코레이터를 사용할 수 있다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">aiter_compat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">async</span> <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">aiter_compat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span>
</pre></div>
</div>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AsyncIterator</span><span class="p">:</span>

    <span class="nd">@aiter_compat</span>
    <span class="k">def</span> <span class="nf">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">__anext__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>CPython 3.6부터, <a class="reference internal" href="../library/exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PendingDeprecationWarning</span></code></a> 은 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> 으로 변경되었다. CPython 3.7부터, <code class="docutils literal notranslate"><span class="pre">__aiter__</span></code> 이 어웨이터블을 돌려주면 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 을 일으킬 것이다.</p>
</div>
</div>
</div>
<div class="section" id="asynchronous-context-managers">
<h3>3.4.4. 비동기 컨텍스트 매니저<a class="headerlink" href="#asynchronous-context-managers" title="永久链接至标题">¶</a></h3>
<p><em>비동기 컨텍스트 매니저(asynchronous context manager)</em> 는 <code class="docutils literal notranslate"><span class="pre">__aenter__</span></code> 와 <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> 메서드에서 실행을 일시 중지할 수 있는 <em>컨텍스트 매니저</em> 다.</p>
<p>비동기 컨텍스트 매니저는 <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 문에서 사용될 수 있다.</p>
<dl class="method">
<dt id="object.__aenter__">
<code class="descclassname">object.</code><code class="descname">__aenter__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aenter__" title="永久链接至目标">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 메서드와 의미상으로 유사한데, 유일한 차이점은 <em>어웨이터블</em> 을 돌려줘야 한다는 것이다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__aexit__">
<code class="descclassname">object.</code><code class="descname">__aexit__</code><span class="sig-paren">(</span><em>self</em>, <em>exc_type</em>, <em>exc_value</em>, <em>traceback</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aexit__" title="永久链接至目标">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 메서드와 의미상으로 유사한데, 유일한 차이점은 <em>어웨이터블</em> 을 돌려줘야 한다는 것이다.</p>
</dd></dl>

<p>비동기 컨텍스트 매니저 클래스의 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AsyncContextManager</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;entering context&#39;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;exiting context&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">3.5 新版功能.</span></p>
</div>
<p class="rubric">각</p>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>어떤 제한된 조건으로, 어떤 경우에 객체의 형을 변경하는 것이 <em>가능하다</em>. 하지만 잘못 다뤄지면 아주 괴상한 결과로 이어질 수 있으므로 일반적으로 좋은 생각이 아니다.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>, <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a>, <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> 메서드들이 이런 경우에 대한 특별한 처리를 포함하고 있다; 다른 것들도 여전히 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 을 일으키지만, 단지 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 콜러블이 아니므로 그런 것뿐이다.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>여기서 &quot;지원하지 않는다&quot; 는 클래스가 그런 메서드를 갖지 않거나, 메서드가 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 를 돌려줌을 뜻한다. 오른쪽 피연산자의 뒤집힌 메서드를 사용하는 대안이 시도되도록 하려면 메서드를 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정하지 말아야 한다 - 그렇게 하는 것은 그런 대안을 명시적으로 <em>금지하는</em> 반대 효과를 준다.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[4]</a></td><td>피연산자들이 같은 형이면, 뒤집히지 않은 메서드(<a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a> 같은)가 실패하면 그 연산이 지원되지 않는 것으로 간주한다. 이것이 뒤집힌 메서드가 호출되지 않는 이유다.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. 데이터 모델</a><ul>
<li><a class="reference internal" href="#objects-values-and-types">3.1. 객체, 값, 형</a></li>
<li><a class="reference internal" href="#the-standard-type-hierarchy">3.2. 표준형 계층</a></li>
<li><a class="reference internal" href="#special-method-names">3.3. 특수 메서드 이름들</a><ul>
<li><a class="reference internal" href="#basic-customization">3.3.1. 기본적인 커스터마이제이션</a></li>
<li><a class="reference internal" href="#customizing-attribute-access">3.3.2. 어트리뷰트 액세스 커스터마이제이션</a><ul>
<li><a class="reference internal" href="#customizing-module-attribute-access">3.3.2.1. Customizing module attribute access</a></li>
<li><a class="reference internal" href="#implementing-descriptors">3.3.2.2. 디스크립터 구현하기</a></li>
<li><a class="reference internal" href="#invoking-descriptors">3.3.2.3. 디스크립터 호출하기</a></li>
<li><a class="reference internal" href="#slots">3.3.2.4. __slots__</a><ul>
<li><a class="reference internal" href="#notes-on-using-slots">3.3.2.4.1. <em>__slots__</em> 사용에 관한 노트</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-class-creation">3.3.3. 클래스 생성 커스터마이제이션</a><ul>
<li><a class="reference internal" href="#metaclasses">3.3.3.1. 메타 클래스</a></li>
<li><a class="reference internal" href="#determining-the-appropriate-metaclass">3.3.3.2. 적절한 메타 클래스 선택하기</a></li>
<li><a class="reference internal" href="#preparing-the-class-namespace">3.3.3.3. 클래스 이름 공간 준비하기</a></li>
<li><a class="reference internal" href="#executing-the-class-body">3.3.3.4. 클래스 바디 실행하기</a></li>
<li><a class="reference internal" href="#creating-the-class-object">3.3.3.5. 클래스 객체 만들기</a></li>
<li><a class="reference internal" href="#metaclass-example">3.3.3.6. 메타 클래스 예제</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-instance-and-subclass-checks">3.3.4. 인스턴스 및 서브 클래스 검사 커스터마이제이션</a></li>
<li><a class="reference internal" href="#emulating-callable-objects">3.3.5. 콜러블 객체 흉내 내기</a></li>
<li><a class="reference internal" href="#emulating-container-types">3.3.6. 컨테이너형 흉내 내기</a></li>
<li><a class="reference internal" href="#emulating-numeric-types">3.3.7. 숫자 형 흉내 내기</a></li>
<li><a class="reference internal" href="#with-statement-context-managers">3.3.8. with 문 컨텍스트 매니저</a></li>
<li><a class="reference internal" href="#special-method-lookup">3.3.9. 특수 메서드 조회</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coroutines">3.4. 코루틴(Coroutines)</a><ul>
<li><a class="reference internal" href="#awaitable-objects">3.4.1. 어웨이터블 객체(Awaitable Objects)</a></li>
<li><a class="reference internal" href="#coroutine-objects">3.4.2. 코루틴 객체(Coroutine Objects)</a></li>
<li><a class="reference internal" href="#asynchronous-iterators">3.4.3. 비동기 이터레이터(Asynchronous Iterators)</a></li>
<li><a class="reference internal" href="#asynchronous-context-managers">3.4.4. 비동기 컨텍스트 매니저</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="lexical_analysis.html"
                        title="上一章">2. 구문 분석</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="executionmodel.html"
                        title="下一章">4. 실행 모델</a></p>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/reference/datamodel.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 실행 모델"
             >下一页</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. 구문 분석"
             >上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh</span>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">도큐멘테이션 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 언어 레퍼런스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    파이썬 소프트웨어 재단은 비영리 법인입니다.
    <a href="https://www.python.org/psf/donations/">기부를 부탁합니다.</a>
    <br />
    4月 21, 2018 에 마지막으로 업데이트되었습니다.
    <a href="../bugs.html">버그를 찾았나요?</a>
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.7.2 를 사용해서 만들었습니다.
    </div>

  </body>
</html>