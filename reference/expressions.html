
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>6. 표현식 &#8212; Python 3.6.5 文档</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.6.5 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="7. 단순문(Simple statements)" href="simple_stmts.html" />
    <link rel="prev" title="5. 임포트 시스템" href="import.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.org/3/reference/expressions.html" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. 단순문(Simple statements)"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="import.html" title="5. 임포트 시스템"
             accesskey="P">上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh</span>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">도큐멘테이션 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 언어 레퍼런스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="expressions">
<span id="id1"></span><h1>6. 표현식<a class="headerlink" href="#expressions" title="永久链接至标题">¶</a></h1>
<p id="index-0">이 장은 파이썬에서 사용되는 표현식 요소들의 의미를 설명한다.</p>
<p><strong>문법 유의 사항:</strong> 여기와 이어지는 장에서는, 구문 분석이 아니라 문법을 설명하기 위해 확장 BNF 표기법을 사용한다. 문법 규칙이 다음과 같은 형태를 가지고,</p>
<pre>
<strong id="grammar-token-name">name</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">othername</span></code>
</pre>
<p>뜻(semantics)을 주지 않으면, 이 형태의 <code class="docutils literal notranslate"><span class="pre">name</span></code> 의 뜻은 <code class="docutils literal notranslate"><span class="pre">othername</span></code> 과 같다.</p>
<div class="section" id="arithmetic-conversions">
<span id="conversions"></span><h2>6.1. 산술 변환<a class="headerlink" href="#arithmetic-conversions" title="永久链接至标题">¶</a></h2>
<p id="index-1">다음에 나오는 산술 연산자의 설명이 &quot;숫자 인자들은 공통 형으로 변환된다&quot;라는 구절을 사용할 때, 내장형의 연산자 구현이 다음과 같이 동작한다는 뜻이다:</p>
<ul class="simple">
<li>어느 한 인자가 복소수면 다른 하나는 복소수로 변환된다;</li>
<li>그렇지 않고, 어느 한 인자가 실수면, 다른 하나는 실수로 변환된다;</li>
<li>그렇지 않으면, 두 인자는 모두 정수여야 하고, 변환은 필요 없다.</li>
</ul>
<p>어떤 연산자들(예를 들어, '%' 연산자의 왼쪽 인자로 주어지는 문자열)에 대해서는 몇 가지 추가의 규칙이 적용된다. 확장(extension)은 그들 자신의 변환 규칙을 정의해야 한다.</p>
</div>
<div class="section" id="atoms">
<span id="id2"></span><h2>6.2. 아톰 (Atoms)<a class="headerlink" href="#atoms" title="永久链接至标题">¶</a></h2>
<p id="index-2">아톰은 표현식의 가장 기본적인 요소다. 가장 간단한 아톰은 식별자와 리터럴이다. 괄호, 꺾쇠괄호, 중괄호로 둘러싸인 형태도 문법적으로 아톰으로 분류된다. 아톰의 문법은 이렇다:</p>
<pre>
<strong id="grammar-token-atom">atom     </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> | <a class="reference internal" href="#grammar-token-literal"><code class="xref docutils literal notranslate"><span class="pre">literal</span></code></a> | <a class="reference internal" href="#grammar-token-enclosure"><code class="xref docutils literal notranslate"><span class="pre">enclosure</span></code></a>
<strong id="grammar-token-enclosure">enclosure</strong> ::=  <a class="reference internal" href="#grammar-token-parenth_form"><code class="xref docutils literal notranslate"><span class="pre">parenth_form</span></code></a> | <a class="reference internal" href="#grammar-token-list_display"><code class="xref docutils literal notranslate"><span class="pre">list_display</span></code></a> | <a class="reference internal" href="#grammar-token-dict_display"><code class="xref docutils literal notranslate"><span class="pre">dict_display</span></code></a> | <a class="reference internal" href="#grammar-token-set_display"><code class="xref docutils literal notranslate"><span class="pre">set_display</span></code></a>
               | <a class="reference internal" href="#grammar-token-generator_expression"><code class="xref docutils literal notranslate"><span class="pre">generator_expression</span></code></a> | <a class="reference internal" href="#grammar-token-yield_atom"><code class="xref docutils literal notranslate"><span class="pre">yield_atom</span></code></a>
</pre>
<div class="section" id="atom-identifiers">
<span id="identifiers-names"></span><h3>6.2.1. 식별자 (이름)<a class="headerlink" href="#atom-identifiers" title="永久链接至标题">¶</a></h3>
<p id="index-3">아톰으로 등장하는 식별자는 이름이다. 구문 분석에 대해서는 <a class="reference internal" href="lexical_analysis.html#identifiers"><span class="std std-ref">식별자와 키워드</span></a> 섹션을, 이름과 연결에 대한 문서는 <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">이름과 연결(binding)</span></a> 섹션을 보면 된다.</p>
<p id="index-4">이름이 객체에 연결될 때, 아톰의 값을 구하면 객체가 나온다. 이름이 연결되지 않았을 때, 값을 구하려고 하면 <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 예외가 일어난다.</p>
<p id="index-5"><strong>비공개 이름 뒤섞기(private name mangling):</strong> 클래스 정의에 등장하는 식별자가 두 개나 그 이상의 밑줄로 시작하고, 두 개나 그 이상의 밑줄로 끝나지 않으면, 그 클래스의 <em class="dfn">비공개 이름(private name)</em> 으로 간주한다. 비공개 이름은 그 들을 위한 코드가 만들어지기 전에 더 긴 형태로 변환된다. 이 변환은 그 이름의 앞에 클래스 이름을 삽입하는데, 클래스 이름의 처음에 오는 모든 밑줄을 제거한 후, 하나의 밑줄을 추가한다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">Ham</span></code> 이라는 이름의 클래스에 식별자 <code class="docutils literal notranslate"><span class="pre">__spam</span></code> 이 등장하면, <code class="docutils literal notranslate"><span class="pre">_Ham__spam</span></code> 으로 변환된다. 이 변환은 식별자가 사용되는 문법적인 문맥에 무관하다. 변환된 이름이 극단적으로 길면(255자보다 길면), 구현이 정의한 잘라내기가 발생할 수 있다. 클래스 이름이 밑줄로만 구성되어 있으면, 변환은 일어나지 않는다.</p>
</div>
<div class="section" id="literals">
<span id="atom-literals"></span><h3>6.2.2. 리터럴 (Literals)<a class="headerlink" href="#literals" title="永久链接至标题">¶</a></h3>
<p id="index-6">파이썬은 문자열과 바이트열 리터럴과 여러 가지 숫자 리터럴들을 지원한다:</p>
<pre>
<strong id="grammar-token-literal">literal</strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-stringliteral"><code class="xref docutils literal notranslate"><span class="pre">stringliteral</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-bytesliteral"><code class="xref docutils literal notranslate"><span class="pre">bytesliteral</span></code></a>
             | <a class="reference internal" href="lexical_analysis.html#grammar-token-integer"><code class="xref docutils literal notranslate"><span class="pre">integer</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-floatnumber"><code class="xref docutils literal notranslate"><span class="pre">floatnumber</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-imagnumber"><code class="xref docutils literal notranslate"><span class="pre">imagnumber</span></code></a>
</pre>
<p>리터럴의 값을 구하면 주어진 형(문자열, 바이트열, 정수, 실수, 복소수)과 주어진 값을 갖는 객체가 나온다. 실수와 복소수의 경우는 근삿값일 수 있다. 자세한 내용은 <a class="reference internal" href="lexical_analysis.html#literals"><span class="std std-ref">리터럴</span></a> 섹션을 보면 된다.</p>
<p id="index-7">모든 리터럴은 불변 데이터형에 대응하기 때문에, 객체의 아이덴티티는 값 보다 덜 중요하다. 같은 값의 리터럴에 대해 반복적으로 값을 구하면 (프로그램 텍스트의 같은 장소에 있거나 다른 장소에 있을 때) 같은 객체를 얻을 수도 있고, 같은 값의 다른 객체를 얻을 수도 있다.</p>
</div>
<div class="section" id="parenthesized-forms">
<span id="parenthesized"></span><h3>6.2.3. 괄호 안에 넣은 형<a class="headerlink" href="#parenthesized-forms" title="永久链接至标题">¶</a></h3>
<p id="index-8">괄호 안에 넣은 형은, 괄호로 둘러싸인 생략 가능한 표현식 목록이다:</p>
<pre>
<strong id="grammar-token-parenth_form">parenth_form</strong> ::=  &quot;(&quot; [<a class="reference internal" href="#grammar-token-starred_expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a>] &quot;)&quot;
</pre>
<p>괄호 안에 넣은 표현식 목록은, 무엇이건 그 표현식 목록이 산출하는 것이 된다: 목록이 적어도 하나의 쉼표를 포함하면, 튜플이 된다; 그렇지 않으면 표현식 목록을 구성한 단일 표현식이 된다.</p>
<p id="index-9">빈 괄호 쌍은 빈 튜플 객체를 만든다. 튜플은 불변이기 때문에 리터럴의 규칙이 적용된다 (즉, 두 개의 빈 튜플은 같은 객체일 수도 있고 그렇지 않을 수도 있다).</p>
<p id="index-10">튜플이 괄호에 의해 만들어지는 것이 아니라, 쉼표 연산자의 사용 때문이라는 것에 주의해야 한다. 예외는 빈 튜플인데, 괄호가 필요하다 --- 표현식에서 괄호 없는 &quot;없음(nothing)&quot;을 허락하는 것은 모호함을 유발하고 자주 발생하는 오타들이 잡히지 않은 채로 남게 할 것이다.</p>
</div>
<div class="section" id="displays-for-lists-sets-and-dictionaries">
<span id="comprehensions"></span><h3>6.2.4. 리스트, 집합, 딕셔너리의 디스플레이(display)<a class="headerlink" href="#displays-for-lists-sets-and-dictionaries" title="永久链接至标题">¶</a></h3>
<p>리스트, 집합, 딕셔너리를 구성하기 위해, 파이썬은 &quot;디스플레이(displays)&quot;라고 부르는 특별한 문법을 각기 두 가지 스타일로 제공한다:</p>
<ul class="simple">
<li>컨테이너의 내용을 명시적으로 나열하거나,</li>
<li>일련의 루프와 필터링 지시들을 통해 계산되는데, <em class="dfn">컴프리헨션 (comprehension)</em> 이라고 불린다.</li>
</ul>
<p>컴프리헨션의 공통 문법 요소들은 이렇다:</p>
<pre>
<strong id="grammar-token-comprehension">comprehension</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a>
<strong id="grammar-token-comp_for">comp_for     </strong> ::=  [ASYNC] &quot;for&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-target_list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a> &quot;in&quot; <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [<a class="reference internal" href="#grammar-token-comp_iter"><code class="xref docutils literal notranslate"><span class="pre">comp_iter</span></code></a>]
<strong id="grammar-token-comp_iter">comp_iter    </strong> ::=  <a class="reference internal" href="#grammar-token-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a> | <a class="reference internal" href="#grammar-token-comp_if"><code class="xref docutils literal notranslate"><span class="pre">comp_if</span></code></a>
<strong id="grammar-token-comp_if">comp_if      </strong> ::=  &quot;if&quot; <a class="reference internal" href="#grammar-token-expression_nocond"><code class="xref docutils literal notranslate"><span class="pre">expression_nocond</span></code></a> [<a class="reference internal" href="#grammar-token-comp_iter"><code class="xref docutils literal notranslate"><span class="pre">comp_iter</span></code></a>]
</pre>
<p>컴프리헨션은 하나의 표현식과 그 뒤를 따르는 최소한 하나의 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 절과 없거나 여러 개의 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 또는 <a class="reference internal" href="compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 절로 구성된다. 이 경우, 새 컨테이너의 요소들은 각 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 또는 <a class="reference internal" href="compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 절이 왼쪽에서 오른쪽으로 중첩된 블록을 이루고, 가장 안쪽에 있는 블록에서 표현식의 값을 구해서 만들어낸 것들이다.</p>
<p>컴프리헨션은 별도의 스코프(scope)에서 실행되기 때문에, 타깃 목록에서 대입된 이름들은 둘러싼 스코프로 &quot;누수(leak)&quot;되지 않음에 주의해야 한다.</p>
<p>파이썬 3.6부터, <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 함수에서는, <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">비동기 이터레이터</span></a> 를 탐색하기 위해 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 를 사용할 수 있다. <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 함수에 있는 컴프리헨션은 처음에 나오는 표현식뒤에 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 나 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 절이 올 수 있고, 추가의 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 나 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 절이 올 수 있고, <a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식 또한 사용할 수 있다. 컴프리헨션이 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 절이나 <a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식을 포함하면 <em class="dfn">비동기 컴프리헨션 (asynchronous comprehension)</em> 이라고 불린다. 비동기 컴프리헨션은 그것이 등장한 코루틴 함수의 실행을 일시 중지시킬 수 있다. <span class="target" id="index-95"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0530"><strong>PEP 530</strong></a> 를 참고하라.</p>
</div>
<div class="section" id="list-displays">
<span id="lists"></span><h3>6.2.5. 리스트 디스플레이<a class="headerlink" href="#list-displays" title="永久链接至标题">¶</a></h3>
<p id="index-12">리스트 디스플레이는 꺾쇠괄호(square brackets)로 둘러싸인 표현식의 나열인데 비어있을 수 있다:</p>
<pre>
<strong id="grammar-token-list_display">list_display</strong> ::=  &quot;[&quot; [<a class="reference internal" href="#grammar-token-starred_list"><code class="xref docutils literal notranslate"><span class="pre">starred_list</span></code></a> | <a class="reference internal" href="#grammar-token-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>] &quot;]&quot;
</pre>
<p>리스트 디스플레이는 리스트 객체를 만드는데, 그 내용은 표현식의 목록이나 컴프리헨션으로 지정할 수 있다. 쉼표로 분리된 표현식의 목록이 제공될 때, 그 요소들은 왼쪽에서 오른쪽으로 값이 구해지고, 그 순서대로 리스트 객체에 삽입된다. 컴프리헨션이 제공될 때, 리스트는 컴프리헨션으로 만들어지는 요소들로 구성된다.</p>
</div>
<div class="section" id="set-displays">
<span id="set"></span><h3>6.2.6. 집합 디스플레이<a class="headerlink" href="#set-displays" title="永久链接至标题">¶</a></h3>
<p id="index-13">집합 디스플레이는 중괄호(curly braces)로 표시되고, 키와 값을 분리하는 콜론(colon)이 없는 것으로 딕셔너리 디스플레이와 구분될 수 있다.</p>
<pre>
<strong id="grammar-token-set_display">set_display</strong> ::=  &quot;{&quot; (<a class="reference internal" href="#grammar-token-starred_list"><code class="xref docutils literal notranslate"><span class="pre">starred_list</span></code></a> | <a class="reference internal" href="#grammar-token-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>) &quot;}&quot;
</pre>
<p>집합 디스플레이는 새 가변 집합 객체를 만드는데, 그 내용은 표현식의 시퀀스나 컴프리헨션으로 지정된다. 쉼표로 분리된 표현식의 목록이 제공될 때, 그 요소들은 왼쪽에서 오른쪽으로 값이 구해지고, 집합 객체에 더해진다. 컴프리헨션이 제공될 때, 집합은 컴프리헨션으로 만들어지는 요소들로 구성된다.</p>
<p>빈 집합은 <code class="docutils literal notranslate"><span class="pre">{}</span></code> 으로 만들어질 수 없다; 이 리터럴은 빈 딕셔너리를 만든다.</p>
</div>
<div class="section" id="dictionary-displays">
<span id="dict"></span><h3>6.2.7. 딕셔너리 디스플레이<a class="headerlink" href="#dictionary-displays" title="永久链接至标题">¶</a></h3>
<p id="index-14">딕셔너리 디스플레이는 중괄호(curly braces)로 둘러싸인 키/데이터 쌍의 나열인데 비어있을 수 있다:</p>
<pre>
<strong id="grammar-token-dict_display">dict_display      </strong> ::=  &quot;{&quot; [<a class="reference internal" href="#grammar-token-key_datum_list"><code class="xref docutils literal notranslate"><span class="pre">key_datum_list</span></code></a> | <a class="reference internal" href="#grammar-token-dict_comprehension"><code class="xref docutils literal notranslate"><span class="pre">dict_comprehension</span></code></a>] &quot;}&quot;
<strong id="grammar-token-key_datum_list">key_datum_list    </strong> ::=  <a class="reference internal" href="#grammar-token-key_datum"><code class="xref docutils literal notranslate"><span class="pre">key_datum</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-key_datum"><code class="xref docutils literal notranslate"><span class="pre">key_datum</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-key_datum">key_datum         </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | &quot;**&quot; <a class="reference internal" href="#grammar-token-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>
<strong id="grammar-token-dict_comprehension">dict_comprehension</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a>
</pre>
<p>딕셔너리 디스플레이는 새 딕셔너리 객체를 만든다.</p>
<p>쉼표로 분리된 키/데이터 쌍의 시퀀스가 주어질 때, 그것들은 왼쪽에서 오른쪽으로 값이 구해지고 딕셔너리의 엔트리들을 정의한다: 각 키 객체는 딕셔너리에 대응하는 데이터를 저장하는 데 키로 사용된다. 이것은 키/값 목록에서 같은 키를 여러 번 지정할 수 있다는 뜻인데, 그 키의 최종 딕셔너리 값은 마지막에 주어진 것이 된다.</p>
<p id="index-15">두 개의 애스터리스크(asterisk) <code class="docutils literal notranslate"><span class="pre">**</span></code> 는 <em class="dfn">딕셔너리 언 패킹(dictionary unpacking)</em> 를 나타낸다. 피연산자는 <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">매핑</span></a> 이어야만 한다. 각 매핑 항목은 새 딕셔너리에 추가된다. 뒤에 오는 값들이 앞의 키/데이터 쌍이나 앞의 딕셔너리 언 패킹 때문에 설정된 값들을 교체한다.</p>
<div class="versionadded">
<p><span class="versionmodified">3.5 新版功能: </span><span class="target" id="index-96"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0448"><strong>PEP 448</strong></a> 에서 처음 제안된 딕셔너리 디스플레이로의 언 패킹.</p>
</div>
<p>딕셔너리 컴프리헨션은, 리스트와 집합 컴프리헨션에 대비해서, 일반적인 &quot;for&quot; 와 &quot;if&quot; 절 앞에 콜론으로 분리된 두 개의 표현식을 필요로 한다. 컴프리헨션이 실행될 때, 만들어지는 키와 값 요소들이 만들어지는 순서대로 딕셔너리에 삽입된다.</p>
<p id="index-17">킷값의 형에 대한 제약은 앞의 섹션 <a class="reference internal" href="datamodel.html#types"><span class="std std-ref">표준형 계층</span></a> 에서 나열되었다. (요약하자면, 키 형은 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">해시 가능</span></a> 해야 하는데, 모든 가변 객체들이 제외된다.) 중복된 키 간의 충돌은 감지되지 않는다; 주어진 키에 대해 저장된 마지막 (구문상으로 디스플레이의 가장 오른쪽에 있는) 데이터가 우선한다.</p>
</div>
<div class="section" id="generator-expressions">
<span id="genexpr"></span><h3>6.2.8. 제너레이터 표현식 (Generator expressions)<a class="headerlink" href="#generator-expressions" title="永久链接至标题">¶</a></h3>
<p id="index-18">제너레이터 표현식은 괄호로 둘러싸인 간결한 제너레이터 표기법이다.</p>
<pre>
<strong id="grammar-token-generator_expression">generator_expression</strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a> &quot;)&quot;
</pre>
<p>제너레이터 표현식은 새 제너레이터 객체를 만든다. 문법은 꺾쇠괄호나 중괄호 대신 괄호로 둘러싸인다는 점만 제외하면 컴프리헨션과 같다.</p>
<p>제너레이터 표현식에 사용되는 변수들은 제너레이터 객체의 <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 메서드가 호출될 때 느긋하게(lazily) 값이 구해진다 (일반 제너레이터와 마찬가지다). 하지만, 가장 왼쪽의 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 절은 즉시 값이 구해져서, 그것으로 인해 발생하는 에러는 제너레이터 표현을 다루는 다른 어떤 코드들에서 발생하는 에러들보다 먼저 발견된다. 뒤따르는 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 절들은 앞의 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 루프에 종속되기 때문에 즉시 값을 구할 수 없다. 예를 들어: <code class="docutils literal notranslate"><span class="pre">(x*y</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(10)</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">bar(x))</span></code>.</p>
<p>단지 하나의 인자만 갖는 호출에서는 괄호를 생략할 수 있다. 자세한 내용은 <a class="reference internal" href="#calls"><span class="std std-ref">호출</span></a> 섹션을 보면 된다.</p>
<p>파이썬 3.6부터, 제너레이터가 <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 함수에서 등장하면, 비동기 컴프리헨션 처럼 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 절과 <a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식이 허락된다. 제너레이터 표현식이 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 절이나 <a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식을 포함하면 <em class="dfn">비동기 제너레이터 표현식 (asynchronous generator expression)</em> 이라고 불린다. 비동기 제너레이터 표현식은 새 비동기 제너레이터 객체를 만드는데 이것은 비동기 이터레이터다 (<a class="reference internal" href="datamodel.html#async-iterators"><span class="std std-ref">비동기 이터레이터(Asynchronous Iterators)</span></a> 를 참고하라).</p>
</div>
<div class="section" id="yield-expressions">
<span id="yieldexpr"></span><h3>6.2.9. 일드 표현식(Yield expressions)<a class="headerlink" href="#yield-expressions" title="永久链接至标题">¶</a></h3>
<pre id="index-19">
<strong id="grammar-token-yield_atom">yield_atom      </strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-yield_expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a> &quot;)&quot;
<strong id="grammar-token-yield_expression">yield_expression</strong> ::=  &quot;yield&quot; [<a class="reference internal" href="#grammar-token-expression_list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a> | &quot;from&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
</pre>
<p>일드 표현식은 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a> 함수나 <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">비동기 제너레이터</span></a> 함수를 정의할 때 사용되고, 그래서 함수 정의의 바디에서만 사용될 수 있다. 함수의 바디에서 일드 표현식을 사용하는 것은 함수를 제너레이터로 만들고, <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 함수의 바디에서 사용하는 것은 그 코루틴 함수를 비동기 제너레이터로 만든다. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>  <span class="c1"># defines a generator function</span>
    <span class="k">yield</span> <span class="mi">123</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">agen</span><span class="p">():</span> <span class="c1"># defines an asynchronous generator function (PEP 525)</span>
    <span class="k">yield</span> <span class="mi">123</span>
</pre></div>
</div>
<p>제너레이터 함수는 다음에서 설명한다. 반면에 비동기 제너레이터 함수는 <a class="reference internal" href="#asynchronous-generator-functions"><span class="std std-ref">비동기 제너레이터 함수</span></a> 섹션에서 별도로 설명한다.</p>
<p>제너레이터 함수가 호출될 때, 제너레이터로 알려진 이터레이터를 돌려준다. 그러면 그 제너레이터가 제너레이터 함수의 실행을 제어한다. 제너레이터의 메서드들 중 하나가 호출될 때 실행이 시작된다. 그 시점에, 실행은 첫 번째 일드 표현식까지 진행한 후, 거기에서 다시 일시 중지(suspend)하고 제너레이터의 호출자에게 <a class="reference internal" href="#grammar-token-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> 의 값을 돌려준다. 일시 중지된다는 것은, 모든 지역 상태가 보존된다는 뜻인데, 지역 변수들의 현재 연결들, 명령 포인터(instruction pointer), 내부 연산 스택(internal evaluation stack), 모든 예외 처리 상태가 포함된다. 제너레이터의 메서드들 중 하나를 호출해서 실행이 재개될 때, 함수는 마치 일드 표현식이 단지 또 하나의 외부 호출인 것처럼 진행할 수 있다. 재개된 후에 일드 표현식의 값은 실행을 재개하도록 만든 메서드에 달려있다. (보통 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 나 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 내장을 통해) <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 가 사용되었다면 결과는 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 이다. 그렇지 않고, <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> 가 사용되었다면, 결과는 그 메서드로 전달된 값이다.</p>
<p id="index-20">이 모든 것들은 제너레이터 함수를 코루틴과 아주 비슷하게 만든다; 여러 번 결과를 만들고, 하나 이상의 진입 지점을 갖고 있으며, 실행이 일시 중지될 수 있다. 유일한 차이점은 제너레이터 함수는 yield 한 후에 실행이 어디에서 계속되어야 하는지를 제어할 수 없다는 점이다; 제어는 항상 제너레이터의 호출자로 전달된다.</p>
<p>일드 표현식은 <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 구조물의 어디에서건 허락된다. 제너레이터가 (참조 횟수가 0이 되거나 가비지 수거됨으로써) 파이널라이즈(finalize)되기 전에 재개되지 않으면, 제너레이터-이터레이터의 <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 메서드가 호출되어, 대기 중인 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절이 실행되도록 허락한다.</p>
<p><code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> 이 사용될 때, 제공된 표현식을 서브 이터레이터(subiterator)로 취급한다. 서브 이터레이터가 만드는 모든 값은 현재 제너레이터 메서드의 호출자에게 바로 전달된다. <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> 로 전달된 모든 값과 <a class="reference internal" href="#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> 로 전달된 모든 예외는 밑에 있는(underlying) 이터레이터가 해당 메서드를 갖고 있다면 그곳으로 전달된다. 그렇지 않다면, <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> 는 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 나 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으키지만, <a class="reference internal" href="#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> 는 전달된 예외를 즉시 일으킨다.</p>
<p>밑에 있는 이러레이터가 완료될 때, 발생하는 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 인스턴스의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> 어트리뷰트는 일드 표현식의 값이 된다. <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 를 일으킬 때 명시적으로 설정되거나, 서브 이터레이터가 제너레이터일 경우는 자동으로 이루어진다 (서브 제너레이터가 값을 돌려(return)줌으로써).</p>
<blockquote>
<div><div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>서브 이터레이터로 제어 흐름을 위임하는 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> 를 추가했다.</p>
</div>
</div></blockquote>
<p>일드 표현식이 대입문의 우변에 홀로 나온다면 괄호를 생략할 수 있다.</p>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<dl class="last docutils">
<dt><span class="target" id="index-97"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0255"><strong>PEP 255</strong></a> - 간단한 제너레이터</dt>
<dd>파이썬에 제너레이터와 <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 문을 추가하는 제안.</dd>
<dt><span class="target" id="index-98"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0342"><strong>PEP 342</strong></a> - 개선된 제너레이터를 통한 코루틴</dt>
<dd>제너레이터의 API와 문법을 개선해서, 간단한 코루틴으로 사용할 수 있도록 만드는 제안.</dd>
<dt><span class="target" id="index-99"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0380"><strong>PEP 380</strong></a> - 서브 제너레이터로 위임하는 문법</dt>
<dd><code class="xref std std-token docutils literal notranslate"><span class="pre">yield_from</span></code> 문법을 도입해서, 서브 제너레이터로의 위임을 쉽게 만드는 제안.</dd>
</dl>
</div>
<div class="section" id="generator-iterator-methods">
<span id="generator-methods"></span><span id="index-24"></span><h4>6.2.9.1. 제너레이터-이터레이터 메서드<a class="headerlink" href="#generator-iterator-methods" title="永久链接至标题">¶</a></h4>
<p>이 서브섹션은 제너레이터 이터레이터의 메서드들을 설명한다. 제너레이터 함수의 실행을 제어하는데 사용될 수 있다.</p>
<p>제너레이터가 이미 실행 중일 때 아래에 나오는 메서드들을 호출하면 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 예외를 일으키는 것에 주의해야 한다.</p>
<span class="target" id="index-25"></span><dl class="method">
<dt id="generator.__next__">
<code class="descclassname">generator.</code><code class="descname">__next__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.__next__" title="永久链接至目标">¶</a></dt>
<dd><p>제너레이터 함수의 실행을 시작하거나 마지막으로 실행된 일드 표현식에서 재개한다. 제너레이터 함수가 <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 메서드로 재개될 때, 현재의 일드 표현식은 항상 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 값을 갖는다. 실행은 다음 일드 표현식까지 이어지는데, 그곳에서 제너레이터는 다시 일시 중지되고, <a class="reference internal" href="#grammar-token-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> 의 값을 <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 의 호출자에게 돌려준다. 제너레이터가 다른 값을 yield 하지 않고 종료되면 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 예외가 발생한다.</p>
<p>이 메서드는 보통 묵시적으로 호출된다, 예를 들어, <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 루프나 내장 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 함수에 의해.</p>
</dd></dl>

<dl class="method">
<dt id="generator.send">
<code class="descclassname">generator.</code><code class="descname">send</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#generator.send" title="永久链接至目标">¶</a></dt>
<dd><p>실행을 재개하고 제너레이터 함수로 값을 &quot;보낸다(send)&quot;. <em>value</em> 인자는 현재 일드 표현식의 값이 된다. <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> 메서드는 제너레이터가 yield 하는 다음 값을 돌려주거나, 제너레이터가 다른 값을 yield 하지 않고 종료하면 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 을 일으킨다. <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> 가 제너레이터를 시작시키도록 호출될 때, 값을 받을 일드 표현식이 없으므로, 인자로는 반드시 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 을 전달해야 한다.</p>
</dd></dl>

<dl class="method">
<dt id="generator.throw">
<code class="descclassname">generator.</code><code class="descname">throw</code><span class="sig-paren">(</span><em>type</em><span class="optional">[</span>, <em>value</em><span class="optional">[</span>, <em>traceback</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.throw" title="永久链接至目标">¶</a></dt>
<dd><p>제너레이터가 일시 정지한 지점에서 <code class="docutils literal notranslate"><span class="pre">type</span></code> 형의 예외를 일으키고, 제너레이터 함수가 yield 하는 다음 값을 돌려준다. 제너레이터가 다른 값을 yield 하지 않고 종료하면 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 을 일으킨다. 제너레이터가 전달된 예외를 잡지 않거나, 다른 예외를 일으키면, 그 예외는 호출자로 퍼진다.</p>
</dd></dl>

<span class="target" id="index-26"></span><dl class="method">
<dt id="generator.close">
<code class="descclassname">generator.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.close" title="永久链接至目标">¶</a></dt>
<dd><p>제너레이터가 일시 정지한 지점에서 <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> 를 일으킨다. 그런 다음 제너레이터 함수가 우아하게(gracefully) 종료하거나, 이미 닫혔거나, (그 예외를 잡지 않음으로써) <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> 를 일으키면 close는 호출자로 돌아간다. 제너레이터가 값을 yield 하면 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 가 발생한다. 제너레이터가 다른 예외를 일으키면, 호출자로 퍼진다. 제너레이터가 예외나 정상 종료로 인해 이미 종료되었다면, <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 는 아무런 일도 하지 않는다.</p>
</dd></dl>

</div>
<div class="section" id="examples">
<span id="index-27"></span><h4>6.2.9.2. 사용 예<a class="headerlink" href="#examples" title="永久链接至标题">¶</a></h4>
<p>여기에 제너레이터와 제너레이터 함수의 동작을 시연하는 간단한 예가 있다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Execution starts when &#39;next()&#39; is called for the first time.&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="n">e</span>
<span class="gp">... </span>    <span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Don&#39;t forget to clean up when &#39;close()&#39; is called.&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span> <span class="o">=</span> <span class="n">echo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
<span class="go">Execution starts when &#39;next()&#39; is called for the first time.</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">generator</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="s2">&quot;spam&quot;</span><span class="p">)</span>
<span class="go">TypeError(&#39;spam&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">Don&#39;t forget to clean up when &#39;close()&#39; is called.</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 을 사용하는 예는, &quot;What's New in Python.&quot; 에 있는 <a class="reference internal" href="../whatsnew/3.3.html#pep-380"><span class="std std-ref">PEP 380: Syntax for Delegating to a Subgenerator</span></a> 을 보면 된다.</p>
</div>
<div class="section" id="asynchronous-generator-functions">
<span id="id3"></span><h4>6.2.9.3. 비동기 제너레이터 함수<a class="headerlink" href="#asynchronous-generator-functions" title="永久链接至标题">¶</a></h4>
<p><a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 를 사용한 함수나 메서드에서 일드 표현식의 존재는 그 함수를 <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">비동기 제너레이터</span></a> 함수로 정의한다.</p>
<p>비동기 제너레이터 함수가 호출되면, 비동기 제너레이터 객체로 알려진 비동기 이터레이터를 돌려준다. 그런 다음 그 객체는 제너레이터 함수의 실행을 제어한다. 비동기 제너레이터 객체는 보통 코루틴 함수의 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 문에서 사용되는데, 제너레이터 객체가 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 문에서 사용되는 방식과 유사하다.</p>
<p>비동기 제너레이터의 메서드들 중 하나를 호출하면 <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a> 객체를 돌려주고, 이 객체를 await 할 때 실행이 시작된다. 그 시점에, 실행은 첫 번째 일드 표현식까지 진행한 후, 거기에서 다시 일시 중지(suspend)하고 await 중인 코루틴에게 <a class="reference internal" href="#grammar-token-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> 의 값을 돌려준다. 제너레이터에서처럼, 일시 중지된다는 것은, 모든 지역 상태가 보존된다는 뜻인데, 지역 변수들의 현재 연결들, 명령 포인터(instruction pointer), 내부 연산 스택(internal evaluation stack), 모든 예외 처리 상태가 포함된다. 비동기 제너레이터의 메서드가 돌려준 다음 객체를 await 해서 실행이 재개될 때, 함수는 마치 일드 표현식이 단지 또 하나의 외부 호출인 것처럼 진행할 수 있다. 재개된 후에 일드 표현식의 값은 실행을 재개하도록 만든 메서드에 달려있다. <a class="reference internal" href="#agen.__anext__" title="agen.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> 가 사용되었다면 결과는 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 이다. 그렇지 않고, <a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> 가 사용되었다면, 결과는 그 메서드로 전달된 값이다.</p>
<p>비동기 제너레이터 함수에서, 일드 표현식은 <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 구조물의 어디에서건 허락된다. 하지만, 비동기 제너레이터가 (참조 횟수가 0이 되거나 가비지 수거됨으로써) 파이널라이즈(finalize)되기 전에 재개되지 않으면, <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 구조물 내의 일드 표현식은 대기 중인 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절을 실행하는 데 실패할 수 있다. 이 경우에, 비동기 제너레이터-이터레이터의 <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> 를 호출하고, 그 결과로 오는 코루틴 객체를 실행해서, 대기 중인 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절이 실행되도록 하는 책임은, 비동기 제너레이터를 실행하는 이벤트 루프(event loop)나 스케쥴러(scheduler)에게 있다.</p>
<p>파이널리제이션을 처리하기 위해, 이벤트 루프는 <em>파이널라이저(finalizer)</em> 함수를 정의해야 하는데 비동기 제너레이터-이터레이터를 받아서 아마도 <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> 를 호출하고 그 코루틴을 실행한다. 이 <em>파이널라이저</em> 는 <a class="reference internal" href="../library/sys.html#sys.set_asyncgen_hooks" title="sys.set_asyncgen_hooks"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.set_asyncgen_hooks()</span></code></a> 을 호출해서 등록할 수 있다. 처음 탐색 될 때, 비동기 제너레이터-이터레이터는 파이널리제이션때 호출될 등록된 <em>파이널라이저</em> 를 저장할 것이다. <em>파이널라이저</em> 메서드의 참조할만한 예는 <a class="reference external" href="https://github.com/python/cpython/tree/3.6/Lib/asyncio/base_events.py">Lib/asyncio/base_events.py</a> 에 있는 <code class="docutils literal notranslate"><span class="pre">asyncio.Loop.shutdown_asyncgens</span></code> 구현을 보면 된다.</p>
<p>표현식 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> 를 비동기 제너레이터 함수에서 사용하는 것은 문법 에러다.</p>
</div>
<div class="section" id="asynchronous-generator-iterator-methods">
<span id="asynchronous-generator-methods"></span><span id="index-28"></span><h4>6.2.9.4. 비동기 제너레이터-이터레이터 메서드<a class="headerlink" href="#asynchronous-generator-iterator-methods" title="永久链接至标题">¶</a></h4>
<p>이 서브섹션은 비동기 제너레이터 이터레이터의 메서드를 설명하는데, 제너레이터 함수의 실행을 제어하는 데 사용된다.</p>
<span class="target" id="index-29"></span><dl class="method">
<dt id="agen.__anext__">
<em class="property">coroutine </em><code class="descclassname">agen.</code><code class="descname">__anext__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agen.__anext__" title="永久链接至目标">¶</a></dt>
<dd><p>어웨이터블을 돌려주는데, 실행하면 비동기 제너레이터 함수의 실행을 시작하거나 마지막으로 실행된 일드 표현식에서 재개한다. 비동기 제너레이터 함수가 <a class="reference internal" href="#agen.__anext__" title="agen.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> 메서드로 재개될 때, 반환된 어웨이터블에서 현재의 일드 표현식은 항상 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 값을 갖고 반환된 어웨이터블을 실행하면 다음 일드 표현식까지 이어진다. 일드 표현식의 <a class="reference internal" href="#grammar-token-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> 의 값은 종료하는 코루틴이 일으킨 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 의 값이다. 비동기 제너레이터가 다른 값을 yield 하지 않고 종료되면, 비동기 탐색의 종료를 알리기 위해 어웨이터블이 대신 <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 예외를 일으킨다.</p>
<p>이 메서드는 보통 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 루프에 의해 묵시적으로 호출된다.</p>
</dd></dl>

<dl class="method">
<dt id="agen.asend">
<em class="property">coroutine </em><code class="descclassname">agen.</code><code class="descname">asend</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#agen.asend" title="永久链接至目标">¶</a></dt>
<dd><p>어웨이터블을 돌려주는데, 실행하면 비동기 제너레이터의 실행을 재개한다. 제너레이터의 <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> 메서드 처럼, 이것은 값을 비동기 제너레이터 함수로 &quot;보내(send)&quot;고, <em>value</em> 인자는 현재 일드 표현식의 결과가 된다. <a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> 메서드가 돌려주는 어웨이터블은 제너레이터가 yield 하는 다음 값을 발생시킨 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 의 값으로 돌려주거나, 비동기 제너레이터가 다른 값을 yield 하지 않고 종료하면 <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 를 일으킨다. 비동기 제너레이터를 시작시키도록 <a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> 가 호출될 때, 값을 받을 일드 표현식이 없으므로 인자를 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 으로 호출해야 한다.</p>
</dd></dl>

<dl class="method">
<dt id="agen.athrow">
<em class="property">coroutine </em><code class="descclassname">agen.</code><code class="descname">athrow</code><span class="sig-paren">(</span><em>type</em><span class="optional">[</span>, <em>value</em><span class="optional">[</span>, <em>traceback</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#agen.athrow" title="永久链接至目标">¶</a></dt>
<dd><p>어웨이터블을 돌려주는데, 비동기 제너레이터가 일시 중지한 지점에 <code class="docutils literal notranslate"><span class="pre">type</span></code> 형의 예외를 일으키고, 제너레이터 함수가 yield 한 다음 값을 발생하는 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 예외의 값으로 돌려준다. 비동기 제너레이터가 다른 값을 yield 하지 않고 종료하면, 어웨이터블에 의해 <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 예외가 일어난다. 제너레이터 함수가 전달된 예외를 잡지 않거나, 다른 예외를 일으키면, 어웨이터블을 실행할 때 그 예외가 어웨이터블의 호출자에게 퍼진다.</p>
</dd></dl>

<span class="target" id="index-30"></span><dl class="method">
<dt id="agen.aclose">
<em class="property">coroutine </em><code class="descclassname">agen.</code><code class="descname">aclose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agen.aclose" title="永久链接至目标">¶</a></dt>
<dd><p>어웨이터블을 돌려주는데, 실행하면, 비동기 제너레이터 함수가 일시 정지한 지점으로 <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> 를 던진다. 만약 그 이후에 비동기 제너레이터 함수가 우아하게 (gracefully) 종료하거나, 이미 닫혔거나, (그 예외를 잡지 않음으로써) <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> 를 일으키면, 돌려준 어웨이터블은 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 예외를 일으킨다. 이어지는 비동기 제너레이터 호출이 돌려주는 추가의 어웨이터블들은 <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 예외를 일으킨다. 만약 비동기 제너레이터가 값을 yield 하면 어웨이터블에 의해 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 가 발생한다. 만약 비동기 제너레이터가 그 밖의 다른 예외를 일으키면, 어웨이터블의 호출자로 퍼진다. 만약 비동기 제너레이터가 예외나 정상 종료로 이미 종료했으면, 더 이어지는 <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> 호출은 아무것도 하지 않는 어웨이터블을 돌려준다.</p>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="primaries">
<span id="id4"></span><h2>6.3. 프라이머리<a class="headerlink" href="#primaries" title="永久链接至标题">¶</a></h2>
<p id="index-31">프라이머리는 언어에서 가장 강하게 결합하는 연산들을 나타낸다. 문법은 이렇다:</p>
<pre>
<strong id="grammar-token-primary">primary</strong> ::=  <a class="reference internal" href="#grammar-token-atom"><code class="xref docutils literal notranslate"><span class="pre">atom</span></code></a> | <a class="reference internal" href="#grammar-token-attributeref"><code class="xref docutils literal notranslate"><span class="pre">attributeref</span></code></a> | <a class="reference internal" href="#grammar-token-subscription"><code class="xref docutils literal notranslate"><span class="pre">subscription</span></code></a> | <a class="reference internal" href="#grammar-token-slicing"><code class="xref docutils literal notranslate"><span class="pre">slicing</span></code></a> | <a class="reference internal" href="#grammar-token-call"><code class="xref docutils literal notranslate"><span class="pre">call</span></code></a>
</pre>
<div class="section" id="attribute-references">
<span id="id5"></span><h3>6.3.1. 어트리뷰트 참조<a class="headerlink" href="#attribute-references" title="永久链接至标题">¶</a></h3>
<p id="index-32">어트리뷰트 참조는 마침표(period)와 이름이 뒤에 붙은 프라이머리다:</p>
<pre>
<strong id="grammar-token-attributeref">attributeref</strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;.&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
</pre>
<p id="index-33">프라이머리는 값을 구했을 때 어트리뷰트 참조를 지원하는 형의 객체가 나와야 하는데, 대부분 객체가 이 상황에 해당한다. 이 객체는 그 이름을 식별자로 하는 어트리뷰트를 생산하도록 요청받는다. 이 생산은 <a class="reference internal" href="datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 메서드를 재정의해서 커스터마이즈 할 수 있다. 이 어트리뷰트가 없으면, <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 을 일으킨다. 그렇지 않으면, 생산된 객체의 형과 값은 그 객체에 의해 결정된다. 같은 어트리뷰트 참조의 값을 여러 번 구하면 각기 다른 객체가 얻어질 수 있다.</p>
</div>
<div class="section" id="subscriptions">
<span id="id6"></span><h3>6.3.2. 서브스크립션(Subscriptions)<a class="headerlink" href="#subscriptions" title="永久链接至标题">¶</a></h3>
<span class="target" id="index-34"></span><p id="index-35">서브스크립션은 시퀀스(문자열, 튜플, 리스트)나 매핑 (딕셔너리) 객체의 항목을 선택한다:</p>
<pre>
<strong id="grammar-token-subscription">subscription</strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-expression_list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a> &quot;]&quot;
</pre>
<p>프라이머리는 값을 구했을 때 서브스크립션을 지원하는 객체가 나와야 한다 (예를 들어, 리스트나 딕셔너리). 사용자 정의 객체들은 <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 메서드를 구현해서 서브스크립션을 지원할 수 있다.</p>
<p>내장 객체들의 경우, 서브스크립션을 지원하는 두 가지 종류의 객체들이 있다:</p>
<p>프라이머리가 매핑이면, 표현식 목록은 값을 구했을 때 매핑의 키 중 하나가 되어야 하고, 서브스크립션은 매핑에서 그 키에 대응하는 값을 선택한다. (표현식 목록은 정확히 하나의 항목을 가지는 경우만을 제외하고는 튜플이다.)</p>
<p>프라이머리가 시퀀스면, 표현식(목록)은 값을 구했을 때 정수나 슬라이스(slice) (다음 섹션에서 논의한다)가 나와야 한다.</p>
<p>형식 문법은 시퀀스에서 음수 인덱스에 대해 특별히 규정하지 않는다; 하지만, 내장 시퀀스들은 모두 인덱스에 시퀀스의 길이를 더하는 것으로 음의 인덱스를 해석하는 <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 메서드를 제공한다 (그래서 <code class="docutils literal notranslate"><span class="pre">x[-1]</span></code> 은 <code class="docutils literal notranslate"><span class="pre">x</span></code> 의 마지막 항목을 선택한다). 결괏값은 반드시 시퀀스에 있는 항목들의 개수보다 작은 음이 아닌 정수가 되어야 하고, 서브스크립션은 인덱스가 그 값이 되는 항목을 선택한다 (0에서 부 터 센다). 음의 인덱스와 슬라이싱에 대한 지원이 객체의 <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 메서드에서 이루어지기 때문에, 이 메서드를 재정의하는 서브 클래스는 그 지원을 명시적으로 추가할 필요가 있다.</p>
<p id="index-36">문자열의 항목은 문자다. 문자는 별도의 데이터형이 아니고, 하나의 문자만을 가진 문자열이다.</p>
</div>
<div class="section" id="slicings">
<span id="id7"></span><h3>6.3.3. 슬라이싱(Slicings)<a class="headerlink" href="#slicings" title="永久链接至标题">¶</a></h3>
<span class="target" id="index-37"></span><p id="index-38">슬라이싱은 시퀀스 객체 (예를 들어, 문자열 튜플 리스트)에서 어떤 범위의 항목들을 선택한다. 슬라이싱은 표현식이나 대입의 타깃이나 <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> 문에 사용될 수 있다. 슬라이싱의 문법은 이렇다:</p>
<pre>
<strong id="grammar-token-slicing">slicing     </strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-slice_list"><code class="xref docutils literal notranslate"><span class="pre">slice_list</span></code></a> &quot;]&quot;
<strong id="grammar-token-slice_list">slice_list  </strong> ::=  <a class="reference internal" href="#grammar-token-slice_item"><code class="xref docutils literal notranslate"><span class="pre">slice_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-slice_item"><code class="xref docutils literal notranslate"><span class="pre">slice_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-slice_item">slice_item  </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | <a class="reference internal" href="#grammar-token-proper_slice"><code class="xref docutils literal notranslate"><span class="pre">proper_slice</span></code></a>
<strong id="grammar-token-proper_slice">proper_slice</strong> ::=  [<a class="reference internal" href="#grammar-token-lower_bound"><code class="xref docutils literal notranslate"><span class="pre">lower_bound</span></code></a>] &quot;:&quot; [<a class="reference internal" href="#grammar-token-upper_bound"><code class="xref docutils literal notranslate"><span class="pre">upper_bound</span></code></a>] [ &quot;:&quot; [<a class="reference internal" href="#grammar-token-stride"><code class="xref docutils literal notranslate"><span class="pre">stride</span></code></a>] ]
<strong id="grammar-token-lower_bound">lower_bound </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-upper_bound">upper_bound </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-stride">stride      </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>이 형식 문법에는 모호함이 있다: 표현식 목록처럼 보이는 것들은 모두 슬라이스 목록으로 보이기도 해서, 모든 서브스크립션이 슬라이싱으로 해석될 수도 있다. 문법을 더 복잡하게 만드는 대신, 이 경우에 서브스크립션으로 해석하는 것이 슬라이싱으로 해석하는 것에 우선한다고 정의하는 것으로 애매함을 제거한다 (이 경우는 슬라이스 목록이 고유한 슬라이스(proper slice) 를 하나도 포함하지 않을 때다).</p>
<p id="index-39">슬라이싱의 의미는 다음과 같다. 프라이머리가 (일반 서브스크립션과 같은 <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 메서드를 사용해서) 다음과 같이 슬라이스 목록으로부터 만들어지는 키로 인덱싱된다. 슬라이스 목록이 적어도 하나의 쉼표를 갖는다면, 키는 슬라이스 항목들의 변환을 포함하는 튜플이다; 그렇지 않으면 슬라이스 항목 하나의 변환이 키다. 표현식인 슬라이스 항목의 변환은 그 표현식이다. 고유한 슬라이스(proper slice)의 변환은 슬라이스 객체 (섹션 <a class="reference internal" href="datamodel.html#types"><span class="std std-ref">표준형 계층</span></a> 를 보라)인데, <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code> 어트리뷰트가 각각 <code class="docutils literal notranslate"><span class="pre">lower_bound</span></code>, <code class="docutils literal notranslate"><span class="pre">upper_bound</span></code>, <code class="docutils literal notranslate"><span class="pre">stride</span></code> 로 주어진 표현식이고, 빠진 표현식들을 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 채운다.</p>
</div>
<div class="section" id="calls">
<span id="index-40"></span><span id="id8"></span><h3>6.3.4. 호출<a class="headerlink" href="#calls" title="永久链接至标题">¶</a></h3>
<p>호출은 콜러블 객체 (예를 들어, <a class="reference internal" href="../glossary.html#term-function"><span class="xref std std-term">함수</span></a>) 를 빌 수도 있는 <a class="reference internal" href="../glossary.html#term-argument"><span class="xref std std-term">인자</span></a> 들의 목록으로 호출한다.</p>
<pre>
<strong id="grammar-token-call">call                </strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;(&quot; [<a class="reference internal" href="#grammar-token-argument_list"><code class="xref docutils literal notranslate"><span class="pre">argument_list</span></code></a> [&quot;,&quot;] | <a class="reference internal" href="#grammar-token-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>] &quot;)&quot;
<strong id="grammar-token-argument_list">argument_list       </strong> ::=  <a class="reference internal" href="#grammar-token-positional_arguments"><code class="xref docutils literal notranslate"><span class="pre">positional_arguments</span></code></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-starred_and_keywords"><code class="xref docutils literal notranslate"><span class="pre">starred_and_keywords</span></code></a>]
                            [&quot;,&quot; <a class="reference internal" href="#grammar-token-keywords_arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>]
                          | <a class="reference internal" href="#grammar-token-starred_and_keywords"><code class="xref docutils literal notranslate"><span class="pre">starred_and_keywords</span></code></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-keywords_arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>]
                          | <a class="reference internal" href="#grammar-token-keywords_arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>
<strong id="grammar-token-positional_arguments">positional_arguments</strong> ::=  [&quot;*&quot;] <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> (&quot;,&quot; [&quot;*&quot;] <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)*
<strong id="grammar-token-starred_and_keywords">starred_and_keywords</strong> ::=  (&quot;*&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | <a class="reference internal" href="#grammar-token-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a>)
                          (&quot;,&quot; &quot;*&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | &quot;,&quot; <a class="reference internal" href="#grammar-token-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a>)*
<strong id="grammar-token-keywords_arguments">keywords_arguments  </strong> ::=  (<a class="reference internal" href="#grammar-token-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a> | &quot;**&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)
                          (&quot;,&quot; <a class="reference internal" href="#grammar-token-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a> | &quot;,&quot; &quot;**&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)*
<strong id="grammar-token-keyword_item">keyword_item        </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> &quot;=&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>생략할 수 있는 마지막 쉼표가 위치나 키워드 인자 뒤에 나타날 수 있지만, 의미를 바꾸지 않는다.</p>
<p id="index-41">프라이머리의 값을 구하면 콜러블 객체 (사용자 정의 함수, 내장 함수, 내장 객체들의 메서드, 클래스 객체, 클래스 인스턴스의 메서드, <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> 메서드를 갖는 모든 객체가 콜러블이다) 가 나와야 한다. 모든 인자 표현식들은 호출을 시도하기 전에 값이 구해진다. 형식 <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">파라미터</span></a> 목록의 문법은 <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">함수 정의</span></a> 섹션을 참고하면 된다.</p>
<p>키워드 인자가 있으면, 먼저 다음과 같이 위치 인자로 변환된다. 먼저 형식 파라미터들의 채워지지 않은 슬롯들의 목록이 만들어진다. N 개의 위치 인자들이 있다면, 처음 N 개의 슬롯에 넣는다. 그다음, 각 키워드 인자마다, 식별자가 대응하는 슬롯을 결정하는 데 사용된다 (식별자가 첫 번째 형식 파라미터의 이름과 같으면, 첫 번째 슬롯은 사용되고, 이런 식으로 계속한다). 슬롯이 이미 채워졌으면, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 예외를 일으킨다. 그렇지 않으면 그 인자의 값을 슬롯에 채워 넣는다 (표현식이 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이라 할지라도, 슬롯을 채우게 된다). 모든 인자가 처리되었을 때, 아직 채워지지 않은 슬롯들을 함수 정의로부터 오는 대응하는 기본값들로 채운다. (기본값들은 함수가 정의될 때 한 번만 값을 구한다; 그래서, 리스트나 딕셔너리 같은 가변객체들이 기본값으로 사용되면 해당 슬롯에 인자값을 지정하지 않은 모든 호출에서 공유된다; 보통 이런 상황은 피해야 할 일이다.) 만약 기본값이 지정되지 않고, 아직도 비어있는 슬롯이 남아있다면, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 예외가 발생한다. 그렇지 않으면, 채워진 슬롯의 목록이 호출의 인자 목록으로 사용된다.</p>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> 구현은 위치 파라미터가 이름을 갖지 않아서, 설사 문서화의 목적으로 이름이 붙여졌다 하더라도, 키워드로 공급될 수 없는 내장 함수들을 제공할 수 있다. CPython 에서, 인자들을 파싱하기 위해 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> 를 사용하는 C로 구현된 함수들이 이 경우다.</p>
</div>
<p>형식 파라미터 슬롯들보다 많은 위치 인자들이 있으면, <code class="docutils literal notranslate"><span class="pre">*identifier</span></code> 문법을 사용하는 형식 파라미터가 있지 않은 한, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 예외를 일으킨다; 이 경우, 그 형식 파라미터는 남는 위치 인자들을 포함하는 튜플을 전달받는다 (또는 남는 위치 인자들이 없으면 빈 튜플).</p>
<p>키워드 인자가 형식 파라미터 이름에 대응하지 않으면, <code class="docutils literal notranslate"><span class="pre">**identifier</span></code> 문법을 사용하는 형식 파라미터가 있지 않은 한, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 예외를 일으킨다; 이 경우, 그 형식 파라미터는 남는 키워드 인자들을 포함하는 딕셔너리나, 남는 위치기반 인자들이 없으면 빈 (새) 딕셔너리를 전달받는다.</p>
<p id="index-42">문법 <code class="docutils literal notranslate"><span class="pre">*expression</span></code> 이 함수 호출에 등장하면, <code class="docutils literal notranslate"><span class="pre">expression</span></code> 의 값은 <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">이터러블</span></a> 이 되어야 한다. 이 이터러블의 요소들은, 그것들이 추가의 위치 인자들인 것처럼 취급된다. 호출 <code class="docutils literal notranslate"><span class="pre">f(x1,</span> <span class="pre">x2,</span> <span class="pre">*y,</span> <span class="pre">x3,</span> <span class="pre">x4)</span></code> 의 경우, <em>y</em> 의 값을 구할 때 시퀀스 <em>y1</em>, ..., <em>yM</em> 이 나온다면, 이것은 M+4개의 위치 인자들 <em>x1</em>, <em>x2</em>, <em>y1</em>, ..., <em>yM</em>, <em>x3</em>, <em>x4</em> 로 호출하는 것과 동등하다.</p>
<p>이로 인한 결과는 설사 <code class="docutils literal notranslate"><span class="pre">*expression</span></code> 문법이 명시적인 키워드 인자 <em>뒤에</em> 나올 수는 있어도, 키워드 인자 (그리고 모든 <code class="docutils literal notranslate"><span class="pre">**expression</span></code> 인자들 -- 아래를 보라) <em>전에</em> 처리된다는 것이다. 그래서:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">2 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">f() got multiple values for keyword argument &#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">1 2</span>
</pre></div>
</div>
<p>같은 호출에서 키워드 인자와 <code class="docutils literal notranslate"><span class="pre">*expression</span></code> 문법을 모두 사용하는 것은 일반적이지 않기 때문에, 실제로는 이런 혼란이 일어나지 않는다.</p>
<p id="index-43">문법 <code class="docutils literal notranslate"><span class="pre">**expression</span></code> 이 함수 호출에 등장하면, <code class="docutils literal notranslate"><span class="pre">expression</span></code> 의 값은 <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">매핑</span></a> 이 되어야 한다, 그 내용이 추가의 키워드 인자인 것처럼 취급된다. 키워드가 (명시적인 키워드 인자나 다른 언 패킹으로부터) 이미 존재한다면 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 예외가 발생한다.</p>
<p>문법 <code class="docutils literal notranslate"><span class="pre">*identifier</span></code> 이나 <code class="docutils literal notranslate"><span class="pre">**identifier</span></code> 를 사용하는 형식 파라미터들은 위치 인자 슬롯이나 키워드 인자 아름들로 사용될 수 없다.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.5 版更改: </span>함수 호출은 임의의 개수의 <code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">**</span></code> 언 패킹을 받아들이고, 위치 인자들이 이터러블 언 패킹 (<code class="docutils literal notranslate"><span class="pre">*</span></code>) 뒤에 올 수 있고, 키워드 인자가 딕셔너리 언 패킹 (<code class="docutils literal notranslate"><span class="pre">**</span></code>) 뒤에 올 수 있다. 최초로 <span class="target" id="index-100"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0448"><strong>PEP 448</strong></a> 에서 제안되었다.</p>
</div>
<p>호출은 예외를 일으키지 않는 한, 항상 어떤 값을 돌려준다, <code class="docutils literal notranslate"><span class="pre">None</span></code> 일 수 있다. 이 값이 어떻게 계산되는지는 콜러블 객체의 형에 달려있다.</p>
<p>만약 그것이---</p>
<dl class="docutils">
<dt>사용자 정의 함수면:</dt>
<dd><p class="first last" id="index-45">인자 목록을 전달해서 함수의 코드 블록이 실행된다. 코드 블록이 처음으로 하는 일은 형식 파라미터들을 인자에 결합하는 것이다; 이것은 섹션 <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">함수 정의</span></a> 에서 설명한다. 코드 블록이 <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 문을 실행하면, 함수 호출의 반환 값을 지정하게 된다.</p>
</dd>
<dt>내장 함수나 메서드면:</dt>
<dd><p class="first last" id="index-46">결과는 인터프리터에 달려있다; 내장 함수와 메서드들에 대한 설명은 <a class="reference internal" href="../library/functions.html#built-in-funcs"><span class="std std-ref">내장 함수</span></a> 를 보면 된다.</p>
</dd>
<dt>클래스 객체면:</dt>
<dd><p class="first last" id="index-47">그 클래스의 새 인스턴스가 반환된다.</p>
</dd>
<dt>클래스 인스턴스 메서드면:</dt>
<dd><p class="first last" id="index-48">대응하는 사용자 정의 함수가 호출되는데, 그 인스턴스가 첫 번째 인자가 되는 하나만큼 더 긴 인자 목록이 전달된다.</p>
</dd>
<dt>클래스 인스턴스면:</dt>
<dd><p class="first last" id="index-49">그 클래스는 <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> 메서드를 정의해야 한다; 그 효과는 그 메서드가 호출되는 것과 같다.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="await-expression">
<span id="await"></span><h2>6.4. 어웨이트 표현식<a class="headerlink" href="#await-expression" title="永久链接至标题">¶</a></h2>
<p><a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a> 에서 <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">코루틴</span></a> 의 실행을 일시 중지한다. 오직 <a class="reference internal" href="../glossary.html#term-coroutine-function"><span class="xref std std-term">코루틴 함수</span></a> 에서만 사용할 수 있다.</p>
<pre>
<strong id="grammar-token-await_expr">await_expr</strong> ::=  &quot;await&quot; <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a>
</pre>
<div class="versionadded">
<p><span class="versionmodified">3.5 新版功能.</span></p>
</div>
</div>
<div class="section" id="the-power-operator">
<span id="power"></span><h2>6.5. 거듭제곱 연산자<a class="headerlink" href="#the-power-operator" title="永久链接至标题">¶</a></h2>
<p>거듭제곱 연산자는 그것의 왼쪽에 붙는 일 항 연산자보다 더 강하게 결합한다; 그것의 오른쪽에 붙는 일 항 연산자보다는 약하게 결합한다. 문법은 이렇다:</p>
<pre>
<strong id="grammar-token-power">power</strong> ::=  ( <a class="reference internal" href="#grammar-token-await_expr"><code class="xref docutils literal notranslate"><span class="pre">await_expr</span></code></a> | <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> ) [&quot;**&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>]
</pre>
<p>그래서, 괄호가 없는 거듭제곱과 일 항 연산자의 시퀀스에서, 연산자는 오른쪽에서 왼쪽으로 값이 구해진다 (이것이 피연산자의 값을 구하는 순서를 제약하는 것은 아니다): <code class="docutils literal notranslate"><span class="pre">-1**2</span></code> 은 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 이 된다.</p>
<p>거듭제곱 연산자는 내장 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> 함수가 두 개의 인자로 호출될 때와 같은 의미가 있다: 왼쪽 인자를 오른쪽 인자만큼 거듭제곱한 값을 준다. 숫자 인자는 먼저 공통 형으로 변환되고, 결과는 그 형이다.</p>
<p>int 피연산자의 경우, 두 번째 인자가 음수가 아닌 이상 결과는 피연산자들과 같은 형을 갖는다; 두 번째 인자가 음수면, 모든 인자는 float로 변환되고, float 결과가 전달된다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">10**2</span></code> 는 <code class="docutils literal notranslate"><span class="pre">100</span></code> 를 돌려주지만, <code class="docutils literal notranslate"><span class="pre">10**-2</span></code> 는 <code class="docutils literal notranslate"><span class="pre">0.01</span></code> 를 돌려준다.</p>
<p><code class="docutils literal notranslate"><span class="pre">0.0</span></code> 를 음수로 거듭제곱하면 <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a> 를 일으킨다. 음수를 분수로 거듭제곱하면 복소수(<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>)가 나온다. (예전 버전에서는 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 를 일으켰다.)</p>
</div>
<div class="section" id="unary-arithmetic-and-bitwise-operations">
<span id="unary"></span><h2>6.6. 일 항 산술과 비트 연산<a class="headerlink" href="#unary-arithmetic-and-bitwise-operations" title="永久链接至标题">¶</a></h2>
<p id="index-50">모든 일 항 산술과 비트 연산자는 같은 우선순위를 갖는다.</p>
<pre>
<strong id="grammar-token-u_expr">u_expr</strong> ::=  <a class="reference internal" href="#grammar-token-power"><code class="xref docutils literal notranslate"><span class="pre">power</span></code></a> | &quot;-&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | &quot;+&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | &quot;~&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>
</pre>
<p id="index-51">일 항 <code class="docutils literal notranslate"><span class="pre">-</span></code> (마이너스) 연산자는 그 숫자 인자의 음의 값을 준다.</p>
<p id="index-52">일 항 <code class="docutils literal notranslate"><span class="pre">+</span></code> (플러스) 연산자는 그 숫자 인자의 값을 변경 없이 준다.</p>
<p id="index-53">일 항 <code class="docutils literal notranslate"><span class="pre">~</span></code> (인버트) 연산자는 그 정수 인자의 비트 반전된 값을 준다. <code class="docutils literal notranslate"><span class="pre">x</span></code> 의 비트 반전은 <code class="docutils literal notranslate"><span class="pre">-(x+1)</span></code> 로 정의된다. 오직 정수에만 적용된다.</p>
<p id="index-54">세 가지 경우 모두, 인자가 올바른 형을 갖지 않는다면, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 예외가 발생한다.</p>
</div>
<div class="section" id="binary-arithmetic-operations">
<span id="binary"></span><h2>6.7. 이항 산술 연산<a class="headerlink" href="#binary-arithmetic-operations" title="永久链接至标题">¶</a></h2>
<p id="index-55">이항 산술 연산자는 관습적인 우선순위를 갖는다. 이 연산자 중 일부는 일부 비 숫자 형에도 적용됨에 주의해야 한다. 거듭제곱 연산자와는 별개로, 오직 두 가지 수준만 있는데, 하나는 곱셈형 연산자들이고, 하나는 덧셈형 연산자들이다.</p>
<pre>
<strong id="grammar-token-m_expr">m_expr</strong> ::=  <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;*&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;&#64;&quot; <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> |
            <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;//&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>| <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;/&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> |
            <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;%&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>
<strong id="grammar-token-a_expr">a_expr</strong> ::=  <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="#grammar-token-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> &quot;+&quot; <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="#grammar-token-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> &quot;-&quot; <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a>
</pre>
<p id="index-56"><code class="docutils literal notranslate"><span class="pre">*</span></code> (곱셈) 연산자는 인자들의 곱을 준다. 인자들은 모두 숫자거나, 한 인자는 정수고 다른 인자는 시퀀스여야 한다. 앞의 경우에, 숫자들은 공통 형으로 변환된 후 곱해진다. 후자의 경우, 시퀀스의 반복이 수행된다; 음의 반복 값은 빈 시퀀스를 만든다.</p>
<p id="index-57"><code class="docutils literal notranslate"><span class="pre">&#64;</span></code> (at) 연산자는 행렬 곱셈에 사용하려는 것이다. 파이썬의 내장형들 어느 것도 이 연산자를 구현하지 않는다.</p>
<div class="versionadded">
<p><span class="versionmodified">3.5 新版功能.</span></p>
</div>
<p id="index-58"><code class="docutils literal notranslate"><span class="pre">/</span></code> (나눗셈)과 <code class="docutils literal notranslate"><span class="pre">//</span></code> (정수 나눗셈, floor division) 연산자들은 그 인자들의 몫(quotient)을 준다. 숫자 인자들은 먼저 공통형으로 변환된다. 정수들의 나눗셈은 실수를 만드는 반면, 정수들의 정수 나눗셈은 정숫값을 준다; 그 결과는 수학적인 나눗셈의 결과에 'floor' 함수를 적용한 것이다. 0으로 나누는 것은 <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a> 예외를 일으킨다.</p>
<p id="index-59"><code class="docutils literal notranslate"><span class="pre">%</span></code> (모듈로, modulo) 연산자는 첫 번째 인자를 두 번째 인자로 나눈 나머지를 준다. 숫자 인자들은 먼저 공통형으로 변환된다. 오른쪽 인자가 0이면 <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a> 예외를 일으킨다. 인자들은 실수가 될 수 있다, 예를 들어, <code class="docutils literal notranslate"><span class="pre">3.14%0.7</span></code> 는 <code class="docutils literal notranslate"><span class="pre">0.34</span></code> 와 같다 (<code class="docutils literal notranslate"><span class="pre">3.14</span></code> 가 <code class="docutils literal notranslate"><span class="pre">4*0.7</span> <span class="pre">+</span> <span class="pre">0.34</span></code> 와 같으므로.) 모듈로 연산자는 항상 두 번째 피연산자와 같은 부호를 갖는 결과를 준다 (또는 0이다); 결과의 절댓값은 두 번째 피연산자의 절댓값보다 작다 <a class="footnote-reference" href="#id17" id="id9">[1]</a>.</p>
<p>정수 나눗셈과 모듈로 연산자는 다음과 같은 항등식으로 연결되어 있다: <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x//y)*y</span> <span class="pre">+</span> <span class="pre">(x%y)</span></code>. 정수 나눗셈과 모듈로는 내장 함수 <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a> 와도 연결되어 있다: <code class="docutils literal notranslate"><span class="pre">divmod(x,</span> <span class="pre">y)</span> <span class="pre">==</span> <span class="pre">(x//y,</span> <span class="pre">x%y)</span></code>. <a class="footnote-reference" href="#id18" id="id10">[2]</a>.</p>
<p>숫자들에 대해 모듈로 연산을 수행하는 것에 더해, <code class="docutils literal notranslate"><span class="pre">%</span></code> 연산자는 예전 스타일의 문자열 포매팅 (인터폴레이션이라고도 알려져 있다)을 수행하기 위해 문자열 객체에 의해 다시 정의된다. 문자열 포매팅의 문법은 파이썬 라이브러리 레퍼런스의 섹션 <a class="reference internal" href="../library/stdtypes.html#old-string-formatting"><span class="std std-ref">printf-style String Formatting</span></a> 에서 설명한다.</p>
<p>정수 나눗셈 연산자, 모듈로 연산자, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a> 함수는 복소수에 대해서는 정의되어 있지 않다. 대신, 적절하다면, <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a> 함수를 사용해서 실수로 변환하라.</p>
<p id="index-60"><code class="docutils literal notranslate"><span class="pre">+</span></code> (덧셈) 연산자는 그 인자들의 합을 준다. 인자들은 둘 다 숫자거나, 둘 다 같은 형의 시퀀스여야 한다. 앞의 경우, 숫자들은 먼저 공통형으로 변환된 후, 함께 합쳐진다. 후자의 경우 시퀀스는 이어붙이게 된다.</p>
<p id="index-61"><code class="docutils literal notranslate"><span class="pre">-</span></code> (빼기) 연산자는 그 인자들의 차를 준다. 숫자 인자들은 먼저 공통형으로 변환된다.</p>
</div>
<div class="section" id="shifting-operations">
<span id="shifting"></span><h2>6.8. 시프트 연산<a class="headerlink" href="#shifting-operations" title="永久链接至标题">¶</a></h2>
<p id="index-62">시프트 연산은 산술 연산보다 낮은 우선순위를 갖는다.</p>
<pre>
<strong id="grammar-token-shift_expr">shift_expr</strong> ::=  <a class="reference internal" href="#grammar-token-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> | <a class="reference internal" href="#grammar-token-shift_expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a> ( &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; ) <a class="reference internal" href="#grammar-token-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a>
</pre>
<p>이 연산들은 정수들을 인자로 받아들인다. 첫 번째 인자를 두 번째 인자로 주어진 비트 수만큼 왼쪽이나 오른쪽으로 민(shift)다.</p>
<p id="index-63">오른쪽으로 <em>n</em> 비트 시프트 하는 것은 <code class="docutils literal notranslate"><span class="pre">pow(2,n)</span></code> 로 정수 나눗셈하는 것으로 정의된다. 왼쪽으로 <em>n</em> 비트 시프트 하는 것은 <code class="docutils literal notranslate"><span class="pre">pow(2,n)</span></code> 를 곱하는 것으로 정의된다.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">현재 구현에서, 우측 피연산자는 최대 <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a> 일 것이 요구된다. 우측 피연산자가 <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a> 보다 크면 <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> 예외가 발생한다.</p>
</div>
</div>
<div class="section" id="binary-bitwise-operations">
<span id="bitwise"></span><h2>6.9. 이항 비트 연산<a class="headerlink" href="#binary-bitwise-operations" title="永久链接至标题">¶</a></h2>
<p id="index-64">세 개의 비트 연산은 각기 다른 우선순위를 갖는다:</p>
<pre>
<strong id="grammar-token-and_expr">and_expr</strong> ::=  <a class="reference internal" href="#grammar-token-shift_expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a> | <a class="reference internal" href="#grammar-token-and_expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a> &quot;&amp;&quot; <a class="reference internal" href="#grammar-token-shift_expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a>
<strong id="grammar-token-xor_expr">xor_expr</strong> ::=  <a class="reference internal" href="#grammar-token-and_expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a> | <a class="reference internal" href="#grammar-token-xor_expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a> &quot;^&quot; <a class="reference internal" href="#grammar-token-and_expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a>
<strong id="grammar-token-or_expr">or_expr </strong> ::=  <a class="reference internal" href="#grammar-token-xor_expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a> | <a class="reference internal" href="#grammar-token-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a> &quot;|&quot; <a class="reference internal" href="#grammar-token-xor_expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a>
</pre>
<p id="index-65"><code class="docutils literal notranslate"><span class="pre">&amp;</span></code> 연산자는 그 인자들의 비트별 AND를 주는데, 인자들은 정수여야 한다.</p>
<p id="index-66"><code class="docutils literal notranslate"><span class="pre">^</span></code> 연산자는 그 인자들의 비트별 XOR (배타적 OR)를 주는데, 인자들은 정수여야 한다.</p>
<p id="index-67"><code class="docutils literal notranslate"><span class="pre">|</span></code> 연산자는 그 인자들의 비트별 (포함적, inclusive) OR를 주는데, 인자들은 정수여야 한다.</p>
</div>
<div class="section" id="comparisons">
<span id="id11"></span><h2>6.10. 비교<a class="headerlink" href="#comparisons" title="永久链接至标题">¶</a></h2>
<span class="target" id="index-68"></span><p id="index-69">C와는 달리, 파이썬에서 모든 비교 연산은 같은 우선순위를 갖는데, 산술, 시프팅, 비트 연산들보다 낮다. 또한, C와는 달리, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">c</span></code> 와 같은 표현식이 수학에서와 같은 방식으로 해석된다.</p>
<pre>
<strong id="grammar-token-comparison">comparison   </strong> ::=  <a class="reference internal" href="#grammar-token-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a> ( <a class="reference internal" href="#grammar-token-comp_operator"><code class="xref docutils literal notranslate"><span class="pre">comp_operator</span></code></a> <a class="reference internal" href="#grammar-token-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a> )*
<strong id="grammar-token-comp_operator">comp_operator</strong> ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;==&quot; | &quot;&gt;=&quot; | &quot;&lt;=&quot; | &quot;!=&quot;
                   | &quot;is&quot; [&quot;not&quot;] | [&quot;not&quot;] &quot;in&quot;
</pre>
<p>비교는 논리값을 준다: <code class="docutils literal notranslate"><span class="pre">True</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">False</span></code></p>
<p id="index-70">비교는 자유롭게 연결될 수 있다, 예를 들어, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> 와 동등한데, 차이점은 <code class="docutils literal notranslate"><span class="pre">y</span></code> 의 값을 오직 한 번만 구한다는 것이다 (하지만 두 경우 모두 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> 가 거짓이면 <code class="docutils literal notranslate"><span class="pre">z</span></code> 의 값은 구하지 않는다).</p>
<p>형식적으로, <em>a</em>, <em>b</em>, <em>c</em>, ..., <em>y</em>, <em>z</em> 가 표현식이고, <em>op1</em>, <em>op2</em>, ..., <em>opN</em> 가 비교 연산자면, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code> 는 각 표현식의 값을 최대 한 번만 구한다는 점을 제외하고는 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">and</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">and</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code> 와 동등하다.</p>
<p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span></code> 가 <em>a</em> 와 <em>c</em> 간의 어떤 종류의 비교도 암시하지 않기 때문에, 예를 들어, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> 이 완벽하게 (아마 이쁘지는 않더라도) 올바르다는 것에 주의해야 한다.</p>
<div class="section" id="value-comparisons">
<h3>6.10.1. 값 비교<a class="headerlink" href="#value-comparisons" title="永久链接至标题">¶</a></h3>
<p>연산자 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code> 는 두 객체의 값을 비교한다. 객체들이 같은 형일 필요는 없다.</p>
<p><a class="reference internal" href="datamodel.html#objects"><span class="std std-ref">객체, 값, 형</span></a> 장은 객체들이 (형과 아이덴티티에 더해) 값을 갖는다고 말하고 있다. 파이썬에서 객체의 값은 좀 추상적인 개념이다: 예를 들어, 객체의 값에 대한 규범적인(canonical) 액세스 방법은 없다. 또한, 객체의 값이 특별한 방식(예를 들어, 모든 데이터 어트리뷰트로 구성되는 것)으로 구성되어야 한다는 요구 사항도 없다. 비교 연산자는 객체의 값이 무엇인지에 대한 특정한 종류의 개념을 구현한다. 객체의 값을 비교를 통해 간접적으로 정의한다고 생각해도 좋다.</p>
<p>모든 형은 (직접적 혹은 간접적으로) <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 의 서브 형이기 때문에, 그들은 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 로 부터 기본 비교 동작을 계승한다. 형들은 <a class="reference internal" href="datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> 와 같은 풍부한 비교 메서드(<em class="dfn">rich comparison methods</em>) 를 구현해서 자신의 비교 동작을 커스터마이즈할 수 있는데, <a class="reference internal" href="datamodel.html#customization"><span class="std std-ref">기본적인 커스터마이제이션</span></a> 에서 설명된다.</p>
<p>동등 비교 (<code class="docutils literal notranslate"><span class="pre">==</span></code> 와 <code class="docutils literal notranslate"><span class="pre">!=</span></code>) 의 기본 동작은 객체의 아이덴티티에 기반을 둔다. 그래서, 같은 아이덴티티를 갖는 인스턴스 간의 동등 비교는 같음을 주고, 다른 아이덴티티를 갖는 인스턴스 간의 동등 비교는 다름을 준다. 이 기본 동작의 동기는 모든 객체가 반사적(reflexive) (즉, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> 를 암시한다) 이도록 만들고자 하는 욕구다.</p>
<p>기본 대소 비교(order comparison) (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>) 는 제공되지 않는다; 시도하면 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으킨다. 이 기본 동작의 동기는 동등함과 유사한 항등 관계가 없다는 것이다.</p>
<p>다른 아이덴티티를 갖는 인스턴스들이 항상 서로 다르다는, 기본 동등 비교의 동작은, 객체의 값과 값 기반의 동등함에 대한 나름의 정의를 가진 형들이 필요로 하는 것과는 크게 다를 수 있다. 그런 형들은 자신의 비교 동작을 커스터마이즈 할 필요가 있고, 사실 많은 내장형이 그렇게 하고 있다.</p>
<p>다음 목록은 가장 중요한 내장형들의 비교 동작을 기술한다.</p>
<ul>
<li><p class="first">내장 숫자 형 ((<a class="reference internal" href="../library/stdtypes.html#typesnumeric"><span class="std std-ref">Numeric Types --- int, float, complex</span></a>)) 과 표준 라이브러리 형 <a class="reference internal" href="../library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a> 과 <a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a> 에 속하는 숫자들은, 복소수가 대소 비교를 지원하지 않는다는 제약 사항만 빼고는, 같거나 다른 형들 간의 비교가 가능하다. 관련된 형들의 한계 안에서, 정밀도의 손실 없이 수학적으로 (알고리즘 적으로) 올바르게 비교한다.</p>
<p>NaN(not-a-number) 값들 <code class="xref py py-const docutils literal notranslate"><span class="pre">float('NaN')</span></code> 과 <code class="xref py py-const docutils literal notranslate"><span class="pre">Decimal('NaN')</span></code> 은 특별하다. 이것들은 자기 자신과 같은 객체지만 (<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">x</span></code> 는 참이다), 자기 자신과 같지는 않다 (<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">x</span></code> 는 거짓이다.). 추가로, 어떤 숫자건 NaN 값과 비교하면 <code class="docutils literal notranslate"><span class="pre">False</span></code> 를 돌려준다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">&lt;</span> <span class="pre">float('NaN')</span></code> 과 <code class="docutils literal notranslate"><span class="pre">float('NaN')</span> <span class="pre">&lt;</span> <span class="pre">3</span></code> 모두 <code class="docutils literal notranslate"><span class="pre">False</span></code> 를 돌려준다.</p>
</li>
<li><p class="first">바이너리 시퀀스들 (<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 나 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 의 인스턴스들)은 형을 건너 상호 비교될 수 있다. 이것들은 요소들의 숫자 값을 사용해서 사전식으로(lexicographically) 비교한다.</p>
</li>
<li><p class="first">문자열들 (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 의 인스턴스들) 은 문자들의 유니코드 코드 포인트(Unicode code points) (내장 함수 <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a> 의 결과)를 사용해서 사전식으로 비교한다. <a class="footnote-reference" href="#id19" id="id12">[3]</a></p>
<p>문자열과 바이너리 시퀀스는 직접 비교할 수 없다.</p>
</li>
<li><p class="first">시퀀스들 (<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a> 의 인스턴스들)은 같은 형끼리 비교될 수 있는데, range는 대소 비교를 지원하지 않는다. 서로 다른 형들 간의 동등 비교는 다름을 주고, 서로 다른 형들 간의 대소 비교는 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으킨다.</p>
<p>시퀀스는 대응하는 요소 간의 비교를 사용해서 사전적으로 비교하는데, 요소들의 반사성(reflexivity)이 강제된다.</p>
<p>요소들의 반사성을 강제한다는 것은, 컬렉션의 비교가 컬렉션 요소 <code class="docutils literal notranslate"><span class="pre">x</span></code> 에 대해, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">x</span></code> 가 항상 참이라고 가정한다는 것이다. 그 가정에 기반을 둬서, 요소들의 아이덴티티가 먼저 비교된 후에, 이것이 다를 때만 요소 간의 동등 비교가 수행된다. 비교되는 요소들이 반사적일 때, 이런 접근법은 엄밀한 요소 간 비교와 같은 결과를 준다. 비 반사적인 요소의 경우, 결과가 엄밀한 요소 비교와 달라질 수 있고, 놀랄 수 있다: 예를 들어, 비 반사적인 NaN이 리스트에서 사용될 때 다음과 같은 비교 동작을 보인다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nan</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nan</span> <span class="ow">is</span> <span class="n">nan</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nan</span> <span class="o">==</span> <span class="n">nan</span>
<span class="go">False                 &lt;-- the defined non-reflexive behavior of NaN</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">nan</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="n">nan</span><span class="p">]</span>
<span class="go">True                  &lt;-- list enforces reflexivity and tests identity first</span>
</pre></div>
</div>
<p>내장 컬렉션들의 사전적인 비교는 다음과 같이 이루어진다:</p>
<ul class="simple">
<li>두 컬렉션이 같다고 비교되기 위해서는, 같은 형이고, 길이가 같고, 대응하는 요소들의 각 쌍이 같다고 비교되어야 한다 (예를 들어, <code class="docutils literal notranslate"><span class="pre">[1,2]</span> <span class="pre">==</span> <span class="pre">(1,2)</span></code> 는 거짓인데, 형이 다르기 때문이다).</li>
<li>대소 비교를 지원하는 컬렉션들은 첫 번째로 다른 요소들과 같은 순서를 준다 (예를 들어, <code class="docutils literal notranslate"><span class="pre">[1,2,x]</span> <span class="pre">&lt;=</span> <span class="pre">[1,2,y]</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> 와 같은 값이다). 대응하는 요소가 없는 경우 더 짧은 컬렉션이 작다고 비교된다 (예를 들어, <code class="docutils literal notranslate"><span class="pre">[1,2]</span> <span class="pre">&lt;</span> <span class="pre">[1,2,3]</span></code> 은 참이다).</li>
</ul>
</li>
<li><p class="first">매핑들 (<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 의 인스턴스들) 은 같은 <cite>(key, value)</cite> 쌍들을 가질 때, 그리고 오직 이 경우만 같다고 비교된다. 키와 값의 동등 비교는 반사성을 강제한다.</p>
<p>대소 비교 (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>) 는 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으킨다.</p>
</li>
<li><p class="first">집합들 (<a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 이나 <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> 의 인스턴스들)은 같은 형들과 서로 다른 형들 간에 비교될 수 있다.</p>
<p>이것들은 부분집합(subset)과 상위집합(superset)을 뜻하는 대소비교 연산자들을 정의한다. 이 관계는 전 순서(total ordering)를 정의하지 않는다 (예를 들어, 두 집합 <code class="docutils literal notranslate"><span class="pre">{1,2}</span></code> 와 <code class="docutils literal notranslate"><span class="pre">{2,3}</span></code> 는 다르면서도, 하나가 다른 하나의 부분집합이지도, 하나가 다른 하나의 상위집합이지도 않다). 따라서, 전 순서에 의존하는 함수의 인자로는 적합하지 않다 (예를 들어, <a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> 에 입력으로 집합의 리스트를 제공하면 정의되지 않은 결과를 준다).</p>
<p>집합의 비교는 그 요소들의 반사성을 강제한다.</p>
</li>
<li><p class="first">대부분의 다른 내장형들은 비교 메서드들을 구현하지 않기 때문에, 기본 비교 동작을 계승한다.</p>
</li>
</ul>
<p>비교 동작을 커스터마이즈하는 사용자 정의 클래스들은 가능하다면 몇 가지 일관성 규칙을 준수해야 한다:</p>
<ul>
<li><p class="first">동등 비교는 반사적(reflexive)이어야 한다. 다른 말로 표현하면, 아이덴티티가 같은 객체는 같다고 비교되어야 한다:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> 면 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> 다.</p>
</div></blockquote>
</li>
<li><p class="first">비교는 대칭적(symmetric)이어야 한다. 다른 말로 표현하면, 다음과 같은 표현식은 같은 결과를 주어야 한다:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> 와 <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">==</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code> 와 <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">!=</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> 와 <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> 와 <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&gt;=</span> <span class="pre">x</span></code></p>
</div></blockquote>
</li>
<li><p class="first">비교는 추이적(transitive)이어야 한다. 다음 (철저하지 않은) 예들이 이것을 예증한다:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> 면 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> 다</p>
<p>x &lt; y and y &lt;= z`` 면 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">z</span></code> 다</p>
</div></blockquote>
</li>
<li><p class="first">역 비교는 논리적 부정이 되어야 한다. 다른 말로 표현하면, 다음 표현식들이 같은 값을 주어야 한다:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> 와 <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> 와 <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code> (전 순서의 경우)</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> 와 <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> (전 순서의 경우)</p>
</div></blockquote>
<p>마지막 두 표현식은 전 순서 컬렉션에 적용된다 (예를 들어, 시퀀스에는 적용되지만, 집합과 매핑은 그렇지 않다). <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">total_ordering()</span></code></a> 데코레이터 또한 보기 바란다.</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 결과는 동등성과 일관성을 유지해야 한다. 같은 객체들은 같은 해시값을 같거나 해시 불가능으로 지정되어야 한다.</p>
</li>
</ul>
<p>파이썬은 이 일관성 규칙들을 강제하지 않는다. 사실 NaN 값들은 이 규칙을 따르지 않는 예다.</p>
</div>
<div class="section" id="membership-test-operations">
<span id="membership-test-details"></span><span id="not-in"></span><span id="in"></span><h3>6.10.2. 멤버십 검사 연산<a class="headerlink" href="#membership-test-operations" title="永久链接至标题">¶</a></h3>
<p>연산자 <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 과 <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a> 은 멤버십을 검사한다. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code> 는 <em>x</em> 가 <em>s</em> 의 멤버일 때 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를, 그렇지 않을 때 <code class="docutils literal notranslate"><span class="pre">False</span></code> 를 준다. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></code> 은 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code> 의 부정을 준다. 딕셔너리 뿐만 아니라 모든 내장 시퀀스들과 집합 형들이 이것을 지원하는데, 딕셔너리의 경우는 <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 이 딕셔너리에 주어진 키가 있는지 검사한다. list, tuple, set, frozenset, dict, collections.deque 와 같은 컨테이너형들의 경우, 표현식 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">any(x</span> <span class="pre">is</span> <span class="pre">e</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">e</span> <span class="pre">for</span> <span class="pre">e</span> <span class="pre">in</span> <span class="pre">y)</span></code> 와 동등하다.</p>
<p>문자열과 바이트열 형의 경우, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> 는 <em>x</em> 가 <em>y</em> 의 서브 스트링(substring)인 경우, 그리고 오직 그 경우만 <code class="docutils literal notranslate"><span class="pre">True</span></code> 다. 동등한 검사는 <code class="docutils literal notranslate"><span class="pre">y.find(x)</span> <span class="pre">!=</span> <span class="pre">-1</span></code> 다. 빈 문자열은 항상 다른 문자열들의 서브 스트링으로 취급되기 때문에, <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span> <span class="pre">in</span> <span class="pre">&quot;abc&quot;</span></code> 은 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 돌려준다.</p>
<p><a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> 메서드를 정의하는 사용자 정의 클래스의 경우, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">y.__contains__(x)</span></code> 가 참을 줄 때 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code> 를 돌려준다.</p>
<p><a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> 를 정의하지 않지만 <a class="reference internal" href="datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 를 정의하는 사용자 정의 클래스의 경우, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">y</span></code> 를 탐색할 때 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">z</span></code> 를 만족하는 어떤 값 <code class="docutils literal notranslate"><span class="pre">z</span></code> 가 만들어지면 <code class="docutils literal notranslate"><span class="pre">True</span></code> 다. 탐색하는 동안 예외가 발생하면 <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 이 그 예외를 일으킨 것으로 취급된다.</p>
<p>마지막으로, 올드스타일(old-style) 이터레이션 프로토콜을 시도한다: 클래스가 <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 를 정의하면, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y[i]</span></code> 를 만족하는 음이 아닌 정수 인덱스 <em>i</em> 가 존재하고, 그보다 작은 모든 정수 인덱스들에 대해 <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 예외를 일으키지 않는 경우, 그리고 오직 그 경우만 <code class="docutils literal notranslate"><span class="pre">True</span></code> 가 된다. (그 밖의 예외가 발생하면 <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 이 그 예외를 일으킨 것으로 취급된다.</p>
<p id="index-71">연산자 <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a> 은 <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 의 논리적 부정으로 정의된다.</p>
</div>
<div class="section" id="is-not">
<span id="is"></span><span id="index-72"></span><span id="identity-comparisons"></span><h3>6.10.3. 아이덴티티 비교<a class="headerlink" href="#is-not" title="永久链接至标题">¶</a></h3>
<p>연산자 <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> 와 <a class="reference internal" href="#is-not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code></a> 은 객체의 아이덴티티를 검사한다: <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> 는 <em>x</em> 와 <em>y</em> 가 아이덴티티가 같은 객체일 때, 그리고 오직 그 경우만 참이다. 객체의 아이덴티티는 <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id()</span></code></a> 함수를 사용해서 결정된다. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">y</span></code> 은 논리적 부정 값을 준다. <a class="footnote-reference" href="#id20" id="id13">[4]</a></p>
</div>
</div>
<div class="section" id="boolean-operations">
<span id="not"></span><span id="or"></span><span id="and"></span><span id="booleans"></span><h2>6.11. 논리 연산(Boolean operations)<a class="headerlink" href="#boolean-operations" title="永久链接至标题">¶</a></h2>
<pre id="index-73">
<strong id="grammar-token-or_test">or_test </strong> ::=  <a class="reference internal" href="#grammar-token-and_test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a> | <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> &quot;or&quot; <a class="reference internal" href="#grammar-token-and_test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a>
<strong id="grammar-token-and_test">and_test</strong> ::=  <a class="reference internal" href="#grammar-token-not_test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a> | <a class="reference internal" href="#grammar-token-and_test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a> &quot;and&quot; <a class="reference internal" href="#grammar-token-not_test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a>
<strong id="grammar-token-not_test">not_test</strong> ::=  <a class="reference internal" href="#grammar-token-comparison"><code class="xref docutils literal notranslate"><span class="pre">comparison</span></code></a> | &quot;not&quot; <a class="reference internal" href="#grammar-token-not_test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a>
</pre>
<p>논리 연산의 문맥에서, 그리고 표현식이 제어 흐름 문(control flow statements)에서 사용될 때, 다음 값들은 거짓으로 해석된다: <code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code>, 모든 형의 숫자 0, 빈 문자열과 컨테이너(문자열, 튜플, 리스트, 딕셔너리, 집합, 불변 집합(frozenset)들을 포함한다). 그 밖의 모든 값은 참으로 해석된다. 사용자 정의 객체들은 <a class="reference internal" href="datamodel.html#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> 메서드를 제공해서 자신의 논리값(truth value)을 커스터마이즈 할 수 있다.</p>
<p id="index-74">연산자 <a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a> 은 그 인자가 거짓이면 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code> 를 준다.</p>
<p id="index-75">표현식 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></code> 는 먼저 <em>x</em> 의 값을 구한다; <em>x</em> 가 거짓이면 그 값을 돌려준다; 그렇지 않으면 <em>y</em> 의 값을 구한 후에 그 결과를 돌려준다.</p>
<p id="index-76">표현식 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></code> 는 먼저 <em>x</em> 의 값을 구한다; <em>x</em> 가 참이면 그 값을 돌려준다. 그렇지 않으면 <em>y</em> 의 값을 구한 후에 그 결과를 돌려준다.</p>
<p>(<a class="reference internal" href="#and"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code></a> 와 <a class="reference internal" href="#or"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code></a> 어느 것도 반환 값이나 그 형을 <code class="docutils literal notranslate"><span class="pre">False</span></code> 와 <code class="docutils literal notranslate"><span class="pre">True</span></code> 로 제한하지 않고, 대신 마지막에 값이 구해진 인자를 돌려줌에 주의해야 한다. 이것은 때로 쓸모가 있다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">s</span></code> 가 문자열이고 비어 있으면 기본값으로 대체되어야 한다면, 표현식 <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">or</span> <span class="pre">'foo'</span></code> 는 원하는 값을 제공한다. <a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a> 은 새 값을 만들어야 하므로, 그 인자의 형과 관계없이 논리값(boolean value)을 돌려준다 (예를 들어, <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">'foo'</span></code> 는 <code class="docutils literal notranslate"><span class="pre">''</span></code> 가 아니라 <code class="docutils literal notranslate"><span class="pre">False</span></code> 를 만든다.))</p>
</div>
<div class="section" id="conditional-expressions">
<h2>6.12. 조건 표현식(Conditional expressions)<a class="headerlink" href="#conditional-expressions" title="永久链接至标题">¶</a></h2>
<pre id="index-77">
<strong id="grammar-token-conditional_expression">conditional_expression</strong> ::=  <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [&quot;if&quot; <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> &quot;else&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
<strong id="grammar-token-expression">expression            </strong> ::=  <a class="reference internal" href="#grammar-token-conditional_expression"><code class="xref docutils literal notranslate"><span class="pre">conditional_expression</span></code></a> | <a class="reference internal" href="#grammar-token-lambda_expr"><code class="xref docutils literal notranslate"><span class="pre">lambda_expr</span></code></a>
<strong id="grammar-token-expression_nocond">expression_nocond     </strong> ::=  <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> | <a class="reference internal" href="#grammar-token-lambda_expr_nocond"><code class="xref docutils literal notranslate"><span class="pre">lambda_expr_nocond</span></code></a>
</pre>
<p>조건 표현식은 (때로 &quot;삼 항 연산자(ternary operator)&quot;라고 불린다) 모든 파이썬 연산에서 가장 낮은 우선순위를 갖는다.</p>
<p>표현식 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">if</span> <span class="pre">C</span> <span class="pre">else</span> <span class="pre">y</span></code> 은 먼저 <em>x</em> 대신에 조건 <em>C</em> 의 값을 구한다. <em>C</em> 가 참이면, <em>x</em> 의 값이 구해지고 그 값을 돌려준다; 그렇지 않으면, <em>y</em> 의 값을 구한 후에 그 결과를 돌려준다.</p>
<p>조건 표현식에 대한 더 자세한 내용은 <span class="target" id="index-101"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0308"><strong>PEP 308</strong></a> 를 참고하라.</p>
</div>
<div class="section" id="lambda">
<span id="lambdas"></span><span id="id14"></span><h2>6.13. 람다(Lambdas)<a class="headerlink" href="#lambda" title="永久链接至标题">¶</a></h2>
<pre id="index-79">
<strong id="grammar-token-lambda_expr">lambda_expr       </strong> ::=  &quot;lambda&quot; [<a class="reference internal" href="compound_stmts.html#grammar-token-parameter_list"><code class="xref docutils literal notranslate"><span class="pre">parameter_list</span></code></a>]: <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-lambda_expr_nocond">lambda_expr_nocond</strong> ::=  &quot;lambda&quot; [<a class="reference internal" href="compound_stmts.html#grammar-token-parameter_list"><code class="xref docutils literal notranslate"><span class="pre">parameter_list</span></code></a>]: <a class="reference internal" href="#grammar-token-expression_nocond"><code class="xref docutils literal notranslate"><span class="pre">expression_nocond</span></code></a>
</pre>
<p>람다 표현식은 (때로 람다 형식(lambda forms)이라고 불린다) 이름 없는 함수를 만드는 데 사용된다. 표현식 <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">arguments:</span> <span class="pre">expression</span></code> 는 함수 객체를 준다. 이 이름 없는 객체는 이렇게 정의된 함수 객체처럼 동작한다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def &lt;lambda&gt;(arguments):
    return expression
</pre></div>
</div>
<p>파라미터 목록의 문법은 <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">함수 정의</span></a> 섹션을 보면 된다. 람다 표현식으로 만들어진 함수는 문장(statements)이나 어노테이션(annotations)을 포함할 수 없음에 주의해야 한다.</p>
</div>
<div class="section" id="expression-lists">
<span id="exprlists"></span><h2>6.14. 표현식 목록(Expression lists)<a class="headerlink" href="#expression-lists" title="永久链接至标题">¶</a></h2>
<pre id="index-80">
<strong id="grammar-token-expression_list">expression_list   </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> ( &quot;,&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> )* [&quot;,&quot;]
<strong id="grammar-token-starred_list">starred_list      </strong> ::=  <a class="reference internal" href="#grammar-token-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a> ( &quot;,&quot; <a class="reference internal" href="#grammar-token-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a> )* [&quot;,&quot;]
<strong id="grammar-token-starred_expression">starred_expression</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | ( <a class="reference internal" href="#grammar-token-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a> &quot;,&quot; )* [<a class="reference internal" href="#grammar-token-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a>]
<strong id="grammar-token-starred_item">starred_item      </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | &quot;*&quot; <a class="reference internal" href="#grammar-token-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>
</pre>
<p id="index-81">리스트나 집합 디스플레이의 일부일 때를 제외하고, 최소한 하나의 쉼표를 포함하는 표현식 목록은 튜플을 준다. 튜플의 길이는 목록에 있는 표현식의 개수다. 표현식들은 왼쪽에서 오른쪽으로 값이 구해진다.</p>
<p id="index-82">애스터리스크(asterisk) <code class="docutils literal notranslate"><span class="pre">*</span></code> 는 이터러블 언 패킹(<em class="dfn">iterable unpacking</em>)을 나타낸다. 피연산자는 반드시 <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">이터러블</span></a> 이어야 한다. 그 이터러블이 항목들의 시퀀스로 확장되어서, 언 패킹 지점에서 새 튜플, 리스트, 집합에 포함된다.</p>
<div class="versionadded">
<p><span class="versionmodified">3.5 新版功能: </span>표현식 목록에서의 이터러블 언 패킹, <span class="target" id="index-102"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0448"><strong>PEP 448</strong></a> 에서 최초로 제안되었다.</p>
</div>
<p id="index-84">끝에 붙는 쉼표는 단일 튜플(single tuple) (소위, <em>싱글톤(singleton)</em>) 을 만들 때만 필수다; 다른 모든 경우에는 생략할 수 있다. 끝에 붙는 쉼표가 없는 단일 표현식은 튜플을 만들지 않고, 그 표현식의 값을 준다. (빈 튜플을 만들려면, 빈 괄호 쌍을 사용하라: <code class="docutils literal notranslate"><span class="pre">()</span></code>.)</p>
</div>
<div class="section" id="evaluation-order">
<span id="evalorder"></span><h2>6.15. 값을 구하는 순서<a class="headerlink" href="#evaluation-order" title="永久链接至标题">¶</a></h2>
<p id="index-85">파이썬은 왼쪽에서 오른쪽으로 표현식의 값을 구한다. 대입의 값을 구하는 동안, 우변의 값이 좌변보다 먼저 구해짐에 주목하라.</p>
<p>다 줄들에서, 표현식은 그들의 끝에 붙은 숫자들의 순서대로 값이 구해진다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span>
<span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span><span class="p">)</span>
<span class="p">{</span><span class="n">expr1</span><span class="p">:</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">:</span> <span class="n">expr4</span><span class="p">}</span>
<span class="n">expr1</span> <span class="o">+</span> <span class="n">expr2</span> <span class="o">*</span> <span class="p">(</span><span class="n">expr3</span> <span class="o">-</span> <span class="n">expr4</span><span class="p">)</span>
<span class="n">expr1</span><span class="p">(</span><span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="o">*</span><span class="n">expr4</span><span class="p">,</span> <span class="o">**</span><span class="n">expr5</span><span class="p">)</span>
<span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span> <span class="o">=</span> <span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span>
</pre></div>
</div>
</div>
<div class="section" id="operator-precedence">
<span id="operator-summary"></span><h2>6.16. 연산자 우선순위<a class="headerlink" href="#operator-precedence" title="永久链接至标题">¶</a></h2>
<p id="index-86">다음 표는 파이썬 에서의 연산자 우선순위를 가장 낮은 것 (least binding)에서 가장 높은 것 (most binding) 순으로 요약한다. 같은 상자에 들어있는 연산자들은 같은 우선순위를 갖는다. 문법이 명시적으로 주어지지 않는 이상, 연산자들은 이항(binary)이다. 같은 상자에 있는 연산자들은 왼쪽에서 오른쪽으로 그룹 지어진다 (거듭제곱은 예외인데, 오른쪽에서 왼쪽으로 그룹 지어진다).</p>
<p>비교, 멤버십 검사, 아이덴티티 검사들은 모두 같은 우선순위를 갖고 <a class="reference internal" href="#comparisons"><span class="std std-ref">비교</span></a> 섹션에서 설명한 것처럼 왼쪽에서 오른쪽으로 이어붙이기(chaining) 하는 기능을 갖는다.</p>
<table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">연산자</th>
<th class="head">설명</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a></td>
<td>람다 표현식</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> -- <a class="reference internal" href="compound_stmts.html#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a></td>
<td>조건 표현식</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#or"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code></a></td>
<td>논리 OR</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#and"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code></a></td>
<td>논리 AND</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a> <code class="docutils literal notranslate"><span class="pre">x</span></code></td>
<td>논리 NOT</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a>, <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>,
<a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a>, <a class="reference internal" href="#is-not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code></a>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code></td>
<td>비교, 멤버십 검사와 아이덴티티 검사를 포함한다</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">|</span></code></td>
<td>비트 OR</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">^</span></code></td>
<td>비트 XOR</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">&amp;</span></code></td>
<td>비트 AND</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code></td>
<td>시프트</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code></td>
<td>덧셈과 뺄셈</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code></td>
<td>곱셈, 행렬 곱셈, 나눗셈, 정수 나눗셈, 나머지 <a class="footnote-reference" href="#id21" id="id15">[5]</a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">+x</span></code>, <code class="docutils literal notranslate"><span class="pre">-x</span></code>, <code class="docutils literal notranslate"><span class="pre">~x</span></code></td>
<td>양, 음, 비트 NOT</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">**</span></code></td>
<td>거듭제곱 <a class="footnote-reference" href="#id22" id="id16">[6]</a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">await</span></code> <code class="docutils literal notranslate"><span class="pre">x</span></code></td>
<td>어웨이트 표현식</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">x[index]</span></code>, <code class="docutils literal notranslate"><span class="pre">x[index:index]</span></code>,
<code class="docutils literal notranslate"><span class="pre">x(arguments...)</span></code>, <code class="docutils literal notranslate"><span class="pre">x.attribute</span></code></td>
<td>서브스크립션, 슬라이싱, 호출, 어트리뷰트 참조</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">(expressions...)</span></code>,
<code class="docutils literal notranslate"><span class="pre">[expressions...]</span></code>,
<code class="docutils literal notranslate"><span class="pre">{key:</span> <span class="pre">value...}</span></code>,
<code class="docutils literal notranslate"><span class="pre">{expressions...}</span></code></td>
<td>결합(binding) 또는 튜플 디스플레이, 리스트 디스플레이, 딕셔너리 디스플레이, 집합 디스플레이</td>
</tr>
</tbody>
</table>
<p class="rubric">각주</p>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[1]</a></td><td><code class="docutils literal notranslate"><span class="pre">abs(x%y)</span> <span class="pre">&lt;</span> <span class="pre">abs(y)</span></code> 이 수학적으로는 참이지만, float의 경우에는 소수점 자름(roundoff) 때문에 수치적으로 참이 아닐 수 있다. 예를 들어, 파이썬 float가 IEEE 754 배정도 숫자인 플랫폼을 가정할 때, <code class="docutils literal notranslate"><span class="pre">-1e-100</span> <span class="pre">%</span> <span class="pre">1e100</span></code> 가 <code class="docutils literal notranslate"><span class="pre">1e100</span></code> 와 같은 부호를 가지기 위해, 계산된 결과는 <code class="docutils literal notranslate"><span class="pre">-1e-100</span> <span class="pre">+</span> <span class="pre">1e100</span></code> 인데, 수치적으로는 <code class="docutils literal notranslate"><span class="pre">1e100</span></code> 과 정확히 같은 값이다. 함수 <a class="reference internal" href="../library/math.html#math.fmod" title="math.fmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.fmod()</span></code></a> 는 부호가 첫 번째 인자의 부호에 맞춰진 결과를 주기 때문에, 이 경우 <code class="docutils literal notranslate"><span class="pre">-1e-100</span></code> 을 돌려준다. 어떤 접근법이 더 적절한지는 응용 프로그램에 달려있다.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[2]</a></td><td>x가 y의 정확한 정수배와 아주 가까우면, 라운딩(rounding) 때문에 <code class="docutils literal notranslate"><span class="pre">x//y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">(x-x%y)//y</span></code> 보다 1 클 수 있다. 그런 경우, <code class="docutils literal notranslate"><span class="pre">divmod(x,y)[0]</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code> 가 <code class="docutils literal notranslate"><span class="pre">x</span></code> 와 아주 가깝도록 유지하기 위해, 파이썬은 뒤의 결과를 돌려준다.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[3]</a></td><td><p class="first">유니코드 표준은 코드 포인트(<em class="dfn">code points</em>) (예를 들어, U+0041) 와 추상 문자(<em class="dfn">abstract characters</em>) (예를 들어, &quot;LATIN CAPITAL LETTER A&quot;) 를 구분한다. 유니코드에 있는 대부분의 추상 문자들이 오직 하나의 코드 포인트만으로 표현되지만, 추가로 하나 이상의 코드 포인트의 시퀀스로 표현될 수 있는 추상 문자들이 많이 있다. 예를 들어, 추상 문자 &quot;LATIN CAPITAL LETTER C WITH CEDILLA&quot; 는 코드 위치 U+00C7 에 있는 한 개의 복합 문자(<em class="dfn">precomposed character</em>) 나 코드 위치 U+0043 (LATIN CAPITAL LETTER C) 에 있는 기본 문자(<em class="dfn">base character</em>) 와 뒤따르는 코드 위치 U+0327 (COMBINING CEDILLA) 에 있는 결합 문자(<em class="dfn">combining character</em>) 의 시퀀스로 표현될 수 있다.</p>
<p>문자열의 비교 연산자는 유니코드 코드 포인트 수준에서 비교한다. 이것은 사람에게 반 직관적일 수 있다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">&quot;\u00C7&quot;</span> <span class="pre">==</span> <span class="pre">&quot;\u0043\u0327&quot;</span></code> 는 거짓이다, 설사 두 문자열이 같은 추상 문자 &quot;LATIN CAPITAL LETTER C WITH CEDILLA&quot;를 표현할지라도 그렇다.</p>
<p class="last">문자열을 추상 문자 수준에서 비교하려면 (즉, 사람에게 직관적인 방법으로), <a class="reference internal" href="../library/unicodedata.html#unicodedata.normalize" title="unicodedata.normalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">unicodedata.normalize()</span></code></a> 를 사용하라.</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[4]</a></td><td>자동 가비지-수거(automatic garbage-collection)와 자유 목록(free lists)과 디스크립터(descriptor)의 동적인 성격 때문에, <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> 연산자를 인스턴스 메서드들이나 상수들을 비교하는 것과 같은 특정한 방식으로 사용할 때, 겉으로 보기에 이상한 동작을 감지할 수 있다. 더 자세한 정보는 그들의 문서를 확인하기 바란다.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[5]</a></td><td><code class="docutils literal notranslate"><span class="pre">%</span></code> 연산자는 문자열 포매팅에도 사용된다; 같은 우선순위가 적용된다.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[6]</a></td><td>거듭제곱 연산자 <code class="docutils literal notranslate"><span class="pre">**</span></code> 는 오른쪽에 오는 산술이나 비트 일 항 연산자보다 약하게 결합한다, 즉, <code class="docutils literal notranslate"><span class="pre">2**-1</span></code> 는 <code class="docutils literal notranslate"><span class="pre">0.5</span></code> 다.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">6. 표현식</a><ul>
<li><a class="reference internal" href="#arithmetic-conversions">6.1. 산술 변환</a></li>
<li><a class="reference internal" href="#atoms">6.2. 아톰 (Atoms)</a><ul>
<li><a class="reference internal" href="#atom-identifiers">6.2.1. 식별자 (이름)</a></li>
<li><a class="reference internal" href="#literals">6.2.2. 리터럴 (Literals)</a></li>
<li><a class="reference internal" href="#parenthesized-forms">6.2.3. 괄호 안에 넣은 형</a></li>
<li><a class="reference internal" href="#displays-for-lists-sets-and-dictionaries">6.2.4. 리스트, 집합, 딕셔너리의 디스플레이(display)</a></li>
<li><a class="reference internal" href="#list-displays">6.2.5. 리스트 디스플레이</a></li>
<li><a class="reference internal" href="#set-displays">6.2.6. 집합 디스플레이</a></li>
<li><a class="reference internal" href="#dictionary-displays">6.2.7. 딕셔너리 디스플레이</a></li>
<li><a class="reference internal" href="#generator-expressions">6.2.8. 제너레이터 표현식 (Generator expressions)</a></li>
<li><a class="reference internal" href="#yield-expressions">6.2.9. 일드 표현식(Yield expressions)</a><ul>
<li><a class="reference internal" href="#generator-iterator-methods">6.2.9.1. 제너레이터-이터레이터 메서드</a></li>
<li><a class="reference internal" href="#examples">6.2.9.2. 사용 예</a></li>
<li><a class="reference internal" href="#asynchronous-generator-functions">6.2.9.3. 비동기 제너레이터 함수</a></li>
<li><a class="reference internal" href="#asynchronous-generator-iterator-methods">6.2.9.4. 비동기 제너레이터-이터레이터 메서드</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#primaries">6.3. 프라이머리</a><ul>
<li><a class="reference internal" href="#attribute-references">6.3.1. 어트리뷰트 참조</a></li>
<li><a class="reference internal" href="#subscriptions">6.3.2. 서브스크립션(Subscriptions)</a></li>
<li><a class="reference internal" href="#slicings">6.3.3. 슬라이싱(Slicings)</a></li>
<li><a class="reference internal" href="#calls">6.3.4. 호출</a></li>
</ul>
</li>
<li><a class="reference internal" href="#await-expression">6.4. 어웨이트 표현식</a></li>
<li><a class="reference internal" href="#the-power-operator">6.5. 거듭제곱 연산자</a></li>
<li><a class="reference internal" href="#unary-arithmetic-and-bitwise-operations">6.6. 일 항 산술과 비트 연산</a></li>
<li><a class="reference internal" href="#binary-arithmetic-operations">6.7. 이항 산술 연산</a></li>
<li><a class="reference internal" href="#shifting-operations">6.8. 시프트 연산</a></li>
<li><a class="reference internal" href="#binary-bitwise-operations">6.9. 이항 비트 연산</a></li>
<li><a class="reference internal" href="#comparisons">6.10. 비교</a><ul>
<li><a class="reference internal" href="#value-comparisons">6.10.1. 값 비교</a></li>
<li><a class="reference internal" href="#membership-test-operations">6.10.2. 멤버십 검사 연산</a></li>
<li><a class="reference internal" href="#is-not">6.10.3. 아이덴티티 비교</a></li>
</ul>
</li>
<li><a class="reference internal" href="#boolean-operations">6.11. 논리 연산(Boolean operations)</a></li>
<li><a class="reference internal" href="#conditional-expressions">6.12. 조건 표현식(Conditional expressions)</a></li>
<li><a class="reference internal" href="#lambda">6.13. 람다(Lambdas)</a></li>
<li><a class="reference internal" href="#expression-lists">6.14. 표현식 목록(Expression lists)</a></li>
<li><a class="reference internal" href="#evaluation-order">6.15. 값을 구하는 순서</a></li>
<li><a class="reference internal" href="#operator-precedence">6.16. 연산자 우선순위</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="import.html"
                        title="上一章">5. 임포트 시스템</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="simple_stmts.html"
                        title="下一章">7. 단순문(Simple statements)</a></p>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/reference/expressions.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. 단순문(Simple statements)"
             >下一页</a> |</li>
        <li class="right" >
          <a href="import.html" title="5. 임포트 시스템"
             >上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh</span>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">도큐멘테이션 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 언어 레퍼런스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    파이썬 소프트웨어 재단은 비영리 법인입니다.
    <a href="https://www.python.org/psf/donations/">기부를 부탁합니다.</a>
    <br />
    4月 21, 2018 에 마지막으로 업데이트되었습니다.
    <a href="../bugs.html">버그를 찾았나요?</a>
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.7.2 를 사용해서 만들었습니다.
    </div>

  </body>
</html>