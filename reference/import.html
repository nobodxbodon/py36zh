
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>5. 임포트 시스템 &#8212; Python 3.6.5 文档</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.6.5 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="6. 표현식" href="expressions.html" />
    <link rel="prev" title="4. 실행 모델" href="executionmodel.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.org/3/reference/import.html" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. 표현식"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 실행 모델"
             accesskey="P">上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh</span>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">도큐멘테이션 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 언어 레퍼런스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-import-system">
<span id="importsystem"></span><h1>5. 임포트 시스템<a class="headerlink" href="#the-import-system" title="永久链接至标题">¶</a></h1>
<p id="index-0">한 <a class="reference internal" href="../glossary.html#term-module"><span class="xref std std-term">모듈</span></a> 에 있는 파이썬 코드는 <a class="reference internal" href="../glossary.html#term-importing"><span class="xref std std-term">임포팅</span></a> 이라는 프로세스를 통해 다른 모듈에 있는 코드들에 대한 접근권을 얻는다. <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문은 임포트 절차를 일으키는 가장 흔한 방법이지만, 유일한 방법은 아니다. <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 같은 함수나 내장 <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 도 임포트 절차를 일으키는데 사용될 수 있다.</p>
<p><a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문은 두 가지 연산을 합친 것이다; 먼저 이름이 가리키는 모듈을 찾은 후에, 그 검색의 결과를 지역 스코프의 이름에 연결한다. <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문의 검색 연산은 적절한 인자들로 <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수를 호출하는 것으로 정의된다. <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 의 반환 값은 <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문의 이름 연결 연산을 수행하는 데 사용된다. 이 이름 연결 연산의 정확한 세부사항에 대해서는 <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문을 보면 된다.</p>
<p><a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 의 직접 호출은 모듈을 찾고, 발견된다면, 모듈을 만드는 연산만을 수행한다. 부모 패키지를 임포트하거나 여러 캐시(<a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 를 포함한다)를 갱신하는 것과 같은 부수적인 효과들이 일어날 수 있기는 하지만, 오직 <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문만이 이름 연결 연산을 수행한다.</p>
<p>import 문의 일부로 <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 를 호출할 때, 표준 내장 <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 가 호출된다. 임포트 시스템을 호출하는 다른 메커니즘 (<a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 같은)은 <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 를 사용하지 않고 임포트 개념을 구현하기 위한 자신의 방법을 사용할 수 있다.</p>
<p>모듈이 처음 임포트 될 때, 파이썬은 모듈을 검색하고, 발견된다면, 모듈 객체를 만들고 <a class="footnote-reference" href="#fnmo" id="id1">[1]</a>, 초기화한다. 만약 그 이름의 모듈을 발견할 수 없다면, <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> 를 일으킨다. 파이썬은 임포트 절차가 호출될 때 이름 붙여진 모듈을 찾는 다양한 전략을 구현한다. 이 전략들은 다음 섹션에서 설명하는 여러 가지 훅을 통해 수정되고 확장될 수 있다.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>임포트 시스템은 <span class="target" id="index-45"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> 의 두 번째 단계를 완전히 구현하도록 개정되었다. 이제 묵시적인 임포트 절차는 없다 - 전체 임포트 시스템이 <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 을 통해 노출된다. 여기에 더해, 네이티브(native) 이름 공간 패키지의 지원이 구현되었다 (<span class="target" id="index-46"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> 을 보라).</p>
</div>
<div class="section" id="importlib">
<h2>5.1. <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a><a class="headerlink" href="#importlib" title="永久链接至标题">¶</a></h2>
<p><a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> 모듈은 임포트 시스템과 상호 작용하기 위한 풍부한 API를 제공한다. 예를 들어, <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 는 임포트 절차를 구동하는 데 있어 내장 <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 에 비해 권장되고, 더 간단한 API를 제공한다. 더 상세한 내용은 <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> 라이브러리 도큐멘테이션을 참고하면 된다.</p>
</div>
<div class="section" id="packages">
<h2>5.2. 패키지(package)<a class="headerlink" href="#packages" title="永久链接至标题">¶</a></h2>
<p id="index-3">파이썬은 한 가지 종류의 모듈 객체만 갖고 있고, 모든 모듈은 모듈이 파이썬이나 C나 그 밖의 다른 어떤 방법으로 구현되었는지와 상관없이 이 형이다. 모듈을 조직화하고 이름 계층구조를 제공하기 위해, 파이썬은 <a class="reference internal" href="../glossary.html#term-package"><span class="xref std std-term">패키지</span></a> 라는 개념을 갖고 있다.</p>
<p>패키지를 파일 시스템에 있는 디렉터리라고 생각할 수 있지만, 패키지와 모듈이 파일시스템으로부터 올 필요는 없으므로 이 비유를 너무 문자 그대로 해석하지 말아야 한다. 이 문서의 목적상, 디렉터리와 파일이라는 비유를 사용할 것이다. 파일 시스템 디렉터리처럼, 패키지는 계층적으로 조직화하고, 패키지는 보통 모듈뿐만 아니라 서브 패키지도 포함할 수 있다.</p>
<p>모든 패키지가 모듈이라는 것을 기억하는 것이 중요하다. 하지만 모든 모듈이 패키지인 것은 아니다. 다른 식으로 표현하면, 패키지는 특별한 종류의 모듈이다. 구체적으로, <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트를 포함하는 모든 모듈은 패키지로 취급된다.</p>
<p>모든 모듈은 이름이 있다. 서브 패키지 이름은 파이썬의 표준 어트리뷰트 액세스 문법을 따라, 부모 패키지 이름과 점(dot)으로 구분된다. 그래서 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 라고 불리는 모듈과 <a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> 이라고 불리는 패키지가 있을 수 있다. email 은 다시 서브 패키지 <a class="reference internal" href="../library/email.mime.html#module-email.mime" title="email.mime: Build MIME messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.mime</span></code></a> 을 갖고, 이 서브 패키지 내에 모듈 <code class="xref py py-mod docutils literal notranslate"><span class="pre">email.mime.text</span></code> 가 있을 수 있다.</p>
<div class="section" id="regular-packages">
<h3>5.2.1. 정규 패키지<a class="headerlink" href="#regular-packages" title="永久链接至标题">¶</a></h3>
<p id="index-4">파이썬은 두 가지 종류의 패키지를 정의한다, <a class="reference internal" href="../glossary.html#term-regular-package"><span class="xref std std-term">정규 패키지</span></a> 와 <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">이름 공간 패키지</span></a>. 정규 패키지는 파이썬 3.2와 그 이전에 존재하던 전통적인 패키지다. 정규 패키지는 보통 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 파일을 가진 디렉터리로 구현된다. 정규 패키지가 임포트될 때, 이 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 파일이 묵시적으로 실행되고, 그것이 정의하는 객체들이 패키지의 이름 공간의 이름들도 연결된다. <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 파일은 다른 모듈들이 가질 수 있는 것과 같은 파이썬 코드를 포함할 수 있고, 파이썬은 임포트될 때 모듈에 몇 가지 어트리뷰트를 추가한다.</p>
<p>예를 들어, 다음과 같은 파일시스템 배치는 최상위 <code class="docutils literal notranslate"><span class="pre">parent</span></code> 패키지와 세 개의 서브 패키지를 정의한다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">parent</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">one</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">two</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">three</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">parent.one</span></code> 을 임포트하면 <code class="docutils literal notranslate"><span class="pre">parent/__init__.py</span></code> 과 <code class="docutils literal notranslate"><span class="pre">parent/one/__init__.py</span></code> 을 묵시적으로 실행한다. 뒤이은 <code class="docutils literal notranslate"><span class="pre">parent.two</span></code> 와 <code class="docutils literal notranslate"><span class="pre">parent.three</span></code> 의 임포트는 각각 <code class="docutils literal notranslate"><span class="pre">parent/two/__init__.py</span></code> 와 <code class="docutils literal notranslate"><span class="pre">parent/three/__init__.py</span></code> 를 실행한다.</p>
</div>
<div class="section" id="namespace-packages">
<h3>5.2.2. 이름 공간 패키지<a class="headerlink" href="#namespace-packages" title="永久链接至标题">¶</a></h3>
<p id="index-5">이름 공간 패키지는 여러 가지 <a class="reference internal" href="../glossary.html#term-portion"><span class="xref std std-term">포션</span></a> 들의 복합체인데, 각 포션들은 부모 패키지의 서브 패키지로 이바지한다. 포션들은 파일시스템의 다른 위치에 놓일 수 있다. 포션들은 zip 파일이나 네트워크나 파이썬이 임포트할 때 검색하는 어떤 다른 장소에서 발견될 수 있다. 이름 공간 패키지는 파일시스템의 객체와 직접적인 상관관계가 있을 수도 있고 그렇지 않을 수도 있다; 구체적인 형태가 없는 가상 모듈일 수도 있다.</p>
<p>이름 공간 패키지는 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트로 일반적인 리스트를 사용하지 않는다. 대신에 특별한 이터러블 형을 사용하는데, 그 패키지 내의 다음 임포트 시도에서 그것의 부모 패키지(또는 최상위 패키지의 경우 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>) 의 경로가 변했으면 패키지 포션에 대한 새 검색을 자동으로 수행하게 된다.</p>
<p>이름 공간 패키지의 경우, <code class="docutils literal notranslate"><span class="pre">parent/__init__.py</span></code> 파일이 없다. 사실, 임포트 검색 동안 여러 개의 <code class="docutils literal notranslate"><span class="pre">parent`</span> <span class="pre">디렉터리가</span> <span class="pre">발견될</span> <span class="pre">수</span> <span class="pre">있고,</span> <span class="pre">각각의</span> <span class="pre">것은</span> <span class="pre">다른</span> <span class="pre">포션들에</span> <span class="pre">의해</span> <span class="pre">제공된다.</span> <span class="pre">그래서</span> <span class="pre">``parent/one</span></code> 은 물리적으로 <code class="docutils literal notranslate"><span class="pre">parent/two</span></code> 옆에 위치하지 않을 수 있다. 이 경우, 파이썬은 자신 또는 서브 패키지 중 어느 하나가 임포트 될 때마다 최상위 <code class="docutils literal notranslate"><span class="pre">parent</span></code> 패키지를 위한 이름 공간 패키지를 만든다.</p>
<p>이름 공간 패키지의 규격은 <span class="target" id="index-47"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> 을 참고하라.</p>
</div>
</div>
<div class="section" id="searching">
<h2>5.3. 검색<a class="headerlink" href="#searching" title="永久链接至标题">¶</a></h2>
<p>검색을 시작하기 위해, 파이썬은 임포트될 모듈(또는 패키지, 하지만 이 논의에서 차이점은 중요하지 않다)의 완전히 <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">정규화된 이름</span></a> 을 필요로 한다. 이 이름은 <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문으로 제공된 여러 인자나, <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 나 <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수로 전달된 파라미터들로부터 온다.</p>
<p>이 이름은 임포트 검색의 여러 단계에서 사용되는데, 서브 모듈로 가는 점으로 구분된 경로일 수 있다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>. 이 경우에, 파이썬은 먼저 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 를, 그다음에 <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> 를, 마지막으로 <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> 를 임포트하려고 시도한다. 만약 중간 임포트가 어느 하나라도 실패한다면 <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> 가 발생한다.</p>
<div class="section" id="the-module-cache">
<h3>5.3.1. 모듈 캐시<a class="headerlink" href="#the-module-cache" title="永久链接至标题">¶</a></h3>
<p id="index-7">임포트 검색 도중 처음으로 검사되는 장소는 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 다. 이 매핑은 중간 경로들을 포함해서 전에 임포트된 모든 모듈의 캐시로 기능한다. 그래서 만약 <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> 가 앞서 임포트 되었다면, <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 는 <code class="docutils literal notranslate"><span class="pre">foo</span></code>, <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code>, <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> 항목들을 포함한다. 각 키에 대응하는 값들은 모듈 객체다.</p>
<p>임포트하는 동안, 모듈 이름을 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에서 찾고, 만약 있다면 해당 값이 임포트를 만족하는 모듈이고, 프로세스는 완료된다. 하지만 값이 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a>  를 일으킨다. 만약 모듈 이름이 없다면, 파이썬은 모듈 검색을 계속 진행한다.</p>
<p><a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 은 쓰기가 허락된다. 키를 삭제해도 해당 모듈을 파괴하지는 않지만(다른 모듈들이 아직 그 모듈에 대한 참조를 유지하고 있을 수 있으므로), 해당 이름의 모듈에 대한 캐시를 무효화해서, 다음 임포트때 파이썬으로 하여금 그 모듈을 다시 찾도록 만든다. 키에는 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 대입할 수도 있는데, 다음 임포트 때 <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> 가 일어나도록 만든다.</p>
<p>모듈 객체에 대한 참조를 유지한다면, <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 의 캐시 항목을 무효로 한 후 다시 임포트하면 두 모듈 객체는 같은 것이 아니게 됨에 주의해야 한다. 반면에 <a class="reference internal" href="../library/importlib.html#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.reload()</span></code></a> 는 같은 모듈 객체를 재사용하고, 간단하게 모듈의 코드를 다시 실행해서 모듈의 내용을 다시 초기화한다.</p>
</div>
<div class="section" id="finders-and-loaders">
<h3>5.3.2. 파인더(finder)와 로더(loader)<a class="headerlink" href="#finders-and-loaders" title="永久链接至标题">¶</a></h3>
<p id="index-8">모듈이 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에서 발견되지 않으면, 모듈을 찾아서 로드하기 위해 파이썬의 임포트 프로토콜이 구동된다. 이 프로토콜은 두 개의 개념적 객체들로 구성되어 있다, <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">파인더</span></a> 와 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>. 파인더의 일은 자신이 알고 있는 전략을 사용해, 주어진 이름의 모듈을 찾을 수 있는지 결정하는 것이다. 두 인터페이스 모두를 구현한 객체들을 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">임포터</span></a> 라고 부른다 - 요청한 모듈을 로딩할 수 있다고 판단할 때 자신을 돌려준다.</p>
<p>파이썬은 여러 가지 기본 파인더들과 임포터들을 포함하고 있다. 첫 번째 것은 내장 모듈들의 위치를 찾을 수 있고, 두 번째 것은 프로즌 모듈(frozen module)의 위치를 찾을 수 있고, 세 번째 것은 모듈을 <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">임포트 경로</span></a> 에서 검색한다. <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">임포트 경로</span></a> 는 파일 시스템의 경로나 zip 파일을 가리키는 위치들의 목록이다. 그것은 URL로 식별될 수 있는 것들처럼, 위치가 지정될 수 있는 자원들을 검색하도록 확장될 수 있다.</p>
<p>임포트 절차는 확장 가능해서, 모듈 검색의 범위를 확대하기       위해 새 파인더를 추가할 수 있다.</p>
<p>파인더는 실제로 모듈을 로드하지는 않는다. 주어진 이름의 모듈을 찾으면 임포트와 관련된 정보들을 요약한 <em class="dfn">모듈 스펙 (module spec)</em> 을 돌려주는데, 임포트 절차는 모듈을 로딩할 때 이것을 사용하게 된다.</p>
<p>다음 섹션은 파인더와 로더의 프로토콜에 대해 좀 더 자세히 설명하는데, 임포트 절차를 확장하기 위해 어떻게 새로운 것들을 만들고 등록하는지를 포함한다.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.4 版更改: </span>이전 버전의 파이썬에서, 파인더가 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a> 를 직접 돌려주었지만, 이제는 로더를 <em>포함하고</em> 있는 모듈 스펙을 돌려준다. 임포트 도중 로더가 아직 사용되기는 하지만 그 역할은 축소되었다.</p>
</div>
</div>
<div class="section" id="import-hooks">
<h3>5.3.3. 임포트 훅(import hooks)<a class="headerlink" href="#import-hooks" title="永久链接至标题">¶</a></h3>
<p id="index-9">임포트 절차는 확장할 수 있도록 설계되었다; 일차적인 메커니즘은 <em>임포트 훅(import hook)</em> 이다. 두 가지 종류의 임포트 훅이 있다: <em>메타 훅(meta hook)</em> 과 <em>임포트 경로 훅(import path hook)</em>.</p>
<p>메타 훅은 임포트 처리의 처음에, <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 캐시 조회를 제외한 다른 임포트 처리들이 시작되기 전에 호출된다. 이것은 메타 훅이 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 처리, 프로즌 모듈, 내장 모듈들을 재정의할 수 있게 한다. 다음에 설명하듯이, 메타 훅은 <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 에 새 파인더 객체를 추가하는 방법으로 등록할 수 있다.</p>
<p>임포트 경로 훅은 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> (혹은 <code class="docutils literal notranslate"><span class="pre">package.__path__</span></code>) 처리 일부로, 관련된 경로 항목을 만나는 시점에 호출된다. 다음에 설명하듯이, 임포트 경로 훅은 <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> 에 새 콜러블을 추가하는 방법으로 등록할 수 있다.</p>
</div>
<div class="section" id="the-meta-path">
<h3>5.3.4. 메타 경로(meta path)<a class="headerlink" href="#the-meta-path" title="永久链接至标题">¶</a></h3>
<p id="index-10">주어진 이름의 모듈을 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에서 찾을 수 없을 때, 파이썬은 <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 를 검색하는데, 메타 경로 파인더 객체들의 목록을 포함하고 있다. 이 파인더들이 주어진 이름의 모듈을 처리하는 방법을 알고 있는지 확인하도록 요청한다. 메타 경로 파인더들은 <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 라는 이름의 메서드를 구현해야만 하는데, 세 개의 인자를 받아들인다: 이름, 임포트 경로, (생략 가능한) 타깃(target) 모듈. 메타 경로 파인더는 주어진 이름의 모듈을 처리할 수 있는지를 결정하기 위해 어떤 전략이건 사용할 수 있다.</p>
<p>만약 메타 경로 파인더가 주어진 이름의 모듈을 처리하는 법을 안다면, 스펙 객체를 돌려준다. 그럴 수 없다면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 돌려준다. 만약 <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 처리가 스펙을 돌려주지 못하고 목록의 끝에 도달하면, <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> 를 일으킨다. 발생하는 다른 예외들은 그냥 확산시키고, 임포트 프로세스를 중단한다.</p>
<p>메타 경로 파인더의 <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 메서드는 두 개나 세 개의 인자로 호출된다. 첫 번째 인자는 모듈의 완전히 정규화된 이름(fully qualified name)이다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>. 두 번째 인자는 모듈 검색에 사용할 경로 엔트리다. 최상위 모듈이 경우 두 번째 인자는 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이지만, 서브 모듈이나 서브 패키지의 경우 두 번째 인자는 부모 패키지의 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트 값이다. 만약 적절한 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트를 참조할 수 없으면 <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> 를 일으킨다. 세 번째 인자는 이미 존재하는 모듈 객체인데, 뒤에서 로딩할 대상이 된다. 임포트 시스템은 다시 로드(reload)할 때만 타깃을 전달한다.</p>
<p>메타 경로는 한 번의 임포트 요청에 대해 여러 번 탐색 될 수 있다. 예를 들어, 대상 모듈들이 아무것도 캐싱 되지 않았다고 할 때, <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> 를 임포트 하려면, 먼저 각 메타 경로 파인더 (<code class="docutils literal notranslate"><span class="pre">mpf</span></code>)들에 대해 <code class="docutils literal notranslate"><span class="pre">mpf.find_spec(&quot;foo&quot;,</span> <span class="pre">None,</span> <span class="pre">None)</span></code> 를 호출해서 최상위 임포트를 수행한다. <code class="docutils literal notranslate"><span class="pre">foo</span></code> 가 임포트 된 후에, 메타 경로를 두 번째 탐색해서 <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> 를 임포트 하는데, <code class="docutils literal notranslate"><span class="pre">mpf.find_spec(&quot;foo.bar&quot;,</span> <span class="pre">foo.__path__,</span> <span class="pre">None)</span></code> 를 호출한다. 일단 <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> 가 임포트 되면, 마지막 탐색은 <code class="docutils literal notranslate"><span class="pre">mpf.find_spec(&quot;foo.bar.baz&quot;,</span> <span class="pre">foo.bar.__path__,</span> <span class="pre">None)</span></code> 를 호출한다.</p>
<p>어떤 메타 경로 파인더들은 오직 최상위 임포트만 지원한다. 이런 임포터들은 두 번째 인자로 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 아닌 것이 오면 항상 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 돌려준다.</p>
<p>파이썬의 기본 <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 는 세 개의 메타 경로 파인더를 갖고 있다. 하나는 내장 모듈을 임포트하는 법을 알고, 하나는 프로즌 모듈을 임포트하는 법을 알고, 하나는 <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">임포트 경로</span></a> 에서 모듈을 임포트하는 법을 안다(즉 <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">경로 기반 파인더</span></a>).</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.4 版更改: </span>메타 경로 파인더의 <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 메서드가 이제 디프리케이트된(deprecated) <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_module" title="importlib.abc.MetaPathFinder.find_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code></a> 을 대체한다. 변경 없이도 동작하기는 하지만, 임포트 절차는 파인더가 <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code> 을 구현하지 않았을 때만 <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> 을 사용한다.</p>
</div>
</div>
</div>
<div class="section" id="loading">
<h2>5.4. 로딩(loading)<a class="headerlink" href="#loading" title="永久链接至标题">¶</a></h2>
<p>모듈 스펙이 발견되면, 임포트 절차는 모듈을 로딩할 때 그것(그것이 가진 로더도)을 사용한다. 여기에 임포트의 로딩 과정 동안 일어나는 일에 대한 대략적인 그림이 있다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">,</span> <span class="s1">&#39;create_module&#39;</span><span class="p">):</span>
    <span class="c1"># It is assumed &#39;exec_module&#39; will also be defined on the loader.</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">create_module</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">ModuleType</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># The import-related module attributes get set here:</span>
<span class="n">_init_module_attrs</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span>

<span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># namespace package</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># unsupported</span>
        <span class="k">raise</span> <span class="ne">ImportError</span>
<span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">,</span> <span class="s1">&#39;exec_module&#39;</span><span class="p">):</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="c1"># Set __loader__ and __package__ if missing.</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">raise</span>
<span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
</pre></div>
</div>
<p>다음과 같은 세부 사항에 주의해야 한다:</p>
<blockquote>
<div><ul class="simple">
<li>만약 주어진 이름의 모듈이 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 있다면, 임포트는 이미 그걸 돌려줬다.</li>
<li>로더가 모듈을 실행하기 전에 모듈은 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 자리를 잡는다. 이것은 필수적인데 모듈이 (직접적 혹은 간접적으로) 자신을 임포트할 수 있기 때문이다; 먼저 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 추가함으로써 최악의 상황에 제한 없는 재귀(recursion)를 방지하고, 최선의 상황에 여러 번 로딩되는 것을 막는다.</li>
<li>로딩이 실패하면, 실패한 모듈(오직 실패한 모듈만)은 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에서 삭제된다. <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 캐시에 이미 있는 모듈과 부수적 효과로 성공적으로 로딩된 모듈들은 캐시에 남아있어야만 한다. 이는 실패한 모듈조차 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 남아있게 되는 리로딩과 대비된다.</li>
<li>모듈이 만들어졌지만, 아직 실행되기 전에, <a class="reference internal" href="#import-mod-attrs"><span class="std std-ref">뒤의 섹션</span></a> 에서 요약되듯이, 임포트 절차는 임포트 관련 모듈 어트리뷰트들을 설정한다(위의 의사 코드 예에서 “_init_module_attrs”).</li>
<li>모듈 실행은 로딩에서 모듈의 이름 공간이 채워지는 결정적 순간이다. 실행은 전적으로 로더에 위임되는데, 로더가 어떤 것이 어떻게 채워져야 하는지 결정한다.</li>
<li>로딩 동안 만들어지고 exec_module() 로 전달되는 모듈은 임포트의 끝에 반환되는 것이 아닐 수 있다 <a class="footnote-reference" href="#fnlo" id="id2">[2]</a>.</li>
</ul>
</div></blockquote>
<div class="versionchanged">
<p><span class="versionmodified">在 3.4 版更改: </span>임포트 시스템이 기초 공사에 대한 로더의 책임을 들고 갔다. 이것들은 전에는 <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> 메서드에서 수행되었다.</p>
</div>
<div class="section" id="loaders">
<h3>5.4.1. 로더<a class="headerlink" href="#loaders" title="永久链接至标题">¶</a></h3>
<p>모듈 로더는 로딩의 결정적인 기능을 제공한다: 모듈 실행. 임포트 절차는 하나의 인자로 <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a> 메서드를 호출하는데, 실행할 모듈 객체가 전달된다. <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> 이 돌려주는 값은 무시된다.</p>
<p>로더는 다음과 같은 요구 조건들을 만족해야 한다:</p>
<blockquote>
<div><ul class="simple">
<li>만약 모듈이 파이썬 모듈(내장 모듈이나 동적으로 로딩되는 확장이 아니라)이면, 로더는 모듈의 코드를 모듈의 전역 이름 공간(<code class="docutils literal notranslate"><span class="pre">module.__dict__</span></code>)에서 실행해야 한다.</li>
<li>만약 로더가 모듈을 실행하지 못하면, <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 를 일으켜야 한다. 하지만 <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> 동안 발생하는 다른 예외도 전파된다.</li>
</ul>
</div></blockquote>
<p>많은 경우에, 파인더와 로더는 같은 객체다; 그런 경우 <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 메서드는 로더가 <code class="docutils literal notranslate"><span class="pre">self</span></code> 로 설정된 스펙을 돌려준다.</p>
<p>모듈 로더는 <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> 메서드를 구현함으로써 로딩하는 동안 모듈 객체를 만드는 일에 개입할 수 있다. 하나의 인자, 모듈 스펙, 을 받아들이고 로딩 중 사용할 모듈 객체를 돌려준다. <code class="docutils literal notranslate"><span class="pre">create_module()</span></code> 은 모듈 객체의 어트리뷰트를 설정할 필요는 없다. 만약 메서드가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 돌려주면, 임포트 절차는 새 모듈을 스스로 만든다.</p>
<div class="versionadded">
<p><span class="versionmodified">3.4 新版功能: </span>로더의 <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> 메서드.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.4 版更改: </span><a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_module()</span></code></a> 메서드는 <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> 로 대체되었고, 임포트 절차가 로딩의 공통 코드(boilerplate)에 대한 책임을 진다.</p>
<p>이미 존재하는 로더들과의 호환을 위해, 임포트 절차는 <code class="docutils literal notranslate"><span class="pre">load_module()</span></code> 메서드가 존재하고, <code class="docutils literal notranslate"><span class="pre">exec_module()</span></code> 을 구현하지 않았으면 <code class="docutils literal notranslate"><span class="pre">load_module()</span></code> 을 사용한다. 하지만 <code class="docutils literal notranslate"><span class="pre">load_module()</span></code> 은 디프리케이트되었다. 로더는 대신 <code class="docutils literal notranslate"><span class="pre">exec_module()</span></code> 를 구현해야 한다.</p>
<p><code class="docutils literal notranslate"><span class="pre">load_module()</span></code> 메서드는 모듈을 실행하는 것 외에 위에서 언급한 모든 공통(boilerplate) 로딩 기능을 구현해야만 한다. 같은 제약들이 모두 적용되는데, 추가적인 설명을 붙여보면:</p>
<blockquote>
<div><ul class="simple">
<li>만약 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 주어진 이름의 모듈 객체가 이미 존재하면, 로더는 반드시 그 객체를 사용해야 한다. (그렇지 않으면, <a class="reference internal" href="../library/importlib.html#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.reload()</span></code></a> 이 올바로 동작하지 않게 된다.) 만약 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 주어진 이름의 모듈이 없으면, 로더는 새 모듈객체를 만들고 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 추가해야 한다.</li>
<li>제한 없는 재귀와 여러 번 로딩되는 것을 방지하기 위해, 로더가 모듈 코드를 실행하기 전에 모듈이 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 존재해야 한다.</li>
<li>만약 로딩이 실패하면, 로더는 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 삽입한 모듈들을 제거해야 하는데, 실패한 모듈만을 제거해야 하고, 로더가 그 모듈을 직접 명시적으로 로드한 경우에만 그래야 한다.</li>
</ul>
</div></blockquote>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.5 版更改: </span><code class="docutils literal notranslate"><span class="pre">exec_module()</span></code> 이 정의되었지만 <code class="docutils literal notranslate"><span class="pre">create_module()</span></code> 이 정의되지 않으면 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> 이 발생한다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.6 版更改: </span><code class="docutils literal notranslate"><span class="pre">exec_module()</span></code> 이 정의되었지만 <code class="docutils literal notranslate"><span class="pre">create_module()</span></code> 이 정의되지 않으면 <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 를 일으킨다.</p>
</div>
</div>
<div class="section" id="submodules">
<h3>5.4.2. 서브 모듈<a class="headerlink" href="#submodules" title="永久链接至标题">¶</a></h3>
<p>어떤 메커니즘으로든 (예를 들어, <code class="docutils literal notranslate"><span class="pre">importlib</span></code> API들, <code class="docutils literal notranslate"><span class="pre">import</span></code> 나 <code class="docutils literal notranslate"><span class="pre">import-from</span></code> 문, 내장 <code class="docutils literal notranslate"><span class="pre">__import__()</span></code>) 서브 모듈이 로드될 때, 서브 모듈 객체로의 연결은 부모 모듈의 이름 공간에 이루어진다. 예를 들어, 패키지 <code class="docutils literal notranslate"><span class="pre">spam</span></code> 이 서브 모듈 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 를 가지면, <code class="docutils literal notranslate"><span class="pre">spam.foo</span></code> 를 임포트한 후에는 <code class="docutils literal notranslate"><span class="pre">spam</span></code> 이 서브 모듈에 연결된 어트리뷰트 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 를 갖게 된다. 다음과 같은 디렉터리 구조로 되어 있다고 하자:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">spam</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">foo</span><span class="o">.</span><span class="n">py</span>
    <span class="n">bar</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>그리고 <code class="docutils literal notranslate"><span class="pre">spam/__init__.py</span></code> 가 다음과 같은 줄들을 포함한다고 하자:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">.foo</span> <span class="k">import</span> <span class="n">Foo</span>
<span class="kn">from</span> <span class="nn">.bar</span> <span class="k">import</span> <span class="n">Bar</span>
</pre></div>
</div>
<p>그러면 다음과 같이 실행하면 <code class="docutils literal notranslate"><span class="pre">spam</span></code> 모듈에 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 와 <code class="docutils literal notranslate"><span class="pre">bar</span></code> 에 대한 이름 연결이 일어난다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spam</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="o">.</span><span class="n">foo</span>
<span class="go">&lt;module &#39;spam.foo&#39; from &#39;/tmp/imports/spam/foo.py&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="o">.</span><span class="n">bar</span>
<span class="go">&lt;module &#39;spam.bar&#39; from &#39;/tmp/imports/spam/bar.py&#39;&gt;</span>
</pre></div>
</div>
<p>파이썬의 익숙한 이름 연결 규칙에서 볼 때 의외의 결과로 보일 수 있다. 하지만 실제로는 임포트 시스템의 근본적인 기능이다. 불변의 규칙은 이렇다: 만약 <code class="docutils literal notranslate"><span class="pre">sys.modules['spam']</span></code> 과 <code class="docutils literal notranslate"><span class="pre">sys.modules['spam.foo']</span></code> 가 있다면 (위의 임포트 이후의 상태가 그러하다), 뒤에 있는 것은 반드시 앞에 있는 것의 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 어트리뷰트가 되어야 한다.</p>
</div>
<div class="section" id="module-spec">
<h3>5.4.3. 모듈 스펙<a class="headerlink" href="#module-spec" title="永久链接至标题">¶</a></h3>
<p>임포트 절차는 임포트 동안 각 모듈에 대한 다양한 정보들을 사용한다, 특히 로딩 전에. 대부분 정보는 모든 모듈의 공통이다. 모듈 스펙의 목적은 이 임포트 관련 정보를 모듈별로 요약하는 것이다.</p>
<p>임포트 동안 스펙을 사용하면 상태가 임포트 시스템의 구성 요소들로 전달될 수 있다, 예를 들어 모듈 스펙을 만드는 파인더와 그것을 실행하는 로더 간에. 가장 중요한 것은, 임포트 절차가 로딩의 공통 연산(boilerplate operation)을 수행할 수 있도록 하는 것이다. 모듈 스펙이 없다면 로더가 모든 책임을 지게 된다.</p>
<p>모듈의 스펙은 모듈 객체의 <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> 어트리뷰트로 노출된다. 모듈 스펙의 내용에 대한 세부 사항은 <a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a> 을 보면 된다.</p>
<div class="versionadded">
<p><span class="versionmodified">3.4 新版功能.</span></p>
</div>
</div>
<div class="section" id="import-related-module-attributes">
<span id="import-mod-attrs"></span><h3>5.4.4. 임포트 관련 모듈 어트리뷰트<a class="headerlink" href="#import-related-module-attributes" title="永久链接至标题">¶</a></h3>
<p>임포트 절차는 로딩하는 동안 로더가 모듈을 실행하기 전에 모듈의 스팩에 기초해서 각 모듈 객체에 이 어트리뷰트들을 채워 넣는다.</p>
<dl class="attribute">
<dt id="__name__">
<code class="descname">__name__</code><a class="headerlink" href="#__name__" title="永久链接至目标">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">__name__</span></code> 어트리뷰트는 모듈의 완전히 정규화된(fully-qualified) 이름으로 설정되어야 한다. 이 이름은 임포트 시스템이 모듈을 유일하게(uniquely) 식별하는 데 사용된다.</p>
</dd></dl>

<dl class="attribute">
<dt id="__loader__">
<code class="descname">__loader__</code><a class="headerlink" href="#__loader__" title="永久链接至目标">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">__loader__</span></code> 어트리뷰트는 모듈을 로드할 때 임포트 절차가 사용한 로더 객체로 설정되어야 한다. 이것은 주로 인트로스펙션(introspection)을 위한 것이지만, 추가적인 로더에 국한된 기능들을 위한 것이기도 하다, 예를 들어 로더와 결합한 데이터를 얻는 것이 있다.</p>
</dd></dl>

<dl class="attribute">
<dt id="__package__">
<code class="descname">__package__</code><a class="headerlink" href="#__package__" title="永久链接至目标">¶</a></dt>
<dd><p>모듈의 <code class="docutils literal notranslate"><span class="pre">__package__</span></code> 어트리뷰트는 반드시 설정되어야 한다. 값은 문자열이어야 하는데, <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 과 같은 값일 수 있다. 모듈이 패키지일 때, <code class="docutils literal notranslate"><span class="pre">__package__</span></code> 값은 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 으로 설정되어야 한다. 모듈이 패키지가 아닐 때, 최상위 모듈이면 빈 문자열로 설정되고, 서브 모듈아면 부모 패키지의 이름으로 설정되어야 한다. 더 상세한 내용은 <span class="target" id="index-48"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a> 을 참고하면 된다.</p>
<p><span class="target" id="index-49"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a> 에 정의되어 있듯이, 메인 모듈에서 명시적인 상대 임포트를 계산할 때 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 대신 이 어트리뷰트가 사용된다. <code class="docutils literal notranslate"><span class="pre">__spec__.parent</span></code> 과 같은 값일 것으로 기대된다.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.6 版更改: </span><code class="docutils literal notranslate"><span class="pre">__package__</span></code> 의 값이 <code class="docutils literal notranslate"><span class="pre">__spec__.parent</span></code> 과 같을 것으로 기대된다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="__spec__">
<code class="descname">__spec__</code><a class="headerlink" href="#__spec__" title="永久链接至目标">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">__spec__</span></code> 어트리뷰트는 모듈을 임포트할 때 사용한 모듈 스펙으로 설정되어야 한다. <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> 을 적절히 설정하는 것은 <a class="reference internal" href="toplevel_components.html#programs"><span class="std std-ref">인터프리터가 구동되는 동안 초기화되는 모듈들</span></a> 에도 마찬가지로 적용된다. 한가지 예외는 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 인데, 어떤 경우에 <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> 이 <a class="reference internal" href="#main-spec"><span class="std std-ref">어떤 경우에 None 으로 설정된다</span></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">__package__</span></code> 가 정의되지 않으면, 대체물로 <code class="docutils literal notranslate"><span class="pre">__spec__.parent</span></code> 가 사용된다.</p>
<div class="versionadded">
<p><span class="versionmodified">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">在 3.6 版更改: </span><code class="docutils literal notranslate"><span class="pre">__package__</span></code> 가 정의되지 않으면, 대체물로 <code class="docutils literal notranslate"><span class="pre">__spec__.parent</span></code> 가 사용된다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="__path__">
<code class="descname">__path__</code><a class="headerlink" href="#__path__" title="永久链接至目标">¶</a></dt>
<dd><p>모듈이 패키지면 (정규 또는 이름 공간), 모듈 객체의 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트가 반드시 설정되어야 한다. 값은 이터러블이어야 하는데, <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 가 더는 의미가 없으면 빈 이터러블일 수 있다. 만약 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 가 비어있지 않다면, 탐색할 때 문자열을 제공해야 한다. <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 의 의미에 관한 자세한 내용은 <a class="reference internal" href="#package-path-rules"><span class="std std-ref">아래에</span></a> 나온다.</p>
<p>패키지가 아닌 모듈은 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트가 없어야 한다.</p>
</dd></dl>

<dl class="attribute">
<dt id="__file__">
<code class="descname">__file__</code><a class="headerlink" href="#__file__" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="__cached__">
<code class="descname">__cached__</code><a class="headerlink" href="#__cached__" title="永久链接至目标">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">__file__</span></code> 은 생략될 수 있다. 만약 설정되면, 이 어트리뷰트의 값은 문자열이어야 한다. 임포트 시스템은 의미가 없을 때(예를 들어 데이터베이스에서 로드된 모듈) <code class="docutils literal notranslate"><span class="pre">__file__</span></code> 을 설정하지 않을 수 있다.</p>
<p>만약 <code class="docutils literal notranslate"><span class="pre">__file__</span></code> 이 설정되면, <code class="docutils literal notranslate"><span class="pre">__cached__</span></code> 역시 설정하는 것이 적절할 수 있는데, 코드의 컴파일된 버전(예를 들어, 바이트 컴파일된 파일)을 가리키는 경로다. 이 어트리뷰트를 설정하기 위해 파일이 꼭 존재해야 할 필요는 없다; 경로는 단순히 컴파일된 파일이 있어야 할 곳을 가리킬 수 있다(<span class="target" id="index-50"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a> 을 보라).</p>
<p><code class="docutils literal notranslate"><span class="pre">__file__</span></code> 이 설정되지 않을 때도, <code class="docutils literal notranslate"><span class="pre">__cached__</span></code> 를 설정하는 것이 적절할 수 있다. 하지만, 그런 시나리오는 아주 예외적이다. 궁극적으로, 로더가 <code class="docutils literal notranslate"><span class="pre">__file__</span></code> 이나 <code class="docutils literal notranslate"><span class="pre">__cached__</span></code> 혹은 둘 모두를 사용한다. 그래서 로더가 캐싱된 모듈을 로드할 수는 있지만, 파일로부터 직접 로드할 수 없다면, 예외적인 시나리오가 적절할 수 있다.</p>
</dd></dl>

</div>
<div class="section" id="module-path">
<span id="package-path-rules"></span><h3>5.4.5. module.__path__<a class="headerlink" href="#module-path" title="永久链接至标题">¶</a></h3>
<p>By definition, if a module has a <code class="docutils literal notranslate"><span class="pre">__path__</span></code> attribute, it is a package.</p>
<p>패키지의 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트는 서브 패키지를 로딩할 때 사용한다. 임포트 절차 내에서, 임포트하는 동안 모듈을 검색할 위치들의 목록을 제공한다는 점에서 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 와 같은 기능을 갖는다. 하지만 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 는 보통 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 보다 제약 조건이 많다.</p>
<p><code class="docutils literal notranslate"><span class="pre">__path__</span></code> 는 문자열의 이터러블이지만, 비어있을 수 있다. <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 과 같은 규칙이 패키지의 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 에도 적용되고, 패키지의 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 를 탐색하는 동안 <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> (아래에서 설명한다)에게 의견을 묻는다.</p>
<p>패키지의 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 파일은 패키지의 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트를 설정하거나 변경할 수 있고, 이것이 <span class="target" id="index-51"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> 이전에 이름 공간 패키지를 구현하는 방법으로 사용됐다. <span class="target" id="index-52"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> 의 도입으로 인해, 이름 공간 패키지가 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 조작 코드만을 포함하는 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 파일을 제공할 필요가 없어졌다; 임포트 절차가 자동으로 이름 공간 패키지를 위한 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 를 설정한다.</p>
</div>
<div class="section" id="module-reprs">
<h3>5.4.6. 모듈 repr<a class="headerlink" href="#module-reprs" title="永久链接至标题">¶</a></h3>
<p>기본적으로, 모든 모듈은 사용할만한 repr 을 갖고 있다. 하지만 위의 어트리뷰트들과 모듈 스펙에 있는 것들에 따라, 모듈 객체의 repr 을 좀 더 명시적으로 제어할 수 있다.</p>
<p>모듈이 스펙(<code class="docutils literal notranslate"><span class="pre">__spec__</span></code>)을 가지면, 임포트 절차는 그것으로부터 repr 을 만들려고 시도한다. 그것이 실패하거나 스펙이 없으면, 임포트 시스템은 모듈에서 제공되는 것들로 기본 repr 을 구성한다. <code class="docutils literal notranslate"><span class="pre">module.__name__</span></code>, <code class="docutils literal notranslate"><span class="pre">module.__file__</span></code>, <code class="docutils literal notranslate"><span class="pre">module.__loader__</span></code> 을 repr 의 입력으로 사용하려고 시도하는데, 빠진 정보는 기본값으로 채운다.</p>
<p>사용되고 있는 정확한 규칙은 이렇다:</p>
<blockquote>
<div><ul class="simple">
<li>모듈이 <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> 어트리뷰트를 가지면, 스펙에 있는 정보로 repr 을 생성한다. “name”, “loader”, “origin”, “has_location” 어트리뷰트들이 사용된다.</li>
<li>모듈이 <code class="docutils literal notranslate"><span class="pre">__file__</span></code> 어트리뷰트를 가지면, 모듈의 repr 의 일부로 사용된다.</li>
<li>모듈이 <code class="docutils literal notranslate"><span class="pre">__file__</span></code> 어트리뷰트를 갖지 않지만 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 아닌 <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> 를 가지면, 로더의 repr 이 모듈의 repr 의 일부로 사용된다.</li>
<li>그렇지 않으면, repr 에 모듈의 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 을 사용한다.</li>
</ul>
</div></blockquote>
<div class="versionchanged">
<p><span class="versionmodified">在 3.4 版更改: </span><a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.module_repr" title="importlib.abc.Loader.module_repr"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loader.module_repr()</span></code></a> 의 사용이 디프리케이트 되었고 이제 모듈 repr 를 만드는데 임포트 절차에 의해 모듈 스펙이 사용된다.</p>
<p>파이썬 3.3과의 과거 호환성을 위해, 위에서 설명한 방법들을 시도하기 전에, 만약 정의되어 있으면, 로더의 <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.module_repr" title="importlib.abc.Loader.module_repr"><code class="xref py py-meth docutils literal notranslate"><span class="pre">module_repr()</span></code></a> 메서드를 호출해서 모듈 repr 을 만든다. 하지만, 그 메서드는 디프리케이트 되었다.</p>
</div>
</div>
</div>
<div class="section" id="the-path-based-finder">
<h2>5.5. 경로 기반 파인더<a class="headerlink" href="#the-path-based-finder" title="永久链接至标题">¶</a></h2>
<p id="index-16">앞에서 언급했듯이, 파이썬은 여러 기본 메타 경로 파인더들을 갖고 있다. 이 중 하나는, <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">경로 기반 파인더</span></a> (<a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder" title="importlib.machinery.PathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathFinder</span></code></a>) 라고 불리는데, <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">경로 엔트리</span></a> 들의 목록을 담고 있는 <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">임포트 경로</span></a> 를 검색한다. 각 경로 엔트리는 모듈을 찾을 곳을 가리킨다.</p>
<p>경로 기반 파인더 자신은 뭔가를 임포트하는 법에 대해서는 아는 것이 없다. 대신에, 각 경로 엔트리를 탐색하면서, 각각을 구체적인 경로 엔트리를 다루는 법을 아는 경로 엔트리 파인더와 관련시킨다.</p>
<p>경로 엔트리 파인더의 기본 집합은 파일 시스템에서 모듈을 찾는데 필요한 모든 개념을 구현하는데, 파이썬 소스 코드(<code class="docutils literal notranslate"><span class="pre">.py</span></code> 파일들), 파이썬 바이트 코드(<code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일들), 공유 라이브러리(예를 들어 <code class="docutils literal notranslate"><span class="pre">.so</span></code> 파일들)와 같은 특수 파일형들을 처리한다. 표준라이브러리의 <a class="reference internal" href="../library/zipimport.html#module-zipimport" title="zipimport: support for importing Python modules from ZIP archives."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipimport</span></code></a> 모듈의 지원을 받으면, 기본 경로 엔트리 파인더는 이 모든 파일들(공유 라이브러리를 제외한 것들)을 zip 파일들로부터 로딩한다.</p>
<p>경로 엔트리가 파일 시스템의 위치로 제한될 필요는 없다. URL이나 데이터베이스 조회나 문자열로 지정될 수 있는 어떤 위치도 가능하다.</p>
<p>경로 기반 파인더는 검색 가능한 경로 엔트리의 유형을 확장하고 커스터마이즈할 수 있도록 하는 추가의 훅과 프로토콜을 제공한다. 예를 들어, 네트워크 URL을 경로 엔트리로 지원하고 싶다면, 웹에서 모듈을 찾는 HTTP 개념을 구현하는 훅을 작성할 수 있다. 이 훅 (콜러블)은 아래에서 설명하는 프로토콜을 지원하는 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a> 를 돌려주는데, 웹에 있는 모듈을 위한 로더를 얻는 데 사용된다.</p>
<p>경고의 글: 이 섹션과 앞에 나온 것들은 모두 파인더라는 용어를 사용하는데, <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">메타 경로 파인더</span></a> 와 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a> 라는 용어를 사용해서 구분한다. 이 두 종류의 파인더는 매우 유사해서 비슷한 프로토콜을 지원하고 임포트 절차에서 비슷한 방식으로 기능한다. 하지만 이것들이 미묘하게 다르다는 것을 기억하는 것이 중요하다. 특히, 메타 경로 파인더는 임포트 절차의 처음에 개입하는데, <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 탐색을 통해 들어온다.</p>
<p>반면에, 경로 엔트리 파인더는 경로 기반 파인더의 구현 상세인데, 사실 경로 기반 파인더가 <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 로 부터 제거되면, 경로 엔트리 파인더의 개념은 일절 호출되지 않는다.</p>
<div class="section" id="path-entry-finders">
<h3>5.5.1. 경로 엔트리 파인더<a class="headerlink" href="#path-entry-finders" title="永久链接至标题">¶</a></h3>
<p id="index-17"><a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">경로 기반 파인더</span></a> 는 위치가 문자열 <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">경로 엔트리</span></a> 로 지정된 파이썬 모듈과 패키지를 찾고 로드하는 책임을 진다. 대부분의 경로 엔트리는 파일 시스템의 위치를 가리키지만, 이것으로 한정될 필요는 없다.</p>
<p>메타 경로 파인더로서, <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">경로 기반 파인더</span></a> 는 앞에서 설명한 <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 프로토콜을 구현한다. 하지만 모듈이 <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">임포트 경로</span></a> 에서 어떻게 발견되고 로드되는지는 커스터마이즈하는데 사용될 수 있는 추가의 훅을 제공한다.</p>
<p><a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">경로 기반 파인더</span></a> 는 세 개의 변수를 사용한다, <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>, <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>, <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>. 패키지 객체의 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트 또한 사용된다. 이것들은 임포트 절차를 커스터마이즈할 수 있는 추가의 방법을 제공한다.</p>
<p><a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 는 모듈과 패키지의 검색 위치를 제공하는 문자열의 목록을 포함한다. <code class="xref py py-data docutils literal notranslate"><span class="pre">PYTHONPATH</span></code> 환경 변수와 여러 가지 설치와 구현 특정 기본값들로부터 초기화된다. <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 에 있는 엔트리들은 파일 시스템의 디렉터리와 zip 파일을 가리키고, 그밖에 잠재적으로 모듈 검색에 사용될 수 있는 &quot;장소들&quot;(<a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 모듈을 보라)을 가리킬 수 있는데, URL이나 데이터베이스 조회 같은 것들이다. <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 에는 문자열과 바이트열만 있어야 한다; 다른 모든 형은 무시된다. 바이트열의 인코딩은 개별 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a> 들에 의해 결정된다.</p>
<p><a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">경로 기반 파인더</span></a> 는 <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">메타 경로 파인더</span></a> 이기 때문에, 앞에서 설명했듯이 임포트 절차는 경로 기반 파인더의 <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 메서드를 호출하는 것으로 <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">임포트 경로</span></a> 검색을 시작한다. <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 에 제공되는 <code class="docutils literal notranslate"><span class="pre">path</span></code> 인자는 탐색할 문자열 경로들의 리스트다 - 보통 패키지 내에서 임포트할 경우 패키지의 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트. <code class="docutils literal notranslate"><span class="pre">path</span></code> 인자가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, 최상위 임포트를 뜻하고 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 가 사용된다.</p>
<p>경로 기반 파인더는 검색 경로의 모든 엔트리를 탐색하고, 개별 엔트리마다 적절한 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a> (<a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathEntryFinder</span></code></a>)를 찾는다. 이것은 비용이 많이 드는 연산일 수 있기 때문에(예를 들어, 이 검색을 위해 <cite>stat()</cite> 호출로 인한 부하가 있을 수 있다), 경로 기반 파인더는 경로 엔트리를 경로 엔트리 파인더로 매핑하는 캐시를 관리한다. 이 캐시는 <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 에 유지된다 (이름에도 불구하고, 이 캐시는 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">임포터</span></a> 객체로 제한되지 않고 실제로는 파인더 객체를 저장한다). 이런 방법으로, 특정 <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">경로 엔트리</span></a> 위치의 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a> 의 비싼 검색은 오직 한 번만 수행된다. 사용자 코드가 <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 의 캐시 엔트리를 삭제해서 경로 기반 파인더가 그 경로 엔트리를 다시 검색하도록 하는 것이 허락된다 <a class="footnote-reference" href="#fnpic" id="id3">[3]</a>.</p>
<p>경로 엔트리가 캐시에 없으면, 경로 기반 파인더는 <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> 에 있는 모든 콜러블들을 탐색한다. 이 목록의 각 <a class="reference internal" href="../glossary.html#term-path-entry-hook"><span class="xref std std-term">경로 엔트리 훅</span></a> 은 검색할 경로 엔트리 인자 한 개를 사용해서 호출된다. 이 콜러블은 경로 엔트리를 다룰 수 있는 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a> 를 돌려주거나, <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 를 발생시킬 수 있다. <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 는 경로 기반 파인더가 어떤 훅이 주어진 <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">경로 엔트리</span></a> 를 위한 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a> 를 발견할 수 없음을 알리는 데 사용한다. 이 예외는 무시되고 <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">임포트 경로</span></a> 탐색은 계속된다. 훅은 문자열이나 바이트열을 기대해야 한다; 바이트열의 인코딩은 훅이 결정하고(예를 들어, 파일 시스템 인코딩이나 UTF-8 이나 그 밖의 다른 것일 수 있다), 만약 훅이 인자를 디코딩할 수 없으면 <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 를 일으켜야 한다.</p>
<p>만약 <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> 탐색이 아무런 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a> 를 돌려주지 못하면, 경로 기반 파인더의 <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 메서드는 <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 에 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 저장하고(이 경로 엔트리를 위한 파인더가 없음을 가리키기 위해), <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 돌려줘서 이 <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">메타 경로 파인더</span></a> 가 모듈을 찾을 수 없음을 알린다.</p>
<p>만약 <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> 에 있는 어느 하나의 <a class="reference internal" href="../glossary.html#term-path-entry-hook"><span class="xref std std-term">경로 엔트리 훅</span></a> 콜러블이 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a> 를 <em>돌려주면</em>, 파인더에 모듈 스펙을 요청하기 위해 다음에 나오는 프로토콜이 사용된다. 모듈 스펙은 모듈을 로딩할 때 사용된다.</p>
<p>현재 작업 디렉터리(current working directory) -- 빈 문자열로 표현된다 -- 는 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 에 있는 다른 엔트리들과 약간 다르게 취급된다. 첫째로, 현재 작업 디렉터리가 존재하지 않음이 발견되면 <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 에는 아무런 값도 저장되지 않는다. 둘째로, 현재 작업 디렉터리는 각 모듈 조회 때마다 다시 확인된다. 셋째로, <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 에 사용되는 경로와 <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.PathFinder.find_spec()</span></code></a> 가 돌려주는 경로는 빈 문자열이 아니라 실제 현재 작업 디렉터리가 된다.</p>
</div>
<div class="section" id="path-entry-finder-protocol">
<h3>5.5.2. 경로 엔트리 파인더 프로토콜<a class="headerlink" href="#path-entry-finder-protocol" title="永久链接至标题">¶</a></h3>
<p>모듈과 초기화된 패키지의 임포트를 지원하고 이름 공간 패키지에 포션으로 이바지하기 위해, 경로 엔트리 파인더는 <a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 메서드를 구현해야 한다.</p>
<p><a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 은 두 개의 인자를 받아들인다, 임포트할 모듈의 완전히 정규화된 이름과 (생략 가능한) 타깃 모듈. <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code> 은 값이 완전히 채워진 모듈의 스펙을 돌려준다. 이 스펙은 항상 &quot;loader&quot; 가 설정된다(한가지 예외가 있다).</p>
<p>스펙이 이름 공간의 <a class="reference internal" href="../glossary.html#term-portion"><span class="xref std std-term">포션</span></a> 을 표현한다는 것을 임포트 절차에 알리기 위해, 경로 엔트리 파인더는 스펙의 &quot;loader&quot; 를 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정하고 &quot;submodule_search_locations&quot; 를 포션을 포함하는 목록으로 설정한다.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.4 版更改: </span><a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 이 <a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_loader" title="importlib.abc.PathEntryFinder.find_loader"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_loader()</span></code></a> 와 <a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_module" title="importlib.abc.PathEntryFinder.find_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code></a> 를 대체하는데, 둘 다 이제 디프리케이트되었다, <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code> 이 정의되지 않으면 이것들을 사용한다.</p>
<p>예전의 경로 엔트리 파인더는 <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code> 대신에 이 두 개의 디프리케이트된 메서드들을 구현할 수 있다. 이 메서드들은 과거 호환성 때문에 아직도 사용된다. 하지만, <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code> 이 경로 엔트리 파인더에 구현되면, 예전 메서드들은 무시된다.</p>
<p><a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_loader" title="importlib.abc.PathEntryFinder.find_loader"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_loader()</span></code></a> 는 하나의 인자를 받아들인다, 임포트되는 모듈의 완전히 정규화된 이름. <code class="docutils literal notranslate"><span class="pre">find_loader()</span></code> 는 2-튜플을 돌려주는데, 첫 번째 항목은 로더이고 두 번째 항목은 이름 공간 <a class="reference internal" href="../glossary.html#term-portion"><span class="xref std std-term">포션</span></a> 이다. 첫 번째 항목(즉 로더)이 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, 경로 엔트리 파인더가 주어진 이름의 모듈에 대한 로더를 제공하지는 못하지만, 경로 엔트리가 주어진 이름의 모듈에 대한 이름 공간 포션에 이바지함을 안다는 뜻이다. 이것은 거의 항상, 파이썬이 파일 시스템에 물리적으로 존재하지 않는 이름 공간 패키지를 임포트하도록 요구되는 경우다. 경로 엔트리 파인더가 로더로 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 돌려줄 때, 2-튜플의 두 번째 항목은 시퀀스여야 하는데 비어있을 수도 있다.</p>
<p><code class="docutils literal notranslate"><span class="pre">find_loader()</span></code> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 아닌 로더 값을 돌려주면, 그 포션은 무시되고 경로 기반 파인더가 로더를 돌려주며 경로 엔트리 검색을 종료한다.</p>
<p>임포트 프로토콜의 다른 구현들과의 과거 호환성을 위해, 많은 경로 엔트리 파인더들은 메타 경로 파인더가 지원하는 것과 같고 전통적인 <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> 메서드 또한 지원한다. 하지만 경로 엔트리 파인더 <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> 메서드는 결코 <code class="docutils literal notranslate"><span class="pre">path</span></code> 인자로 호출되지 않는다 (그것들은 경로 훅의 최초 호출 때 적절한 경로 정보를 기록해둘 것으로 기대된다).</p>
<p>경로 엔트리 파인더의 <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> 메서드는 경로 엔트리 파인더가 이름 공간 패키지에 포션으로 이바지하는 것을 허락하지 않기 때문에 디프리케이트 되었다. 만약 경로 엔트리 파인더에 <code class="docutils literal notranslate"><span class="pre">find_loader()</span></code> 와 <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> 이 모두 존재하면, 임포트 시스템은 항상 <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> 대신 <code class="docutils literal notranslate"><span class="pre">find_loader()</span></code> 를 호출한다.</p>
</div>
</div>
</div>
<div class="section" id="replacing-the-standard-import-system">
<h2>5.6. 표준 임포트 시스템 교체하기<a class="headerlink" href="#replacing-the-standard-import-system" title="永久链接至标题">¶</a></h2>
<p>임포트 시스템 전체를 교체하기 위한 가장 신뢰성 있는 메커니즘은 <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 의 기본값들을 모두 삭제하고, 새로 만든 메타 경로 훅들로 채우는 것이다.</p>
<p>만약 임포트 시스템을 액세스하는 다른 API들에 영향을 주지 않고, 단지 임포트 문의 동작만을 변경해도 좋다면, 내장 <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수를 교체하는 것으로 충분할 수도 있다. 이 기법은 특정 모듈 내에서의 임포트 문의 동작만을 변경하도록 모듈 수준에서 적용될 수도 있다.</p>
<p>메타 경로의 앞쪽에 있는 훅에서 어떤 모듈의 임포트를 선택적으로 막으려면(표준 임포트 시스템을 완전히 비활성화하는 대신), <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 에서 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 돌려주는 대신, <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> 를 일으키는 것으로 충분하다. 전자는 메타 경로 검색을 계속해야 한다는 것을 지시하는 반면, 예외를 일으키면 즉시 종료시킨다.</p>
</div>
<div class="section" id="special-considerations-for-main">
<h2>5.7. __main__ 에 대한 특별한 고려<a class="headerlink" href="#special-considerations-for-main" title="永久链接至标题">¶</a></h2>
<p><a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 모듈은 파이썬의 임포트 시스템에서 특별한 경우다. <a class="reference internal" href="toplevel_components.html#programs"><span class="std std-ref">다른 곳에서</span></a> 언급했듯이, <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 모듈은 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 와 <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 처럼 인터프리터 시작 때 직접 초기화된다. 하지만, 이 두 개와는 다르게, 이것은 엄밀하게 내장 모듈로 취급되지 않는다. 이것은 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 이 초기화되는 방식이 인터프리터를 실행할 때 주는 플래그와 다른 옵션들에 영향을 받기 때문이다.</p>
<div class="section" id="main-spec">
<span id="id4"></span><h3>5.7.1. __main__.__spec__<a class="headerlink" href="#main-spec" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 이 어떻게 초기화되는지에 따라, <code class="docutils literal notranslate"><span class="pre">__main__.__spec__</span></code> 은 적절히 설정되기도 하고 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정되기도 한다.</p>
<p>파이썬이 <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> 옵션으로 시작하면, <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> 은 해당하는 모듈이나 패키지의 모듈 스팩으로 설정된다. 또한 <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> 은 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 모듈이 디렉터리나 zip 파일이나 다른 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 엔트리를 실행하는 일부로 로드될 때 그 내용이 채워진다.</p>
<p><a class="reference internal" href="../using/cmdline.html#using-on-interface-options"><span class="std std-ref">나머지 경우</span></a> 에는 <code class="docutils literal notranslate"><span class="pre">__main__.__spec__</span></code> 은 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정되는데, <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 을 채우는데 사용된 코드가 임포트 가능한 모듈에 직접 대응하지 않기 때문이다:</p>
<ul class="simple">
<li>대화형 프롬프트</li>
<li>-c 스위치</li>
<li>표준 입력으로 실행</li>
<li>소스 파일이나 바이트 코드 파일로부터 직접 실행</li>
</ul>
<p>마지막 경우에 <code class="docutils literal notranslate"><span class="pre">__main__.__spec__</span></code> 이 항상 <code class="docutils literal notranslate"><span class="pre">None</span></code> 임에 주의해야 한다. 설사 그 파일이 기술적으로 모듈로 임포트 될 수 있어도 그렇다. <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 에 올바른 모듈 메타데이터가 필요하다면 <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> 스위치를 사용해야 한다.</p>
<p>또한 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 이 임포트 가능한 모듈에 대응되고, <code class="docutils literal notranslate"><span class="pre">__main__.__spec__</span></code> 이 적절히 설정되었다 하더라도, 이 둘은 여전히 <em>다른</em> 모듈로 취급됨에 주의해야 한다. 이것은 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">&quot;__main__&quot;:</span></code> 검사로 둘러싸인 블록이 모듈이 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 이름 공간을 채울 때만 실행되고, 일반적인 임포트 때는 실행되지 않는다는 사실 때문이다.</p>
</div>
</div>
<div class="section" id="open-issues">
<h2>5.8. 열린 이슈들<a class="headerlink" href="#open-issues" title="永久链接至标题">¶</a></h2>
<p>XXX 도표가 있으면 정말 좋겠다.</p>
<p>XXX * (import_machinery.rst) 모듈과 패키지의 어트리뷰트들에만 할당된 섹션은 어떨까? 아마도 데이터 모델 레퍼런스 페이지에 있는 관련 항목들을 확장하거나 대체해야 할 것이다.</p>
<p>XXX 라이브러리 설명서의 runpy, pkgutil 등등은 새 임포트 시스템 섹션으로 가는 &quot;See Also&quot; 링크를 처음에 붙여야만 한다.</p>
<p>XXX <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 이 초기화되는 다른 방법들에 대한 설명을 더 붙여야 하나?</p>
<p>XXX <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 의 까다로움/어려움에 대한 정보를 추가하자 (즉 <span class="target" id="index-53"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0395"><strong>PEP 395</strong></a> 의 사본)</p>
</div>
<div class="section" id="references">
<h2>5.9. 참고문헌<a class="headerlink" href="#references" title="永久链接至标题">¶</a></h2>
<p>임포트 절차는 파이썬의 초창기부터 상당히 변해왔다. 문서를 작성한 이후에 약간의 세부사항이 변경되었기는 하지만, 최초의 <a class="reference external" href="https://www.python.org/doc/essays/packages/">패키지 규격</a> 은 아직 읽을 수 있도록 남아있다.</p>
<p><a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 의 최초 규격은 <span class="target" id="index-54"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> 이고, 뒤이은 확장은 <span class="target" id="index-55"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> 이다.</p>
<p><span class="target" id="index-56"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> 은 파이썬 3.3 에 <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">이름 공간 패키지</span></a> 를 도입했다. PEP 420은 <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code> 의 대안으로 <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_loader()</span></code> 프로토콜 역시 도입했다.</p>
<p><span class="target" id="index-57"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a> 은 메인 모듈에서의 명시적인 상태 임포트를 위한 <code class="docutils literal notranslate"><span class="pre">__package__</span></code> 어트리뷰트의 추가에 관해 설명하고 있다.</p>
<p><span class="target" id="index-58"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a> 은 절대와 명시적인 상대 임포트들 도입하고 <span class="target" id="index-59"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a> 이 결국 <code class="docutils literal notranslate"><span class="pre">__package__</span></code> 를 지정하게 되는 개념을 초기에 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 으로 제안했다.</p>
<p><span class="target" id="index-60"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0338"><strong>PEP 338</strong></a> 은 모듈을 스크립트로 실행하는 것을 정의한다.</p>
<p><span class="target" id="index-61"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0451"><strong>PEP 451</strong></a> 은 스팩 객체에 모듈별 임포트 상태를 요약하는 것을 추가한다. 로더들에 주어졌던 대부분의 공통 코드 책임들을 임포트 절차로 옮기기도 했다. 이 변경은 임포트 시스템의 여러 API 들을 디프리케이트하도록 만들었고, 파인더와 로더에 새 메서드들을 추가하기도 했다.</p>
<p class="rubric">각주</p>
<table class="docutils footnote" frame="void" id="fnmo" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a> 을 보라.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="fnlo" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>importlib 구현은 반환 값을 직접 사용하지 않는다. 대신에, <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에서 모듈 이름을 조회해서 모듈을 얻는다. 이것의 간접적인 효과는 임포트되는 모듈이 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 있는 자신을 바꿀 수 있다는 것이다. 이것은 구현 상세 동작이고 다른 파이썬 구현에서 동작한다고 보장되지 않는다.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="fnpic" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>예전 코드에서, <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 에서 <a class="reference internal" href="../library/imp.html#imp.NullImporter" title="imp.NullImporter"><code class="xref py py-class docutils literal notranslate"><span class="pre">imp.NullImporter</span></code></a> 의 인스턴스를 찾는 것이 가능하다. 코드가 대신 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 사용하도록 변경할 것을 권고한다. 더 자세한 내용은 <a class="reference internal" href="../whatsnew/3.3.html#portingpythoncode"><span class="std std-ref">Porting Python code</span></a> 를 참고하라.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">5. 임포트 시스템</a><ul>
<li><a class="reference internal" href="#importlib">5.1. <code class="docutils literal notranslate"><span class="pre">importlib</span></code></a></li>
<li><a class="reference internal" href="#packages">5.2. 패키지(package)</a><ul>
<li><a class="reference internal" href="#regular-packages">5.2.1. 정규 패키지</a></li>
<li><a class="reference internal" href="#namespace-packages">5.2.2. 이름 공간 패키지</a></li>
</ul>
</li>
<li><a class="reference internal" href="#searching">5.3. 검색</a><ul>
<li><a class="reference internal" href="#the-module-cache">5.3.1. 모듈 캐시</a></li>
<li><a class="reference internal" href="#finders-and-loaders">5.3.2. 파인더(finder)와 로더(loader)</a></li>
<li><a class="reference internal" href="#import-hooks">5.3.3. 임포트 훅(import hooks)</a></li>
<li><a class="reference internal" href="#the-meta-path">5.3.4. 메타 경로(meta path)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#loading">5.4. 로딩(loading)</a><ul>
<li><a class="reference internal" href="#loaders">5.4.1. 로더</a></li>
<li><a class="reference internal" href="#submodules">5.4.2. 서브 모듈</a></li>
<li><a class="reference internal" href="#module-spec">5.4.3. 모듈 스펙</a></li>
<li><a class="reference internal" href="#import-related-module-attributes">5.4.4. 임포트 관련 모듈 어트리뷰트</a></li>
<li><a class="reference internal" href="#module-path">5.4.5. module.__path__</a></li>
<li><a class="reference internal" href="#module-reprs">5.4.6. 모듈 repr</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-path-based-finder">5.5. 경로 기반 파인더</a><ul>
<li><a class="reference internal" href="#path-entry-finders">5.5.1. 경로 엔트리 파인더</a></li>
<li><a class="reference internal" href="#path-entry-finder-protocol">5.5.2. 경로 엔트리 파인더 프로토콜</a></li>
</ul>
</li>
<li><a class="reference internal" href="#replacing-the-standard-import-system">5.6. 표준 임포트 시스템 교체하기</a></li>
<li><a class="reference internal" href="#special-considerations-for-main">5.7. __main__ 에 대한 특별한 고려</a><ul>
<li><a class="reference internal" href="#main-spec">5.7.1. __main__.__spec__</a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-issues">5.8. 열린 이슈들</a></li>
<li><a class="reference internal" href="#references">5.9. 참고문헌</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="executionmodel.html"
                        title="上一章">4. 실행 모델</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="expressions.html"
                        title="下一章">6. 표현식</a></p>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/reference/import.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. 표현식"
             >下一页</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 실행 모델"
             >上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh</span>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">도큐멘테이션 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 언어 레퍼런스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    파이썬 소프트웨어 재단은 비영리 법인입니다.
    <a href="https://www.python.org/psf/donations/">기부를 부탁합니다.</a>
    <br />
    4月 21, 2018 에 마지막으로 업데이트되었습니다.
    <a href="../bugs.html">버그를 찾았나요?</a>
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.7.2 를 사용해서 만들었습니다.
    </div>

  </body>
</html>