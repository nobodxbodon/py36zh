
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>7. 단순문(Simple statements) &#8212; Python 3.6.5 文档</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.6.5 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="8. 복합문(Compound statements)" href="compound_stmts.html" />
    <link rel="prev" title="6. 표현식" href="expressions.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.org/3/reference/simple_stmts.html" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="compound_stmts.html" title="8. 복합문(Compound statements)"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. 표현식"
             accesskey="P">上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh</span>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">도큐멘테이션 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 언어 레퍼런스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="simple-statements">
<span id="simple"></span><h1>7. 단순문(Simple statements)<a class="headerlink" href="#simple-statements" title="永久链接至标题">¶</a></h1>
<p id="index-0">단순문은 하나의 논리적인 줄 안에 구성된다. 여러 개의 단순문이 세미콜론으로 분리되어 하나의 줄에 나올 수 있다. 단순문의 문법은 이렇다:</p>
<pre>
<strong id="grammar-token-simple_stmt">simple_stmt</strong> ::=  <a class="reference internal" href="#grammar-token-expression_stmt"><code class="xref docutils literal notranslate"><span class="pre">expression_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-assert_stmt"><code class="xref docutils literal notranslate"><span class="pre">assert_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-assignment_stmt"><code class="xref docutils literal notranslate"><span class="pre">assignment_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-augmented_assignment_stmt"><code class="xref docutils literal notranslate"><span class="pre">augmented_assignment_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-annotated_assignment_stmt"><code class="xref docutils literal notranslate"><span class="pre">annotated_assignment_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-pass_stmt"><code class="xref docutils literal notranslate"><span class="pre">pass_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-del_stmt"><code class="xref docutils literal notranslate"><span class="pre">del_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-return_stmt"><code class="xref docutils literal notranslate"><span class="pre">return_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-yield_stmt"><code class="xref docutils literal notranslate"><span class="pre">yield_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-raise_stmt"><code class="xref docutils literal notranslate"><span class="pre">raise_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-break_stmt"><code class="xref docutils literal notranslate"><span class="pre">break_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-continue_stmt"><code class="xref docutils literal notranslate"><span class="pre">continue_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-import_stmt"><code class="xref docutils literal notranslate"><span class="pre">import_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-global_stmt"><code class="xref docutils literal notranslate"><span class="pre">global_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-nonlocal_stmt"><code class="xref docutils literal notranslate"><span class="pre">nonlocal_stmt</span></code></a>
</pre>
<div class="section" id="expression-statements">
<span id="exprstmts"></span><h2>7.1. 표현식 문<a class="headerlink" href="#expression-statements" title="永久链接至标题">¶</a></h2>
<span class="target" id="index-1"></span><p id="index-2">표현식 문은 값을 계산하고 출력하거나, (보통) 프로시저(procedure) (의미 없는 결과를 돌려주는 함수; 파이썬에서 프로시저는 <code class="docutils literal notranslate"><span class="pre">None</span></code> 값을 돌려준다)를 호출하기 위해 (대부분 대화형으로) 사용된다. 표현식 문의 다른 사용도 허락되고 때때로 쓸모가 있다.</p>
<pre>
<strong id="grammar-token-expression_stmt">expression_stmt</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-starred_expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a>
</pre>
<p>표현식 문은 (하나의 표현식일 수 있는) 표현식 목록의 값을 구한다.</p>
<p id="index-3">대화형 모드에서, 값이 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 아니면, 내장 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 함수를 사용해 문자열로 변환되고, 그렇게 나온 문자열을 별도의 줄에 표준 출력으로 보낸다 (결과가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 일 때는 그렇지 않아서, 프로시저 호출은 어떤 출력도 만들지 않는다.),</p>
</div>
<div class="section" id="assignment-statements">
<span id="assignment"></span><h2>7.2. 대입문<a class="headerlink" href="#assignment-statements" title="永久链接至标题">¶</a></h2>
<p id="index-4">대입문은 이름을 값에 (재)연결하고 가변 객체의 어트리뷰트나 항목들을 수정한다.</p>
<pre>
<strong id="grammar-token-assignment_stmt">assignment_stmt</strong> ::=  (<a class="reference internal" href="#grammar-token-target_list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a> &quot;=&quot;)+ (<a class="reference internal" href="expressions.html#grammar-token-starred_expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-yield_expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a>)
<strong id="grammar-token-target_list">target_list    </strong> ::=  <a class="reference internal" href="#grammar-token-target"><code class="xref docutils literal notranslate"><span class="pre">target</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-target"><code class="xref docutils literal notranslate"><span class="pre">target</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-target">target         </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
                     | &quot;(&quot; [<a class="reference internal" href="#grammar-token-target_list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a>] &quot;)&quot;
                     | &quot;[&quot; [<a class="reference internal" href="#grammar-token-target_list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a>] &quot;]&quot;
                     | <a class="reference internal" href="expressions.html#grammar-token-attributeref"><code class="xref docutils literal notranslate"><span class="pre">attributeref</span></code></a>
                     | <a class="reference internal" href="expressions.html#grammar-token-subscription"><code class="xref docutils literal notranslate"><span class="pre">subscription</span></code></a>
                     | <a class="reference internal" href="expressions.html#grammar-token-slicing"><code class="xref docutils literal notranslate"><span class="pre">slicing</span></code></a>
                     | &quot;*&quot; <a class="reference internal" href="#grammar-token-target"><code class="xref docutils literal notranslate"><span class="pre">target</span></code></a>
</pre>
<p>(<em>attributeref</em>, <em>subscription</em>, <em>slicing</em> 의 문법 정의는 <a class="reference internal" href="expressions.html#primaries"><span class="std std-ref">프라이머리</span></a> 섹션을 보면 된다.)</p>
<p>대입문은 표현식 목록 (이것이 하나의 표현식일 수도, 쉼표로 분리된 목록일 수도 있는데, 후자의 경우는 튜플이 만들어진다는 것을 기억하라) 의 값을 구하고, 왼쪽에서 오른쪽으로, 하나의 결과 객체를 타깃 목록의 각각에 대입한다.</p>
<p id="index-5">대입은 타깃 (목록)의 형태에 따라 재귀적으로 정의된다. 타깃이 가변 객체의 일부 (어트리뷰트 참조나 서브스크립션이나 슬라이싱) 면, 가변 객체가 최종적으로 대입을 수행해야만 하고, 그것이 올바른지 아닌지를 결정하고, 대입이 받아들여질 수 없으면 예외를 일으킬 수 있다. 다양한 형들이 주시하는 규칙들과 발생하는 예외들은 그 객체 형의 정의에서 주어진다 (<a class="reference internal" href="datamodel.html#types"><span class="std std-ref">표준형 계층</span></a> 섹션을 보라).</p>
<p id="index-6">객체를 타깃 목록, 괄호나 꺾쇠괄호로 둘러싸일 수 있는데 생략할 수 있다, 에 대입하는 것은 다음과 같이 재귀적으로 정의된다.</p>
<ul class="simple">
<li>타깃 목록이 비어있으면: 객체는 빈 이터러블여야만 한다.</li>
<li>타깃 목록이 괄호에 들어있는 하나의 타깃이면: 객체는 타깃에 대입된다.</li>
<li>타깃 목록이 타깃들의 쉼표로 분리된 목록이거나 꺾쇠괄호로 둘러싸인 하나의 타깃이면: 객체는 타깃 목록에 들어있는 타깃의 수와 같은 수의 항목들을 제공하는 이터러블이어야 하고, 왼쪽에서 오른쪽으로 항목들이 대응하는 타깃에 대입된다.<ul>
<li>타깃 목록이 애스터리스크(asterisk)를 앞에 붙인 타깃, &quot;스타드(starred)&quot; 타깃이라고 불린다, 하나를 포함하면: 객체는 적어도 타깃 목록에 나오는 타깃의 수보다 하나 작은 개수의 항목을 제공하는 이터러블이어야 한다. 이터러블의 처음 항목들은, 왼쪽에서 오른쪽으로, 스타드 타깃 앞에 나오는 타깃들에 대입된다. 이터러블의 마지막 항목들은 스타드 타깃 뒤에 나오는 타깃들에 대입된다. 이터러블의 나머지 항목들로 구성된 리스트가 스타드 타깃에 대입된다 (이 리스트는 이어있을 수 있다).</li>
<li>그렇지 않으면: 객체는 타깃 목록에 나오는 타깃의 수와 같은 수의 항목들을 제공하는 이터러블이어야 하고, 항목들은, 왼쪽에서 오른쪽으로, 대응하는 타깃들에 대입된다.</li>
</ul>
</li>
</ul>
<p>하나의 타깃에 대한 객체의 대입은 다음과 같이 재귀적으로 정의된다.</p>
<ul>
<li><p class="first">타깃이 식별자 (이름) 면:</p>
<ul class="simple">
<li>그 이름이 현재 코드 블록에 있는 <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 나 <a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 문에 등장하지 않으면: 그 이름은 현재 지역 이름 공간에서 객체에 연결된다.</li>
<li>그렇지 않으면: 그 이름은 각각 전역 이름 공간이나 <a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 에 의해 결정되는 외부 이름 공간에서 객체에 연결된다.</li>
</ul>
<p id="index-7">그 이름이 이미 연결되어 있으면 재연결된다. 이것은 기존에 연결되어 있던 객체의 참조 횟수가 0이 되도록 만들어서, 객체가 점유하던 메모리가 반납되고 파괴자(destructor) (갖고 있다면) 가 호출되도록 만들 수 있다.</p>
</li>
<li id="index-8"><p class="first">타깃이 어트리뷰트 참조면: 참조의 프라이머리 표현식의 값을 구한다. 이것은 대입 가능한 어트리뷰트를 가진 객체를 주어야 하는데, 그렇지 않으면 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 가 일어난다. 그에 그 객체에 주어진 어트리뷰트로 객체를 대입하도록 요청한다; 대입을 수행할 수 없다면 예외 (보통 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 이지만, 꼭 그럴 필요는 없다) 를 일으킨다.</p>
<p id="attr-target-note">주의 사항: 객체가 클래스 인스턴스이고 어트리뷰트 참조가 대입 연산자의 양쪽에서 모두 등장하면, RHS 표현식, <code class="docutils literal notranslate"><span class="pre">a.x</span></code> 는 인스턴스 어트리뷰트나 (인스턴스 어트리뷰트가 없다면) 클래스 어트리뷰트를 액세스할 수 있다. LHS 타깃 <code class="docutils literal notranslate"><span class="pre">a.x</span></code> 는 항상 필요하면 만들어서라도 항상 인스턴스 어트리뷰트를 설정한다. 그래서, 두 <code class="docutils literal notranslate"><span class="pre">a.x</span></code> 가 같은 어트리뷰트를 가리키는 것은 필요조건이 아니다: RHS 표현식이 클래스 어트리뷰트를 가리킨다면, LHS 는 대입의 타깃으로 새 인스턴스 어트리뷰트를 만든다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cls</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>             <span class="c1"># class variable</span>
<span class="n">inst</span> <span class="o">=</span> <span class="n">Cls</span><span class="p">()</span>
<span class="n">inst</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">inst</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1"># writes inst.x as 4 leaving Cls.x as 3</span>
</pre></div>
</div>
<p>이 설명이 <a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> 로 만들어진 프로퍼티(property)와 같은 디스크립터 어트리뷰트에 적용될 필요는 없다.</p>
</li>
<li id="index-9"><p class="first">타깃이 서브스크립션이면: 참조에 있는 프라이머리 표현식의 값을 구한다. (리스트 같은) 가변 시퀀스 객체나 (딕셔너리 같은) 매핑 객체가 나와야 한다. 그런 다음, 서브 스크립트 표현식의 값을 구한다.</p>
<p id="index-10">프라이머리가 (리스트 같은) 가변 시퀀스 객체면, 서브 스크립트는 정수가 나와야 한다. 음수면, 시퀀스의 길이가 더해진다. 결괏값은 시퀀스의 길이보다 작은 음이 아닌 정수여야 하고, 시퀀스에 그 인덱스를 가진 항목에 객체를 대입하라고 요청한다. 인덱스가 범위를 벗어나면, <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 를 일으킨다 (서브 스크립트 된 시퀀스에 대한 대입은 리스트에 새 항목을 추가할 수 없다).</p>
<p id="index-11">프라이머리가 (딕셔너리 같은) 매핑 객체면, 서브 스크립트는 매핑의 키 형과 호환되는 형이어야 하고, 매핑에 그 서브 스크립트를 객체에 매핑하는 키/데이터 쌍을 만들도록 요청한다. 이때 같은 킷값을 갖는 기존의 키/값 쌍을 대체할 수도 있고, (같은 값의 키가 존재하지 않는 경우) 새 키/값 쌍을 삽입할 수도 있다.</p>
<p>사용자 정의 객체의 경우는, 적절한 인자로 <a class="reference internal" href="datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a> 메서드가 호출된다.</p>
</li>
<li id="index-12"><p class="first">타깃이 슬라이싱이면: 참조의 프라이머리 표현식의 값을 구한다. (리스트 같은) 가변 시퀀스 객체가 나와야 한다. 대입되는 객체는 같은 형의 시퀀스 객체야 한다. 그런 다음, 존재한다면 하한과 상한 표현식의 값을 구한다; 기본값은 0과 시퀀스의 길이다. 경곗값은 정수가 되어야 한다. 둘 중 어느 것이건 음수가 나오면, 시퀀스의 길이를 더한다. 그렇게 얻어진 경곗값들을 0과 시퀀스의 길이나 그 사이에 들어가는 값이 되도록 자른다. 마지막으로 시퀀스 객체에 슬라이스를 대입되는 시퀀스로 변경하도록 요청한다. 타깃 시퀀스가 허락한다면, 슬라이스의 길이는 대입되는 시퀀스의 길이와 다를 수 있다.</p>
</li>
</ul>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> 현재 구현에서, 타깃의 문법은 표현식과 같게 유지되고, 잘못된 문법은 코드 생성 단계에서 거부되기 때문에 에러 메시지가 덜 상세해지는 결과를 낳고 있다.</p>
</div>
<p>설사 대입의 정의가 좌변과 우변 간의 중첩이 '동시적(simultaneous)'임을 (예를 들어, <code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">b,</span> <span class="pre">a</span></code> 는 두 변수를 교환한다) 암시해도, 대입되는 변수들의 컬렉션 <em>안</em> 에서의 중첩은 왼쪽에서 오른쪽으로 일어나서, 때로 혼동할 수 있는 결과를 낳는다. 예를 들어, 다음과 같은 프로그램은 <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">2]</span></code> 를 인쇄한다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>         <span class="c1"># i is updated, then x[i] is updated</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<dl class="last docutils">
<dt><span class="target" id="index-52"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3132"><strong>PEP 3132</strong></a> - 확장 이터러블 언 패킹</dt>
<dd><code class="docutils literal notranslate"><span class="pre">*target</span></code> 기능에 대한 규격</dd>
</dl>
</div>
<div class="section" id="augmented-assignment-statements">
<span id="augassign"></span><h3>7.2.1. 증분 대입문(Augmented assignment statements)<a class="headerlink" href="#augmented-assignment-statements" title="永久链接至标题">¶</a></h3>
<p id="index-14">증분 대입문은 한 문장에서 이항 연산과 대입문을 합치는 것이다:</p>
<pre>
<strong id="grammar-token-augmented_assignment_stmt">augmented_assignment_stmt</strong> ::=  <a class="reference internal" href="#grammar-token-augtarget"><code class="xref docutils literal notranslate"><span class="pre">augtarget</span></code></a> <a class="reference internal" href="#grammar-token-augop"><code class="xref docutils literal notranslate"><span class="pre">augop</span></code></a> (<a class="reference internal" href="expressions.html#grammar-token-expression_list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-yield_expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a>)
<strong id="grammar-token-augtarget">augtarget                </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-attributeref"><code class="xref docutils literal notranslate"><span class="pre">attributeref</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-subscription"><code class="xref docutils literal notranslate"><span class="pre">subscription</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-slicing"><code class="xref docutils literal notranslate"><span class="pre">slicing</span></code></a>
<strong id="grammar-token-augop">augop                    </strong> ::=  &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;&#64;=&quot; | &quot;/=&quot; | &quot;//=&quot; | &quot;%=&quot; | &quot;**=&quot;
                               | &quot;&gt;&gt;=&quot; | &quot;&lt;&lt;=&quot; | &quot;&amp;=&quot; | &quot;^=&quot; | &quot;|=&quot;
</pre>
<p>(마지막 세 기호의 문법 정의는 <a class="reference internal" href="expressions.html#primaries"><span class="std std-ref">프라이머리</span></a> 섹션을 보면 된다.)</p>
<p>증분 대입은 타깃 (일반 대입문과는 달리 언 패킹이 될 수 없다) 과 표현식 목록의 값을 구하고, 둘을 피연산자로 삼아 대입의 형에 맞는 이항 연산을 수행한 후, 원래의 타깃에 그 결과를 대입한다. 타깃은 오직 한 번만 값이 구해진다.</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">1</span></code> 과 같은 증분 대입 표현은 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> 처럼 다시 쓸 수 있는데, 정확히 같은 효과는 아니지만 비슷한 결과를 준다. 증분 버전에서는, <code class="docutils literal notranslate"><span class="pre">x</span></code> 의 값을 오직 한 번만 구한다. 또한, 가능할 때, 실제 연산은 <em>제자리(in-place)</em> 에서 수행되는데, 새 객체를 만들고 그것을 타깃에 대입하기보다는, 예전 객체를 수정한다는 의미다.</p>
<p>일반 대입과는 달리, 증분 대입은 우변의 값을 구하기 <em>이전에</em> 좌변의 값을 구한다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">+=</span> <span class="pre">f(x)</span></code> 는 처음에 <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> 를 조회한 다음, <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> 의 값을 구하고, 덧셈을 수행하고, 마지막으로 그 결과를 <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> 에 다시 쓴다.</p>
<p>하나의 문장에서 튜플과 다중 타깃으로 대입하는 것을 예외로 하면, 증분 대입문에 의한 대입은 일반 대입과 같은 방법으로 처리된다. 마찬가지로, <em>제자리</em> 동작의 가능성을 예외로 하면, 증분 대입 때문에 수행되는 이진 연산은 일반 이진 연산과 같다.</p>
<p>어트리뷰트 참조인 타깃의 경우, 일반 대입처럼 <a class="reference internal" href="#attr-target-note"><span class="std std-ref">클래스와 인스턴스 어트리뷰트에 관한 경고</span></a> 가 적용된다.</p>
</div>
<div class="section" id="annotated-assignment-statements">
<span id="annassign"></span><h3>7.2.2. 어노테이트된 대입문(Annotated assignment statements)<a class="headerlink" href="#annotated-assignment-statements" title="永久链接至标题">¶</a></h3>
<p id="index-15">어노테이션 대입은, 한 문장에서, 변수나 어트리뷰트 어노테이션과 생략할 수 있는 대입문을 합치는 것이다.</p>
<pre>
<strong id="grammar-token-annotated_assignment_stmt">annotated_assignment_stmt</strong> ::=  <a class="reference internal" href="#grammar-token-augtarget"><code class="xref docutils literal notranslate"><span class="pre">augtarget</span></code></a> &quot;:&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> [&quot;=&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
</pre>
<p>일반 <a class="reference internal" href="#assignment"><span class="std std-ref">대입문</span></a> 과의 차이점은 오직 하나의 타깃과 오직 하나의 우변 값만 허락된다는 것이다.</p>
<p>대인 타깃에 단순한 이름을 쓰는 경우, 클래스나 모듈 스코프에 있으면, 어노테이션은 값이 구해진 후 특별한 클래스나 모듈의 어트리뷰트 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> 에 저장되는데, 이 어트리뷰트는 (만약 비공개면 뒤섞인) 변수 이름을 어노테이션의 값으로 대응시키는 딕셔너리 매핑이다. 이 어트리뷰트는 쓰기가 허락되고, 클래스나 모듈의 실행을 시작할 때 어노테이션이 정적으로 발견되면 만들어진다.</p>
<p>대입 타깃으로 표현식을 쓸 때, 어노테이션은 클래스나 모듈 스코프에 있는 것처럼 값이 구해지지만 저장되지는 않는다.</p>
<p>이름이 함수 스코프에서 어노테이트되면, 이 이름은 그 스코프에 지역적(local)이다. 함수 스코프에서 어노테이션은 값이 구해지거나 저장되지 않는다.</p>
<p>우변이 존재하면, 어노테이트된 대입은 (적절한 곳에서) 어노테이션의 값을 구하기 전에 실제 대입을 수행한다. 표현식 타깃의 경우 우변이 존재하지 않으면, 인터프리터는 티깃의 값을 구하는데, 마지막 <a class="reference internal" href="datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a> 이나 <a class="reference internal" href="datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 호출은 생략한다.</p>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<p class="last"><span class="target" id="index-53"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> - 변수와 어트리뷰트 어노테이션 문법 <span class="target" id="index-54"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> - 형 힌트</p>
</div>
</div>
</div>
<div class="section" id="the-assert-statement">
<span id="assert"></span><h2>7.3. <a class="reference internal" href="#assert"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a> 문<a class="headerlink" href="#the-assert-statement" title="永久链接至标题">¶</a></h2>
<p id="index-18">assert 문은 프로그램에 디버깅 어서션(debugging assertion)을 삽입하는 편리한 방법이다:</p>
<pre>
<strong id="grammar-token-assert_stmt">assert_stmt</strong> ::=  &quot;assert&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> [&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
</pre>
<p>간단한 형태, <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">expression</span></code> 은 다음과 동등하다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">expression</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">AssertionError</span>
</pre></div>
</div>
<p>확장된 형태, <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">expression1,</span> <span class="pre">expression2</span></code> 는 다음과 동등하다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">expression1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">expression2</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-19">이 동등성 들은 <a class="reference internal" href="../library/constants.html#__debug__" title="__debug__"><code class="xref py py-const docutils literal notranslate"><span class="pre">__debug__</span></code></a> 과 <a class="reference internal" href="../library/exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> 가 같은 이름의 내장 변수들을 가리킨다고 가정한다. 현재 구현에서, 내장 변수 <a class="reference internal" href="../library/constants.html#__debug__" title="__debug__"><code class="xref py py-const docutils literal notranslate"><span class="pre">__debug__</span></code></a> 은 일반적인 상황에서 <code class="docutils literal notranslate"><span class="pre">True</span></code> 이고, 최적화가 요청되었을 때 (명령행 옵션 -O) <code class="docutils literal notranslate"><span class="pre">False</span></code> 다. 현재의 코드 생성기는 컴파일 시점에 최적화가 요청되면 assert 문을 위한 코드를 만들지 않는다. 에러 메시지에 실패한 표현식의 소스 코드를 포함할 필요가 없음에 주의하라; 그것은 스택 트레이스의 일부로 출력된다.</p>
<p><a class="reference internal" href="../library/constants.html#__debug__" title="__debug__"><code class="xref py py-const docutils literal notranslate"><span class="pre">__debug__</span></code></a> 에 대한 대입은 허락되지 않는다. 이 내장 변수의 값은 인터프리터가 시작할 때 결정된다.</p>
</div>
<div class="section" id="the-pass-statement">
<span id="pass"></span><h2>7.4. <a class="reference internal" href="#pass"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">pass</span></code></a> 문<a class="headerlink" href="#the-pass-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-20">
<strong id="grammar-token-pass_stmt">pass_stmt</strong> ::=  &quot;pass&quot;
</pre>
<p><a class="reference internal" href="#pass"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">pass</span></code></a> 는 널(null) 연산이다 --- 실행될 때, 아무런 일도 일어나지 않는다. 문법적으로 문장이 필요하기는 하지만 할 일은 없을 때, 자리를 채우는 용도로 쓸모가 있다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span> <span class="k">pass</span>    <span class="c1"># a function that does nothing (yet)</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">:</span> <span class="k">pass</span>       <span class="c1"># a class with no methods (yet)</span>
</pre></div>
</div>
</div>
<div class="section" id="the-del-statement">
<span id="del"></span><h2>7.5. <a class="reference internal" href="#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> 문<a class="headerlink" href="#the-del-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-21">
<strong id="grammar-token-del_stmt">del_stmt</strong> ::=  &quot;del&quot; <a class="reference internal" href="#grammar-token-target_list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a>
</pre>
<p>삭제는 대입이 정의된 방식과 아주 비슷하게 재귀적으로 정의된다. 전체 세부 사항들을 나열하는 대신, 여기 몇 가지 힌트가 있다.</p>
<p>타깃 목록의 삭제는 각 타깃을 왼쪽에서 오른쪽으로 재귀적으로 삭제한다.</p>
<p id="index-22">이름의 삭제는 같은 코드 블록에 있는 <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 문에 그 이름이 등장하는지에 따라 지역이나 전역 이름 공간에서 이름의 연결을 제거한다. 이름이 연결되어 있지 않으면, <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 예외가 일어난다.</p>
<p id="index-23">어트리뷰트 참조, 서브스크립션, 슬라이싱의 삭제는 관련된 프라이머리 객체로 전달된다; 슬라이싱의 삭제는 일반적으로 우변 형의 빈 슬라이스를 대입하는 것과 동등하다 (하지만 이것조차 슬라이싱 되는 객체가 판단한다).</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.2 版更改: </span>예전에는 이름이 중첩된 블록에서 자유 변수로 등장하는 경우 지역 이름 공간에서 삭제하는 것이 허락되지 않았다.</p>
</div>
</div>
<div class="section" id="the-return-statement">
<span id="return"></span><h2>7.6. return 문<a class="headerlink" href="#the-return-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-24">
<strong id="grammar-token-return_stmt">return_stmt</strong> ::=  &quot;return&quot; [<a class="reference internal" href="expressions.html#grammar-token-expression_list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a>]
</pre>
<p><a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 은 문법적으로 클래스 정의에 중첩된 경우가 아니라, 함수 정의에만 중첩되어 나타날 수 있다.</p>
<p>표현식 목록이 있으면 값을 구하고, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 치환된다.</p>
<p><a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 은 표현식 목록 (또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>)을 반환 값으로 해서, 현재의 함수 호출을 떠난다.</p>
<p id="index-25"><a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 이 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절을 가진 <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 문에서 제어가 벗어나도록 만드는 경우, 함수로부터 진짜로 벗어나기 전에 그 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절이 실행된다.</p>
<p>제너레이터 함수에서, <a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 문은 제너레이터가 끝났음을 가리키고, <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 예외를 일으킨다. return 문에 제공되는 값은 (있다면) <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 의 생성자에 인자로 전달되어 <code class="xref py py-attr docutils literal notranslate"><span class="pre">StopIteration.value</span></code> 어트리뷰트가 된다.</p>
<p>비동기 제너레이터 함수에서, 빈 <a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 문은 비동기 제너레이터가 끝났음을 알리고, <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 예외를 일으킨다. 비동기 제너레이터 함수에서, 비어있지 않은 <a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 은 문법 에러다.</p>
</div>
<div class="section" id="the-yield-statement">
<span id="yield"></span><h2>7.7. yield 문<a class="headerlink" href="#the-yield-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-26">
<strong id="grammar-token-yield_stmt">yield_stmt</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-yield_expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a>
</pre>
<p><a class="reference internal" href="#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 문은 <a class="reference internal" href="expressions.html#yieldexpr"><span class="std std-ref">yield 표현식</span></a> 과 같은 의미가 있다. 동등한 yield 표현식에서 필요로 하는 괄호를 생략하기 위해 yield 문을 사용한다. 예를 들어, yield 문</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">yield</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span>
<span class="k">yield from</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>은 다음과 같은 yield 표현식 문장들과 동등하다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">yield</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="k">yield from</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>yield 표현식과 문장은 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a> 함수를 정의할 때만 사용되고, 제너레이터 함수의 바디에서만 사용된다. 함수 정의가 일반 함수 대신 제너레이터 함수를 만들도록 하는 데는 yield를 사용하는 것만으로 충분하다.</p>
<p><a class="reference internal" href="#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 의 뜻에 대한 전체 세부 사항들은 <a class="reference internal" href="expressions.html#yieldexpr"><span class="std std-ref">일드 표현식(Yield expressions)</span></a> 섹션을 참고하면 된다.</p>
</div>
<div class="section" id="the-raise-statement">
<span id="raise"></span><h2>7.8. <a class="reference internal" href="#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> 문<a class="headerlink" href="#the-raise-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-27">
<strong id="grammar-token-raise_stmt">raise_stmt</strong> ::=  &quot;raise&quot; [<a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> [&quot;from&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]]
</pre>
<p>표현식이 주어지지 않으면, <a class="reference internal" href="#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> 는 현재 스코프에서 활성화된 마지막 예외를 다시 일으킨다. 현재 스코프에 활성화된 예외가 없다면, 이것이 에러라는 것을 알리기 위해 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 예외를 일으킨다.</p>
<p>그렇지 않으면, <a class="reference internal" href="#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> 는 예외 객체로, 첫 번째 표현식의 값을 구한다. <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseException</span></code></a> 의 서브 클래스나 인스턴스여야 한다. 클래스면, 예외 인스턴스는 필요할 때 인자 없이 클래스의 인스턴스를 만들어서 사용된다.</p>
<p>예외의 형(<em class="dfn">type</em>)은 예외 인스턴스의 클래스고, 값(<em class="dfn">value</em>)은 인스턴스 자신이다.</p>
<p id="index-28">트레이스백 객체는 보통 예외가 일어날 때 자동으로 만들어지고 쓰기 가능한 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__traceback__</span></code> 어트리뷰트로 첨부된다. 다음과 같이, <code class="xref py py-meth docutils literal notranslate"><span class="pre">with_traceback()</span></code> 예외 메서드를 사용하면, 예외를 만들고 트레이스백을 직접 설정하는 것을 한 번에 할 수 있다 (같은 예외 인스턴스를 돌려주는데, 그 인자값으로 트레이스백을 설정해준다):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;foo occurred&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">tracebackobj</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-29"><code class="docutils literal notranslate"><span class="pre">from</span></code> 절은 예외 연쇄(exception chaining)에 사용된다. 주어진다면, 두 번째 <em>표현식(expression)</em> 은 또 하나의 예외 클래스나 인스턴스야 되는데, 발생한 예외에 (쓰기 가능한) <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cause__</span></code> 어트리뷰트로 첨부된다. 발생한 예외가 처리되지 않으면, 두 예외가 모두 인쇄된다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Something bad happened&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">exc</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">division by zero</span>

<span class="go">The above exception was the direct cause of the following exception:</span>

<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">4</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">RuntimeError</span>: <span class="n">Something bad happened</span>
</pre></div>
</div>
<p>예외 처리기나 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절에서 예외가 발생하면 비슷한 메커니즘이 묵시적으로 적용된다: 앞선 예외가 새 예외의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__context__</span></code> 어트리뷰트로 첨부된다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Something bad happened&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">division by zero</span>

<span class="go">During handling of the above exception, another exception occurred:</span>

<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">4</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">RuntimeError</span>: <span class="n">Something bad happened</span>
</pre></div>
</div>
<p>예외 연쇄는 <code class="docutils literal notranslate"><span class="pre">from</span></code> 절에 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 을 지정해서 명시적으로 중지시킬 수 있다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Something bad happened&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">None</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">4</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">RuntimeError</span>: <span class="n">Something bad happened</span>
</pre></div>
</div>
<p>예외에 대한 더 많은 정보를 <a class="reference internal" href="executionmodel.html#exceptions"><span class="std std-ref">예외</span></a> 섹션에서 발견할 수 있고, 예외를 처리하는 것에 대한 정보는 <a class="reference internal" href="compound_stmts.html#try"><span class="std std-ref">try 문</span></a> 섹션에 있다.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>이제 <code class="docutils literal notranslate"><span class="pre">raise</span> <span class="pre">X</span> <span class="pre">from</span> <span class="pre">Y</span></code> 에서 <code class="docutils literal notranslate"><span class="pre">Y</span></code> 로 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 이 허락된다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">3.3 新版功能: </span>예외 문백(exception context)의 자동 출력을 제한할 수 있는 <code class="docutils literal notranslate"><span class="pre">__suppress_context__</span></code> 어트리뷰트</p>
</div>
</div>
<div class="section" id="the-break-statement">
<span id="break"></span><h2>7.9. break 문<a class="headerlink" href="#the-break-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-30">
<strong id="grammar-token-break_stmt">break_stmt</strong> ::=  &quot;break&quot;
</pre>
<p><a class="reference internal" href="#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> 는 문법적으로 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 나 <a class="reference internal" href="compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> 루프에 중첩되어서만 나타날 수 있다. 하지만 그 루프 안의 함수나 클래스 정의에 중첩되지는 않는다.</p>
<p id="index-31">가장 가까이서 둘러싸고 있는 루프를 종료하고, 그 루프가 <a class="reference internal" href="compound_stmts.html#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> 절을 갖고 있다면 건너뛴다(skip).</p>
<p><a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 루프가 <a class="reference internal" href="#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> 로 종료되면, 루프 제어 타깃은 현재값을 유지한다.</p>
<p id="index-32"><a class="reference internal" href="#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> 가 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절을 가 <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 문에서 제어가 벗어나도록 만드는 경우, 루프로부터 진짜로 벗어나기 전에 그 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절이 실행된다.</p>
</div>
<div class="section" id="the-continue-statement">
<span id="continue"></span><h2>7.10. <a class="reference internal" href="#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> 문<a class="headerlink" href="#the-continue-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-33">
<strong id="grammar-token-continue_stmt">continue_stmt</strong> ::=  &quot;continue&quot;
</pre>
<p><a class="reference internal" href="#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> 는 문법적으로 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 나 <a class="reference internal" href="compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> 루프에 중첩되어서만 나타날 수 있다. 하지만 그 루프 안의 함수나 클래스 정의 또는 그 루프 내의 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 에 중첩되지는 않는다. 가장 가까이서 둘러싸고 있는 루프가 다음 사이클로 넘어가도록 만든다.</p>
<p><a class="reference internal" href="#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> 가 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절을 가진 <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 문에서 제어가 벗어나도록 만드는 경우, 다음 루트 사이클을 시작하기 전에 그 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절이 실행된다.</p>
</div>
<div class="section" id="the-import-statement">
<span id="from"></span><span id="import"></span><h2>7.11. 임포트(<a class="reference internal" href="#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>) 문<a class="headerlink" href="#the-import-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-34">
<strong id="grammar-token-import_stmt">import_stmt    </strong> ::=  &quot;import&quot; <a class="reference internal" href="#grammar-token-module"><code class="xref docutils literal notranslate"><span class="pre">module</span></code></a> [&quot;as&quot; <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a>] ( &quot;,&quot; <a class="reference internal" href="#grammar-token-module"><code class="xref docutils literal notranslate"><span class="pre">module</span></code></a> [&quot;as&quot; <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a>] )*
                     | &quot;from&quot; <a class="reference internal" href="#grammar-token-relative_module"><code class="xref docutils literal notranslate"><span class="pre">relative_module</span></code></a> &quot;import&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> [&quot;as&quot; <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a>]
                     ( &quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> [&quot;as&quot; <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a>] )*
                     | &quot;from&quot; <a class="reference internal" href="#grammar-token-relative_module"><code class="xref docutils literal notranslate"><span class="pre">relative_module</span></code></a> &quot;import&quot; &quot;(&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> [&quot;as&quot; <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a>]
                     ( &quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> [&quot;as&quot; <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a>] )* [&quot;,&quot;] &quot;)&quot;
                     | &quot;from&quot; <a class="reference internal" href="#grammar-token-module"><code class="xref docutils literal notranslate"><span class="pre">module</span></code></a> &quot;import&quot; &quot;*&quot;
<strong id="grammar-token-module">module         </strong> ::=  (<a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> &quot;.&quot;)* <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
<strong id="grammar-token-relative_module">relative_module</strong> ::=  &quot;.&quot;* <a class="reference internal" href="#grammar-token-module"><code class="xref docutils literal notranslate"><span class="pre">module</span></code></a> | &quot;.&quot;+
<strong id="grammar-token-name">name           </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
</pre>
<p>(<a class="reference internal" href="#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> 절이 없는) 기본 임포트 문은 두 단계로 실행된다:</p>
<ol class="arabic simple">
<li>모듈을 찾고, 로드하고, 필요하면 초기화한다</li>
<li>임포트(<a class="reference internal" href="#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>) 문이 등장한 스코프의 지역 이름 공간에 이름이나 이름들을 정의한다.</li>
</ol>
<p>문장이 (쉼표로 분리된) 여러 개의 절을 포함하면, 마치 각 절이 별도의 임포트 문에 의해 분리된 것처럼, 두 단계는 절마다 별도로 수행된다.</p>
<p>첫 번째 단계, 모듈을 찾고 로드하는 것의 세부 사항은 <a class="reference internal" href="import.html#importsystem"><span class="std std-ref">임포트 시스템</span></a> 에 있는 섹션에서 아주 상세하게 설명하는데, 임포트될 수 있는 여러 종류의 패키지와 모듈들과 임포트 시스템을 커스터마이즈하는데 사용될 수 있는 모든 훅에 관해서도 설명하고 있다.</p>
<p>요청된 모듈이 성공적으로 읽어 들여지면, 세 가지 중 한 방법으로 지역 이름 공간에 소개된다:</p>
<ul class="simple" id="index-35">
<li>모듈 이름 뒤에 <a class="reference internal" href="compound_stmts.html#as"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code></a> 가 오면, <a class="reference internal" href="compound_stmts.html#as"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code></a> 뒤에 오는 이름이 임포트된 모듈에 직접 연결된다.</li>
<li>다른 이름이 지정되지 않고, 임포트되는 모듈이 최상위 모듈이면, 모듈의 이름이 임포트되는 모듈에 대한 참조로 지역 이름 공간에 연결된다.</li>
<li>임포트되는 모듈이 최상이 모듈이 <em>아니</em> 라면, 그 모듈을 포함하는 최상위 패키지의 이름이 최상위 패키지에 대한 참조로 지역 이름 공간에 연결된다. 임포트된 모듈은 직접적이기보다는 완전히 정규화된 이름(full qualified name)을 통해 액세스 되어야 한다.</li>
</ul>
<p id="index-36"><a class="reference internal" href="#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> 형은 약간 더 복잡한 절차를 사용한다:</p>
<ol class="arabic simple">
<li><a class="reference internal" href="#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> 절에 지정된 모듈을 찾고, 로드하고, 필요하면 초기화한다</li>
<li><a class="reference internal" href="#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 절에 지정된 식별자들 각각에 대해:<ol class="arabic">
<li>임포트된 모듈이 그 이름의 어트리뷰트를 가졌는지 검사한다</li>
<li>없으면, 그 이름의 서브 모듈을 임포트하는 것을 시도한 다음 임포트된 모듈에서 그 어트리뷰트를 다시 검사한다</li>
<li>어트리뷰트가 발견되지 않으면 <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 를 일으킨다.</li>
<li>그렇지 않으면, 그 값에 대한 참조가 지역 이름 공간에 저장되는데, <a class="reference internal" href="compound_stmts.html#as"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code></a> 절이 존재하면 거기에서 지정된 이름을 사용하고, 그렇지 않으면 어트리뷰트 이름을 사용한다</li>
</ol>
</li>
</ol>
<p>사용 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">foo</span>                 <span class="c1"># foo imported and bound locally</span>
<span class="kn">import</span> <span class="nn">foo.bar.baz</span>         <span class="c1"># foo.bar.baz imported, foo bound locally</span>
<span class="kn">import</span> <span class="nn">foo.bar.baz</span> <span class="k">as</span> <span class="nn">fbb</span>  <span class="c1"># foo.bar.baz imported and bound as fbb</span>
<span class="kn">from</span> <span class="nn">foo.bar</span> <span class="k">import</span> <span class="n">baz</span>    <span class="c1"># foo.bar.baz imported and bound as baz</span>
<span class="kn">from</span> <span class="nn">foo</span> <span class="k">import</span> <span class="n">attr</span>       <span class="c1"># foo imported and foo.attr bound as attr</span>
</pre></div>
</div>
<p>식별자들의 목록을 스타 (<code class="docutils literal notranslate"><span class="pre">'*'</span></code>) 로 바꾸면, 모듈에 정의된 모든 공개 이름들이 <a class="reference internal" href="#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문이 등장한 스코프의 지역 이름 공간에 연결된다.</p>
<p id="index-37">모듈에 정의된 <em>공개 이름(public names)</em> 은 모듈의 이름 공간에서 <code class="docutils literal notranslate"><span class="pre">__all__</span></code> 이라는 이름의 변수를 검사해서 결정된다; 정의되어 있다면, 문자열의 시퀀스여야 하는데, 그 모듈이 정의하거나 임포트하는 이름들이다. <code class="docutils literal notranslate"><span class="pre">__all__</span></code> 에서 지정한 이름들은 모두 공개로 취급되고 반드시 존재해야 한다. <code class="docutils literal notranslate"><span class="pre">__all__</span></code> 이 정의되지 않으면, 모듈의 이름 공간에서 발견되는 이름 중, 밑줄 문자 (<code class="docutils literal notranslate"><span class="pre">'_'</span></code>)로 시작하지 않는 모든 이름이 공개로 취급된다. <code class="docutils literal notranslate"><span class="pre">__all__</span></code> 는 공개 API 전체를 포함해야 한다. 이것의 목적은 의도치 않게 API 일부가 아닌 항목들을 노출하는 것을 방지하는 것이다 (가령 그 모듈이 임포트하고 사용하는 라이브러리 모듈).</p>
<p>임포트의 와일드카드 형태 --- <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> --- 는 모듈 수준에서만 허락된다. 클래스나 함수 정의에서 사용하려는 시도는 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 를 일으킨다.</p>
<p id="index-38">임포트할 모듈을 지정할 때 모듈의 절대 이름(absolute name)을 지정할 필요는 없다. 모듈이나 패키지가 다른 패키지 안에 포함될 때, 같은 상위 패키지 내에서는 그 패키지 이름을 언급할 필요 없이 상대 임포트(relative import)를 할 수 있다. <a class="reference internal" href="#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> 뒤에 지정되는 패키지나 모듈 앞에 붙이는 점으로, 정확한 이름을 지정하지 않고도 현재 패키지 계층을 얼마나 거슬러 올라가야 하는지 지정할 수 있다. 하나의 점은 이 임포트를 하는 모듈이 존재하는 현재 패키지를 뜻한다. 두 개의 점은 한 패키지 수준을 거슬러 올라가는 것을 뜻한다. 세 개의 점은 두 개의 수준을, 등등이다. 그래서 <code class="docutils literal notranslate"><span class="pre">pkg</span></code> 패키지에 있는 모듈에서 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">.</span> <span class="pre">import</span> <span class="pre">mod</span></code> 를 실행하면, <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code> 를 임포트하게 된다. <code class="docutils literal notranslate"><span class="pre">pkg.subpkg1</span></code> 안에서 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">..subpkg2</span> <span class="pre">import</span> <span class="pre">mod</span></code> 를 실행하면 <code class="docutils literal notranslate"><span class="pre">pkg.subpkg2.mod</span></code> 를 임포트하게 된다. 상대 임포트에 대한 규격은 <span class="target" id="index-55"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a> 안에 들어있다.</p>
<p>로드할 모듈들을 동적으로 결정하는 응용 프로그램들을 지원하기 위해 <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 이 제공된다.</p>
<div class="section" id="future-statements">
<span id="future"></span><h3>7.11.1. 퓨처 문<a class="headerlink" href="#future-statements" title="永久链接至标题">¶</a></h3>
<p id="index-40">퓨처 문(<em class="dfn">future statement</em>)은 컴파일러가 특정한 모듈을 특별한 문법이나 개념을 사용해서 컴파일하도록 만드는 지시어(directive)인데, 그 기능은 미래에 출시되는 파이썬에서 표준이 되는 것이다.</p>
<p>퓨처 문의 목적은 언어에 호환되지 않는 변경이 도입된 미래 버전의 파이썬으로 옮겨가는 것을 쉽게 만드는 것이다. 그 기능이 표준이 되는 배포 이전에 모듈 단위로 새 기능을 사용할 수 있도록 만든다.</p>
<pre>
<strong id="grammar-token-future_statement">future_statement</strong> ::=  &quot;from&quot; &quot;__future__&quot; &quot;import&quot; feature [&quot;as&quot; name]
                      (&quot;,&quot; feature [&quot;as&quot; name])*
                      | &quot;from&quot; &quot;__future__&quot; &quot;import&quot; &quot;(&quot; feature [&quot;as&quot; name]
                      (&quot;,&quot; feature [&quot;as&quot; name])* [&quot;,&quot;] &quot;)&quot;
<strong id="grammar-token-feature">feature         </strong> ::=  identifier
<strong id="id1">name            </strong> ::=  identifier
</pre>
<p>퓨처 문은 모듈의 거의 처음에 나와야 한다. 퓨처 문 앞에 나올 수 있는 줄들은:</p>
<ul class="simple">
<li>모듈 독스트링(docstring) (있다면),</li>
<li>주석</li>
<li>빈 줄, 그리고</li>
<li>다른 퓨처 문들</li>
</ul>
<p>파이썬 3.0 이 인식하는 기능들은 <code class="docutils literal notranslate"><span class="pre">absolute_import</span></code>, <code class="docutils literal notranslate"><span class="pre">division</span></code>, <code class="docutils literal notranslate"><span class="pre">generators</span></code>, <code class="docutils literal notranslate"><span class="pre">unicode_literals</span></code>, <code class="docutils literal notranslate"><span class="pre">print_function</span></code>, <code class="docutils literal notranslate"><span class="pre">nested_scopes</span></code>, <code class="docutils literal notranslate"><span class="pre">with_statement</span></code> 다. 이것들은 잉여물인데 항상 활성화되고, 오직 과거 호환성을 위해 유지되고 있기 때문이다.</p>
<p>퓨처 문은 구체적으로는 컴파일 시점에 인식되고 다뤄진다: 핵심 구성물들의 의미에 대한 변경은 종종 다른 코드 생성을 통해 구현된다. 새 기능이 호환되지 않는 (새로운 예약어처럼) 새로운 문법을 도입하는 경우조차 가능한데, 이 경우는 컴파일러가 모듈을 다르게 파싱할 수 있다. 그런 결정들은 실행 시점으로 미뤄질 수 없다..</p>
<p>배포마다, 컴파일러는 어떤 기능 이름들이 정의되어 있는지 알고, 만약 퓨처 문이 알지 못하는 기능을 포함하고 있으면 컴파일 시점 에러를 일으킨다.</p>
<p>직접적인 실행 시점의 개념은 다른 임포트 문들과 같다: 표준 모듈 <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a>, 후에 설명한다, 다 있고, 퓨처 문이 실행되는 시점에 일반적인 방법으로 임포트된다.</p>
<p>흥미로운 실행 시점의 개념들은 퓨처 문에 의해 활성화되는 구체적인 기능들에 달려있다.</p>
<p>이런 문장에는 아무것도 특별한 것이 없음에 주의해야 한다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">__future__</span> <span class="p">[</span><span class="k">as</span> <span class="n">name</span><span class="p">]</span>
</pre></div>
</div>
<p>이것은 퓨처 문이 아니다; 아무런 특별한 개념이나 문법적인 제약이 없는 평범한 임포트 문일 뿐이다.</p>
<p>퓨처 문을 포함하는 모듈 <code class="xref py py-mod docutils literal notranslate"><span class="pre">M</span></code> 에 등장하는 내장 함수 <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 와 <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 를 호출해서 컴파일되는 코드는, 기본적으로는, 퓨처 문이 지정하는 새 문법과 개념을 사용한다. 이것은 <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 에 주는 생략 가능한 인자로 제어될 수 있다 --- 자세한 내용은 그 함수의 문서를 보면 된다.</p>
<p>대화형 인터프리터 프롬프트에서 입력된 퓨처 문은 인터프리터 세션의 남은 기간 효과를 발생시킨다. 인터프리터가 <a class="reference internal" href="../using/cmdline.html#cmdoption-i"><code class="xref std std-option docutils literal notranslate"><span class="pre">-i</span></code></a>, 실행할 스크립트 이름이 전달된다, 옵션으로 시작하고, 그 스크립트가 퓨처 문을 포함하면, 스크립트가 실행된 이후에 시작되는 대화형 세션에서도 효과를 유지한다.</p>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<dl class="last docutils">
<dt><span class="target" id="index-56"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0236"><strong>PEP 236</strong></a> - 백 투 더 __future__</dt>
<dd>__future__ 메커니즘에 대한 최초의 제안.</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="the-global-statement">
<span id="global"></span><h2>7.12. <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 문<a class="headerlink" href="#the-global-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-42">
<strong id="grammar-token-global_stmt">global_stmt</strong> ::=  &quot;global&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> (&quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>)*
</pre>
<p><a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 문은 현재 코드 블록 전체에 적용되는 선언이다. 나열된 식별자들이 전역으로 해석되어야 한다는 뜻이다. global 선언 없이 자유 변수들이 전역을 가리킬 수 있기는 하지만, <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 없이 전역 변수에 값을 대입하는 것은 불가능하다.</p>
<p><a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 문에 나열된 이름들은 같은 코드 블록에서 <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 문 앞에 등장할 수 없다.</p>
<p><a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 문에 나열된 이름들은 형식 파라미터나 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 루프 제어 타깃, 클래스(<a class="reference internal" href="compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a>) 정의, 함수 정의, 임포트(<a class="reference internal" href="#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>) 문, 변수 어노테이션으로 정의되지 않아야 한다.</p>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> 현재 구현이 이 제약들의 일부를 강제하지 않지만, 프로그램은 이 자유를 남용하지 말아야 하는데, 미래의 구현은 그것들을 강제하거나 프로그램의 의미를 예고 없이 변경할 수 있기 때문이다.</p>
</div>
<p id="index-43"><strong>프로그래머의 주의 사향:</strong> <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 은 파서에 주는 지시자(directive)다. <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 문과 같은 시점에 파싱되는 코드에만 적용된다. 특히, 내장 <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 함수로 공급되는 문자열이나 코드 객체에 포함된 <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 문은 그 함수 호출을 <em>포함하는</em> 코드 블록에는 영향을 주지 않고, 그런 문자열에 포함된 코드 역시 함수 호출을 포함하는 코드에 있는 <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 문에 영향을 받지 않는다. <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 과 <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 함수들도 마찬가지다.</p>
</div>
<div class="section" id="the-nonlocal-statement">
<span id="nonlocal"></span><h2>7.13. <a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 문<a class="headerlink" href="#the-nonlocal-statement" title="永久链接至标题">¶</a></h2>
<pre id="index-44">
<strong id="grammar-token-nonlocal_stmt">nonlocal_stmt</strong> ::=  &quot;nonlocal&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> (&quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>)*
</pre>
<p><a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 문은 나열된 식별자들이 전역을 제외하고 가장 가까이서 둘러싸는 스코프에서 이미 연결된 변수를 가리키도록 만든다. 이것은 중요한데, 연결의 기본 동작이 지역 이름 공간을 먼저 검색하는 것이기 때문이다. 이 문장은 캡슐화된 코드가 전역 (모듈) 스코프 외에 지역 스코프 밖의 변수들에 재연결할 수 있도록 한다.</p>
<p><a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 문 에 나열된 이름들은, <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 문에 나열된 것들과는 달리, 둘러싼 스코프에서 이미 존재하는 연결들을 가리켜야만 한다 (새 연결이 어떤 스코프에 만들어져야만 하는지 명확하게 결정할 수 없다).</p>
<p><a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 문에 나열되는 이름들은 지역 스코프에 이미 존재하는 연결들과 겹치지 않아야 한다.</p>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<dl class="last docutils">
<dt><span class="target" id="index-57"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3104"><strong>PEP 3104</strong></a> - 바깥 스코프에 있는 이름들에 대한 액세스</dt>
<dd><a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 문의 규격.</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">7. 단순문(Simple statements)</a><ul>
<li><a class="reference internal" href="#expression-statements">7.1. 표현식 문</a></li>
<li><a class="reference internal" href="#assignment-statements">7.2. 대입문</a><ul>
<li><a class="reference internal" href="#augmented-assignment-statements">7.2.1. 증분 대입문(Augmented assignment statements)</a></li>
<li><a class="reference internal" href="#annotated-assignment-statements">7.2.2. 어노테이트된 대입문(Annotated assignment statements)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-assert-statement">7.3. <code class="docutils literal notranslate"><span class="pre">assert</span></code> 문</a></li>
<li><a class="reference internal" href="#the-pass-statement">7.4. <code class="docutils literal notranslate"><span class="pre">pass</span></code> 문</a></li>
<li><a class="reference internal" href="#the-del-statement">7.5. <code class="docutils literal notranslate"><span class="pre">del</span></code> 문</a></li>
<li><a class="reference internal" href="#the-return-statement">7.6. return 문</a></li>
<li><a class="reference internal" href="#the-yield-statement">7.7. yield 문</a></li>
<li><a class="reference internal" href="#the-raise-statement">7.8. <code class="docutils literal notranslate"><span class="pre">raise</span></code> 문</a></li>
<li><a class="reference internal" href="#the-break-statement">7.9. break 문</a></li>
<li><a class="reference internal" href="#the-continue-statement">7.10. <code class="docutils literal notranslate"><span class="pre">continue</span></code> 문</a></li>
<li><a class="reference internal" href="#the-import-statement">7.11. 임포트(<code class="docutils literal notranslate"><span class="pre">import</span></code>) 문</a><ul>
<li><a class="reference internal" href="#future-statements">7.11.1. 퓨처 문</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-global-statement">7.12. <code class="docutils literal notranslate"><span class="pre">global</span></code> 문</a></li>
<li><a class="reference internal" href="#the-nonlocal-statement">7.13. <code class="docutils literal notranslate"><span class="pre">nonlocal</span></code> 문</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="expressions.html"
                        title="上一章">6. 표현식</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="compound_stmts.html"
                        title="下一章">8. 복합문(Compound statements)</a></p>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/reference/simple_stmts.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="compound_stmts.html" title="8. 복합문(Compound statements)"
             >下一页</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. 표현식"
             >上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh</span>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">도큐멘테이션 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 언어 레퍼런스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    파이썬 소프트웨어 재단은 비영리 법인입니다.
    <a href="https://www.python.org/psf/donations/">기부를 부탁합니다.</a>
    <br />
    4月 21, 2018 에 마지막으로 업데이트되었습니다.
    <a href="../bugs.html">버그를 찾았나요?</a>
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.7.2 를 사용해서 만들었습니다.
    </div>

  </body>
</html>