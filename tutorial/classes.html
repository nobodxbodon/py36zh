
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>9. 클래스 &#8212; Python 3.6.5 文档</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.6.5 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="10. 표준 라이브러리 둘러보기" href="stdlib.html" />
    <link rel="prev" title="8. 에러와 예외" href="errors.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.org/3/tutorial/classes.html" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="stdlib.html" title="10. 표준 라이브러리 둘러보기"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="errors.html" title="8. 에러와 예외"
             accesskey="P">上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh</span>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">도큐멘테이션 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">测试python入门教程</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="classes">
<span id="tut-classes"></span><h1>9. 클래스<a class="headerlink" href="#classes" title="永久链接至标题">¶</a></h1>
<p>클래스는 데이터와 기능을 함께 묶는 방법을 제공한다. 새 클래스를 만드는 것은 객체의 새 <em>형</em> 을 만들어서, 그 형의 새 <em>인스턴스</em> 를 만들 수 있도록 한다. 각 클래스 인스턴스는 상태를 유지하기 위해 그 자신에게 첨부된 어트리뷰트를 가질 수 있다. 클래스 인스턴스는 상태를 바꾸기 위한 (클래스에 의해 정의된) 메서드도 가질 수 있다.</p>
<p>다른 프로그래밍 언어들과 비교할 때, 파이썬의 클래스 메커니즘은 최소한의 새로운 문법과 개념을 써서 클래스를 추가한다. C++ 과 모듈라-3 에서 발견되는 클래스 메커니즘을 혼합한다. 파이썬 클래스는 객체 지향형 프로그래밍의 모든 표준 기능들을 제공한다: 클래스 상속 메커니즘은 다중 베이스 클래스를 허락하고, 자식 클래스는 베이스 클래스나 클래스들의 어떤 메서드도 재정의할 수 있으며, 메서드는 같은 이름의 베이스 클래스의 메서드를 호출할 수 있다. 객체들은 임의의 종류의 데이터를 양적 제한 없이 가질 수 있다. 모듈과 마찬가지로, 클래스는 파이썬의 동적인 본성을 함께 나눈다: 실행 시간에 만들어지고, 만들어진 후에도 더 수정될 수 있다.</p>
<p>C++ 용어로, 보통 클래스 멤버들은 (데이터 멤버를 포함해서) <em>public</em> (예외는 아래 <a class="reference internal" href="#tut-private"><span class="std std-ref">비공개 변수</span></a> 를 보라) 하고, 모든 맴버 함수들은 <em>virtual</em> 이다. 모듈라-3처럼, 객체의 매소드에서 그 객체의 멤버를 참조하는 줄임 표현은 없다: 메서드 함수는 그 객체를 표현하는 명시적인 첫 번째 인자를 선언하는데, 함수 호출 때 묵시적으로 제공된다. 스몰토크처럼, 클래스 자신도 객체다. 이것이 임포팅과 이름 변경을 위한 개념을 제공한다. C++ 나 모듈라-3 와는 달리, 내장형도 사용자가 확장하기 위해 베이스 클래스로 사용할 수 있다. 또한, C++ 처럼, 특별한 문법을 갖는 대부분의 내장 연산자들은 (산술 연산자, 서브스크립팅, 등등) 클래스 인스턴스에 대해 새로 정의될 수 있다.</p>
<p>(클래스에 대해 보편적으로 받아들여지는 용어들이 없는 상태에서, 이따금 스몰토크나 C++ 용어들을 사용할 것이다. C++ 보다 객체 지향적 개념들이 파이썬의 것과 더 가까우므로 모듈라-3 용어를 사용할 수도 있지만, 들어본 독자들이 별로 없을 것으로 예상한다.)</p>
<div class="section" id="a-word-about-names-and-objects">
<span id="tut-object"></span><h2>9.1. 이름과 객체에 관한 한마디<a class="headerlink" href="#a-word-about-names-and-objects" title="永久链接至标题">¶</a></h2>
<p>객체는 개체성(individuality)을 갖고, 여러 개의 이름이 (여러 개의 스코프에서) 같은 객체에 연결될 수 있다. 이것은 다른 언어들에서는 에일리어싱(aliasing) 이라고 알려져 있다. 보통 파이썬을 처음 볼 때 이 점을 높이 평가하지는 않고, 불변 기본형들 (숫자, 문자열, 튜플)을 다루는 동안은 안전하게 무시할 수 있다. 하지만, 에일리어싱는 리스트, 딕셔너리나 그 밖의 다른 가변 객체들을 수반하는 파이썬 코드의 의미에 극적인 효과를 줄 수 있다. 이것은 보통 프로그램에 혜택이 되는데, 에일리어스는 어떤 면에서 포인터처럼 동작하기 때문이다. 예를 들어, 구현이 포인터만 전달하기 때문에, 객체를 전달하는 비용이 적게 든다; 그리고 함수가 인자로 전달된 객체를 수정하면, 호출자는 그 변경을 보게 된다 --- 이것은 파스칼에서 사용되는 두 가지 서로 다른 인자 전달 메커니즘의 필요를 제거한다.</p>
</div>
<div class="section" id="python-scopes-and-namespaces">
<span id="tut-scopes"></span><h2>9.2. 파이썬 스코프와 이름 공간<a class="headerlink" href="#python-scopes-and-namespaces" title="永久链接至标题">¶</a></h2>
<p>클래스를 소개하기 전에, 파이썬의 스코프 규칙에 대해 몇 가지 말할 것이 있다. 클래스 정의는 이름 공간으로 깔끔한 요령을 부리고, 여러분은 무엇이 일어나는지 완전히 이해하기 위해 스코프와 이름 공간이 어떻게 동작하는지 알 필요가 있다. 덧붙여 말하자면, 이 주제에 대한 지식은 모든 고급 파이썬 프로그래머에게 쓸모가 있다.</p>
<p>몇 가지 정의로 시작해보자.</p>
<p><em>이름 공간</em> 은 이름에서 객체로 가는 매핑이다. 대부분의 이름 공간은 현재 파이썬 딕셔너리로 구현되어 있지만, 보통 다른 식으로는 알아차릴 수 없고 (성능은 예외다), 앞으로는 바뀔 수 있다. 이름 공간의 예는: 내장 이름들의 집합 (<a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a> 와 같은 함수들과 내장 예외 이름들을 포함한다); 모듈의 전역 이름들; 함수 호출에서의 지역 이름들. 어떤 의미에서 객체의 어트리뷰트 집합도 이름 공간을 형성한다. 이름 공간에 대해 알아야 할 중요한 것은 서로 다른 이름 공간들의 이름 간에는 아무런 관계가 없다는 것이다; 예를 들어, 두 개의 서로 다른 모듈들은 모두 혼동 없이 함수 <code class="docutils literal notranslate"><span class="pre">maximize</span></code> 를 정의할 수 있다 --- 모듈의 사용자들은 모듈 이름을 앞에 붙여야 한다.</p>
<p>그런데, 나는 <em>어트리뷰트</em> 라는 단어를 점 뒤에 오는 모든 이름에 사용한다 --- 예를 들어, 표현식 <code class="docutils literal notranslate"><span class="pre">z.real</span></code> 에서, <code class="docutils literal notranslate"><span class="pre">real</span></code> 는 객체 <code class="docutils literal notranslate"><span class="pre">z</span></code> 의 어트리뷰트다. 엄밀하게 말해서, 모듈에 있는 이름들에 대한 참조는 어트리뷰트 참조다: 표현식 <code class="docutils literal notranslate"><span class="pre">modname.funcname</span></code> 에서, <code class="docutils literal notranslate"><span class="pre">modname</span></code> 은 모듈 객체고 <code class="docutils literal notranslate"><span class="pre">funcname</span></code> 는 그것의 어트리뷰트다. 이 경우에는 우연히도 모듈의 어트리뷰트와 모듈에서 정의된 전역 이름 간에 직접적인 매핑이 생긴다: 같은 이름 공간을 공유한다! <a class="footnote-reference" href="#id2" id="id1">[1]</a></p>
<p>어트리뷰트는 읽기 전용 이거나 쓰기 가능할 수 있다. 후자의 경우, 어트리뷰트에 대한 대입이 가능하다. 모듈 어트리뷰트는 쓰기 가능하다: <code class="docutils literal notranslate"><span class="pre">modname.the_answer</span> <span class="pre">=</span> <span class="pre">42</span></code> 라고 쓸 수 있다. 쓰기 가능한 어트리뷰트는 <a class="reference internal" href="../reference/simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> 문으로 삭제할 수도 있다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">modname.the_answer</span></code> 는 <code class="docutils literal notranslate"><span class="pre">modname</span></code> 라는 이름의 객체에서 어트리뷰트 <code class="xref py py-attr docutils literal notranslate"><span class="pre">the_answer</span></code> 를 제거한다.</p>
<p>이름 공간들은 서로 다른 순간에 만들어지고 서로 다른 수명을 갖는다. 내장 이름들을 담는 이름 공간은 파이썬 인터프리터가 시작할 때 만들어지고 영원히 지워지지 않는다. 모듈의 전역 이름 공간은 모듈 정의를 읽는 동안 만들어진다; 보통, 모듈 이름 공간은 인터프리터가 끝날 때까지 남는다. 인터프리터의 최상위 호출 때문에 실행되는, 스크립트 파일이나 대화형으로 읽히는, 문장들은 <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 이라고 불리는 모듈 일부로 여겨져서 그 들 자신의 이름 공간을 갖는다. (내장 이름들 또한 모듈에 속하는데; 이것을 <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 라 부른다.)</p>
<p>함수의 지역 이름 공간은 함수가 호출될 때 만들어지고, 함수가 복귀하거나 함수 내에서 처리되지 않는 예외를 일으킬 때 삭제된다. (사실, 잊어버린다는 것이 실제로 일어나는 일에 대한 더 좋은 설명이다.) 물론, 재귀적 호출은 각각 자기 자신만의 지역 이름 공간을 갖는다.</p>
<p><em>스코프</em> 는 이름 공간을 직접 액세스할 수 있는 파이썬 프로그램의 텍스트 적인 영역이다. 여기에서 &quot;직접 액세스 가능한&quot; 이란 이름에 대한 정규화되지 않은 참조가 그 이름 공간에서 이름을 찾으려고 시도한다는 의미다.</p>
<p>스코프가 정적으로 결정됨에도 불구하고, 동적으로 사용된다. 실행 중 어느 시점에서건, 이름 공간을 직접 액세스 가능한, 적어도 세 개의 중첩된 스코프가 있다:</p>
<ul class="simple">
<li>가장 먼저 검색되는 가장 내부의 스코프는 지역 이름들을 포함한다</li>
<li>둘러싸고 있는 함수들의 스코프는, 가장 가까이서 둘러싸는 스코프로부터 검색이 시작된다, 비 지역(non-local) 이지만 비 전역(non-global) 이름들을 포함한다</li>
<li>마지막 직전의 스코프는 현재 모듈의 전역 이름들을 포함한다</li>
<li>(가장 나중에 검색되는) 가장 외부의 스코프는 내장 이름들을 포함하고 있는 이름 공간이다.</li>
</ul>
<p>이름을 global로 선언하면, 모든 참조와 대입은 모듈의 전역 이름들을 포함하는 중간 스코프로 바로 간다. 가장 내부의 스코프 바깥에서 발견되는 변수들을 재연결하려면, <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 키워드를 사용할 수 있다; nonlocal 로 선언되지 않으면, 그 변수들은 읽기 전용이다 (그런 변수에 쓰려고 하면 단순히 가장 내부의 스코프에 <em>새</em> 지역 변수를 만들게 되어, 같은 이름의 바깥 변수를 바꾸지 않고 남겨둔다).</p>
<p>보통, 지역 스코프는 현재 함수의 지역 이름들을 (텍스트 적으로) 참조한다. 함수 바깥에서, 지역 스코프는 전역 스코프와 같은 이름 공간을 참조한다: 모듈의 이름 공간. 클래스 정의들은 지역 스코프에 또 하나의 이름 공간을 배치한다.</p>
<p>스코프가 텍스트 적으로 결정된다는 것을 깨닫는 것은 중요하다: 모듈에서 정의된 함수의 전역 스코프는, 어디에서 어떤 에일리어스를 통해 그 함수가 호출되는지에 관계없이, 그 모듈의 이름 공간이다. 반면에, 이름을 실제로 검색하는 것은 실행시간에 동적으로 수행된다 --- 하지만, 언어 정의는 컴파일 시점의 정적인 이름 결정을 향해 진화하고 있어서, 동적인 이름 결정에 의존하지 말아야 한다! (사실, 지역 변수들은 이미 정적으로 결정된다.)</p>
<p>파이썬의 특별한 특징은 -- <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 문이 없을 때 -- 이름에 대입하면 항상 가장 내부의 스코프로 간다는 것이다. 대입은 데이터를 복사하지 않는다 -- 이름을 단지 객체에 연결할 뿐이다. 삭제도 마찬가지다: 문장 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x</span></code> 는 지역 스코프가 참조하는 이름 공간에서 <code class="docutils literal notranslate"><span class="pre">x</span></code> 의 연결을 제거한다. 사실, 새 이름을 소개하는 모든 연산은 지역 스코프를 사용한다: 특히, <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문과 함수 정의는 모듈이나 함수 이름을 지역 스코프에 연결한다.</p>
<p><a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 문은 특정 변수가 전역 스코프에 있으며 그곳에 재연결되어야 함을 가리킬 때 사용될 수 있다; <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 문은 특정 변수가 둘러싸는 스코프에 있으며 그곳에 재연결되어야 함을 가리킨다.</p>
<div class="section" id="scopes-and-namespaces-example">
<span id="tut-scopeexample"></span><h3>9.2.1. 스코프와 이름 공간 예<a class="headerlink" href="#scopes-and-namespaces-example" title="永久链接至标题">¶</a></h3>
<p>이것은 어떻게 서로 다른 스코프와 이름 공간을 참조하고, <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 과 <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 이 변수 연결에 어떤 영향을 주는지를 보여주는 예다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">scope_test</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">do_local</span><span class="p">():</span>
        <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;local spam&quot;</span>

    <span class="k">def</span> <span class="nf">do_nonlocal</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">spam</span>
        <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;nonlocal spam&quot;</span>

    <span class="k">def</span> <span class="nf">do_global</span><span class="p">():</span>
        <span class="k">global</span> <span class="n">spam</span>
        <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;global spam&quot;</span>

    <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;test spam&quot;</span>
    <span class="n">do_local</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After local assignment:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>
    <span class="n">do_nonlocal</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After nonlocal assignment:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>
    <span class="n">do_global</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After global assignment:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>

<span class="n">scope_test</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In global scope:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>
</pre></div>
</div>
<p>예제 코드의 출력은 이렇게 된다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
</pre></div>
</div>
<p>어떻게 <em>지역</em> 대입이 (이것이 기본이다) <em>scope_test</em> 의 <em>spam</em> 연결을 바꾸지 않는지에 유의해야 한다. <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 대입은 <em>scope_test</em> 의 <em>spam</em> 연결을 바꾸고 <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 대입은 모듈 수준의 연결을 바꾼다.</p>
<p><a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 대입 전에는 <em>spam</em> 의 연결이 없다는 것도 볼 수 있다.</p>
</div>
</div>
<div class="section" id="a-first-look-at-classes">
<span id="tut-firstclasses"></span><h2>9.3. 클래스와의 첫 만남<a class="headerlink" href="#a-first-look-at-classes" title="永久链接至标题">¶</a></h2>
<p>클래스는 약간의 새 문법과 세 개의 객체형과 몇 가지 새 개념들을 도입한다.</p>
<div class="section" id="class-definition-syntax">
<span id="tut-classdefinition"></span><h3>9.3.1. 클래스 정의 문법<a class="headerlink" href="#class-definition-syntax" title="永久链接至标题">¶</a></h3>
<p>클래스 정의의 가장 간단한 형태는 이렇게 생겼다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ClassName</span><span class="p">:</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="n">N</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>함수 정의(<a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a> 문)처럼, 클래스 정의는 어떤 효과가 생기기 위해서는 먼저 실행되어야 한다. (상상컨대 클래스 정의를 <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 문의 분기나 함수 내부에 놓을 수 있다)</p>
<p>실재적으로, 클래스 정의 내부의 문장들은 보통 함수 정의들이지만, 다른 문장들도 허락되고 때로 쓸모가 있다 --- 나중에 이 주제로 돌아올 것이다. 클래스 내부의 함수 정의는 보통, 메서드 호출 규약의 영향을 받은, 특별한 형태의 인자 목록을 갖는다. --- 다시, 이것은 뒤에서 설명된다.</p>
<p>클래스 정의에 진입할 때, 새 이름 공간이 만들어지고 지역 스코프로 사용된다 --- 그래서, 모든 지역 변수들로의 대입은 이 새 이름 공간으로 간다. 특히, 함수 정의는 새 함수의 이름을 이곳에 연결한다.</p>
<p>클래스 정의가 (끝을 통해) 정상적으로 끝날 때, <em>클래스 객체</em> 가 만들어진다. 이것은 기본적으로 클래스 정의 때문에 만들어진 이름 공간의 내용물들을 감싸는 싸개다; 다음 섹션에서 클래스 객체에 대해 더 배우게 된다. 원래의 지역 스코프가 (클래스 정의에 들어가기 직전에 유효하던 것) 다시 사용되고, 클래스 객체는 클래스 정의 헤더에서 주어진 클래스 이름 (예에서 <code class="xref py py-class docutils literal notranslate"><span class="pre">ClassName</span></code>) 으로 여기에 연결된다.</p>
</div>
<div class="section" id="class-objects">
<span id="tut-classobjects"></span><h3>9.3.2. 클래스 객체<a class="headerlink" href="#class-objects" title="永久链接至标题">¶</a></h3>
<p>클래스 객체는 두 종류의 연산을 지원한다: 어트리뷰트 참조와 인스턴스 만들기.</p>
<p><em>어트리뷰트 참조</em> 는 파이썬의 모든 어트리뷰트 참조에 사용되는 표준 문법을 사용한다: <code class="docutils literal notranslate"><span class="pre">obj.name</span></code>. 올바른 어트리뷰트 이름은 클래스 객체가 만들어질 때 클래스의 이름 공간에 있던 모든 이름이다. 그래서, 클래스 정의가 이렇게 될 때:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A simple example class&quot;&quot;&quot;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">12345</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">MyClass.i</span></code> 와 <code class="docutils literal notranslate"><span class="pre">MyClass.f</span></code> 는 올바른 어트리뷰트 참조고, 각기 정수와 함수 객체를 돌려준다. 클래스 어트리뷰트는 대입할 수도 있어서, 대입을 통해 <code class="docutils literal notranslate"><span class="pre">MyClass.i</span></code> 의 값을 변경할 수 있다. <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 도 역시 올바른 어트리뷰트고, 클래스에 속하는 독스트링을 돌려준다: <code class="docutils literal notranslate"><span class="pre">&quot;A</span> <span class="pre">simple</span> <span class="pre">example</span> <span class="pre">class&quot;</span></code>.</p>
<p>클래스 <em>인스턴스 만들기</em> 는 함수 표기법을 사용한다. 클래스 객체가 클래스의 새 인스턴스를 돌려주는 파라미터 없는 함수인 체한다. 예를 들어 (위의 클래스를 가정하면):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</pre></div>
</div>
<p>는 클래스의 새 <em>인스턴스</em> 를 만들고 이 객체를 지역 변수 <code class="docutils literal notranslate"><span class="pre">x</span></code> 에 대입한다.</p>
<p>인스턴스 만들기 연산 (클래스 객체 &quot;호출하기&quot;) 은 빈 객체를 만든다. 많은 클래스는 특정한 초기 상태로 커스터마이즈된 인스턴스로 객체를 만드는 것을 좋아한다. 그래서 클래스는 이런 식으로 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 라는 이름의 특수 메서드 정의할 수 있다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
<p>클래스가 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드를 정의할 때, 클래스 인스턴스 만들기는 새로 만들어진 클래스 인스턴스에 대해 자동으로 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 를 호출한다. 그래서 이 예에서, 새 초기화된 인스턴스를 이렇게 얻을 수 있다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</pre></div>
</div>
<p>물론, <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드는 더 높은 유연성을 위해 인자들을 가질 수 있다. 그 경우, 클래스 인스턴스 만들기 연산자로 주어진 인자들은 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 로 전달된다. 예를 들어,</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Complex</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">realpart</span><span class="p">,</span> <span class="n">imagpart</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">realpart</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">imagpart</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">i</span>
<span class="go">(3.0, -4.5)</span>
</pre></div>
</div>
</div>
<div class="section" id="instance-objects">
<span id="tut-instanceobjects"></span><h3>9.3.3. 인스턴스 객체<a class="headerlink" href="#instance-objects" title="永久链接至标题">¶</a></h3>
<p>이제 인스턴스 객체로 무엇을 할 수 있을까? 인스턴스 객체가 이해하는 오직 한가지 연산은 어트리뷰트 참조다. 두 가지 종류의 올바른 어트리뷰트 이름이 있다, 데이터 어트리뷰트와 메서드.</p>
<p><em>데이터 어트리뷰트</em> 는 스몰토크의 &quot;인스턴스 변수&quot; 에, C++ 의 &quot;데이터 멤버&quot; 에 해당한다. 데이터 어트리뷰트는 선언될 필요 없다; 지역 변수처럼, 처음 대입될 때 태어난다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">x</span></code> 가 위에서 만들어진 <code class="xref py py-class docutils literal notranslate"><span class="pre">MyClass</span></code> 의 인스턴스면, 다음과 같은 코드 조각은 트레이스 없이 값 <code class="docutils literal notranslate"><span class="pre">16</span></code> 을 인쇄한다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
    <span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">*</span> <span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">counter</span><span class="p">)</span>
<span class="k">del</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span>
</pre></div>
</div>
<p>다른 인스턴스 어트리뷰트 참조는 <em>메서드</em> 다. 메서드는 객체에 &quot;속하는&quot; 함수다. (파이썬에서, 메서드 라는 용어는 클래스 인스턴스에만 사용되지 않는다; 다른 객체 형들도 메서드를 가질 수 있다. 예를 들어, 리스트 객체는 append, insert, remove, sort 등과 같은 메서드들을 갖는다. 하지만, 앞으로의 논의에서, 명시적으로 언급하지 않는 한, 메서드 라는 용어를 클래스 인스턴스 객체의 메서드에만 사용할 것이다.)</p>
<p id="index-0">인스턴스 객체의 올바른 메서드 이름은 그것의 클래스에 달려있다. 정의상, 함수 객체인 클래스의 모든 어트리뷰트들은 상응하는 인스턴스의 메서드들을 정의한다. 그래서 우리의 예제에서, <code class="docutils literal notranslate"><span class="pre">x.f</span></code> 는 올바른 메서드 참조인데, <code class="docutils literal notranslate"><span class="pre">MyClass.f</span></code> 가 함수이기 때문이다. 하지만 <code class="docutils literal notranslate"><span class="pre">x.i</span></code> 는 그렇지 않은데, <code class="docutils literal notranslate"><span class="pre">MyClass.i</span></code> 가 함수가 아니기 때문이다. 그러나, <code class="docutils literal notranslate"><span class="pre">x.f</span></code> 는 <code class="docutils literal notranslate"><span class="pre">MyClass.f</span></code> 와 같은 것이 아니다 --- 이것은 함수 객체가 아니라 <em>메서드 객체</em> 다.</p>
</div>
<div class="section" id="method-objects">
<span id="tut-methodobjects"></span><h3>9.3.4. 메서드 객체<a class="headerlink" href="#method-objects" title="永久链接至标题">¶</a></h3>
<p>보통, 메서드는 연결되자마자 호출된다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">MyClass</span></code> 예에서, 이것은 문자열 <code class="docutils literal notranslate"><span class="pre">'hello</span> <span class="pre">world'</span></code> 를 돌려준다. 하지만, 메서드를 즉시 호출할 필요는 없다: <code class="docutils literal notranslate"><span class="pre">x.f</span></code> 는 메서드 객체고, 저장된 후에 호출될 수 있다. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">xf</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">f</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">xf</span><span class="p">())</span>
</pre></div>
</div>
<p>는 영원히 계속 <code class="docutils literal notranslate"><span class="pre">hello</span> <span class="pre">world</span></code> 를 인쇄한다.</p>
<p>메서드가 호출될 때 정확히 어떤 일이 일어날까? <code class="xref py py-meth docutils literal notranslate"><span class="pre">f()</span></code> 의 함수 정의가 인자를 지정했음에도 불구하고, 위에서 <code class="docutils literal notranslate"><span class="pre">x.f()</span></code> 는 인자 없이 호출된 것을 알아챘을 것이다. 인자는 어떻게 된 걸까? 확실히 파이썬은 인자를 필요로 하는 함수를 인자 없이 호출하면 예외를 일으킨다 -- 인자가 실제로는 사용되지 않는다 해도...</p>
<p>실제로, 여러분은 답을 짐작할 수 있다: 메소드의 특별함은 인스턴스 객체가 함수의 첫 번째 인자로 전달된다는 것이다. 우리 예에서, 호출 <code class="docutils literal notranslate"><span class="pre">x.f()``은</span> <span class="pre">정확히</span> <span class="pre">``MyClass.f(x)</span></code> 와 동등하다. 일반적으로, <em>n</em> 개의 인자들의 목록으로 메서드를 호출하는 것은, 첫 번째 인자 앞에 메서드의 인스턴스 객체를 삽입해서 만든 인자 목록으로 상응하는 함수를 호출하는 것과 동등하다.</p>
<p>아직 메서드가 어떻게 동작하는지 이해하지 못했다면, 구현을 살펴보는 것이 아마도 문제를 분명하게 만들 수 있을 것이다. 데이터 어트리뷰트가 아닌 인스턴스 어트리뷰트를 참조하면, 그것의 클래스가 검색된다. 만약 그 이름이 함수 객체인 올바른 클래스 어트리뷰트면, 인스턴스 객체와 방금 발견된 함수 객체를 (가리키는 포인터들을) 추상 객체에 함께 묶어서 메서드 객체를 만든다: 이것이 메서드 객체다. 메서드 객체가 인자 목록으로 호출되면, 인스턴스 객체와 인자 목록으로부터 새 인자 목록이 구성된 후, 함수 객체를 이 새 인자 목록으로 호출한다.</p>
</div>
<div class="section" id="class-and-instance-variables">
<span id="tut-class-and-instance-variables"></span><h3>9.3.5. 클래스와 인스턴스 변수<a class="headerlink" href="#class-and-instance-variables" title="永久链接至标题">¶</a></h3>
<p>일반적으로 말해서, 인스턴스 변수는 인스턴스별 데이터를 위한 것이고 클래스 변수는 그 클래스의 모든 인스턴스에서 공유되는 어트리뷰트와 메서드를 위한 것이다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dog</span><span class="p">:</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;canine&#39;</span>         <span class="c1"># class variable shared by all instances</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>    <span class="c1"># instance variable unique to each instance</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Fido&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Buddy&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">kind</span>                  <span class="c1"># shared by all dogs</span>
<span class="s1">&#39;canine&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">kind</span>                  <span class="c1"># shared by all dogs</span>
<span class="s1">&#39;canine&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span>                  <span class="c1"># unique to d</span>
<span class="s1">&#39;Fido&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span>                  <span class="c1"># unique to e</span>
<span class="s1">&#39;Buddy&#39;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#tut-object"><span class="std std-ref">이름과 객체에 관한 한마디</span></a> 에서 논의했듯이, 리스트나 딕셔너리와 같은 <a class="reference internal" href="../glossary.html#term-mutable"><span class="xref std std-term">가변</span></a> 객체가 참여할 때 공유 데이터는 예상치 못한 효과를 줄 가능성이 있다. 예를 들어, 다음 코드에서 <em>tricks</em> 리스트는 클래스 변수로 사용되지 않아야 하는데, 하나의 리스트가 모든 <em>Dog</em> 인스턴스들에 공유되기 때문이다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dog</span><span class="p">:</span>

    <span class="n">tricks</span> <span class="o">=</span> <span class="p">[]</span>             <span class="c1"># mistaken use of a class variable</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">add_trick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trick</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tricks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trick</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Fido&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Buddy&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;roll over&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;play dead&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">tricks</span>                <span class="c1"># unexpectedly shared by all dogs</span>
<span class="p">[</span><span class="s1">&#39;roll over&#39;</span><span class="p">,</span> <span class="s1">&#39;play dead&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>대신, 클래스의 올바른 설계는 인스턴스 변수를 사용해야 한다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dog</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tricks</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># creates a new empty list for each dog</span>

    <span class="k">def</span> <span class="nf">add_trick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trick</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tricks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trick</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Fido&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Buddy&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;roll over&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;play dead&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">tricks</span>
<span class="p">[</span><span class="s1">&#39;roll over&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">tricks</span>
<span class="p">[</span><span class="s1">&#39;play dead&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="random-remarks">
<span id="tut-remarks"></span><h2>9.4. 기타 주의사항들<a class="headerlink" href="#random-remarks" title="永久链接至标题">¶</a></h2>
<p>데이터 어트리뷰트는 같은 이름의 메서드 어트리뷰트를 덮어쓴다; 의도하지 않은 이름 충돌을 피하려면, 큰 프로그램에서 찾기 어려운 버그를 만든다, 충돌의 기회를 최소화하는 어떤 종류의 규칙을 사용하는 것이 현명하다. 가능한 규칙에는 메서드 이름을 대문자로 시작하는 것, 데이터 어트리뷰트의 이름에 작고 특별한 문자열 (아마도 밑줄 하나)을 앞에 붙이는 것, 메서드에는 동사를 데이터 어트리뷰트에는 명사를 쓰는 것들이 있다.</p>
<p>데이터 어트리뷰트는 메서드 뿐만 아니라 객체의 일반적인 사용자 (&quot;클라이언트&quot;)에 의해서 참조될 수도 있다. 달리 표현하면, 클래스는 순수하게 추상적인 데이터형을 구현하는데 사용될 수 없다. 사실, 파이썬에서는 데이터 은닉을 강제할 방법이 없다 --- 모두 관례에 의존한다. (반면에, C로 작성된 파이썬 구현은 필요하다면 구현 상세를 완전히 숨기고 객체에 대한 액세스를 제어할 수 있다; 이것은 C로 작성된 파이썬 확장에서 사용될 수 있다.)</p>
<p>클라이언트는 데이터 어트리뷰트를 조심스럽게 사용해야 한다 --- 클라이언트는 데이터 어트리뷰트를 건드려서 메서드들에 의해 유지되는 불변성 들을 망가뜨릴 수 있다. 클라이언트는 이름 충돌을 피하는 한 메서드들의 유효성을 손상하지 않고도 그들 자신의 데이터 어트리뷰트를 인스턴스 객체에 추가할 수도 있음에 유의해야 한다 --- 다시 한번, 명명 규칙은 여러 골칫거리를 피할 수 있게 한다.</p>
<p>메서드 안에서 데이터 어트리뷰트들 (또는 다른 메서드들!) 을 참조하는 줄임 표현은 없다. 나는 이것이 실제로 메서드의 가독성을 높인다는 것을 알게 되었다: 메서드를 훑어볼 때 지역 변수와 인스턴스 변수를 혼동할 우려가 없다.</p>
<p>종종, 메서드의 첫 번째 인자는 <code class="docutils literal notranslate"><span class="pre">self</span></code> 라고 불린다. 이것은 관례일 뿐이다: 이름 <code class="docutils literal notranslate"><span class="pre">self</span></code> 는 파이썬에서 아무런 특별한 의미를 갖지 않는다. 하지만, 이 규칙을 따르지 않을 때 여러분의 코드가 다른 파이썬 프로그래머들이 읽기에 불편하고, <em>클래스 브라우저</em> 프로그램도 이런 규칙에 의존하도록 작성되었다고 상상할 수 있음에 유의하기 바란다.</p>
<p>클래스 어트리뷰트인 모든 함수는 그 클래스의 인스턴스들을 위한 메서드를 정의한다. 함수 정의가 클래스 정의에 텍스트 적으로 둘러싸일 필요는 없다: 함수 객체를 클래스의 지역 변수로 대입하는 것 역시 가능하다. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Function defined outside the class</span>
<span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">f1</span>

    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">g</span>
</pre></div>
</div>
<p>이제 <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code>, <code class="docutils literal notranslate"><span class="pre">h</span></code> 는 모두 함수 객체를 가리키는 클래스 <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 의 어트리뷰트고, 결과적으로 이것들은 모두 <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 의 인스턴스들의 메서드다 --- <code class="docutils literal notranslate"><span class="pre">h</span></code> 는 정확히 <code class="docutils literal notranslate"><span class="pre">g</span></code> 와 동등하다. 이런 방식은 프로그램의 독자들에게 혼란을 주기만 한다는 점에 주의해야 한다.</p>
<p>메서드는 <code class="docutils literal notranslate"><span class="pre">self</span></code> 인자의 메서드 어트리뷰트를 사용해서 다른 메서드를 호출할 수 있다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Bag</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">addtwice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>메서드는 일반 함수들과 마찬가지로 전역 이름을 참조할 수 있다. 메서드에 결합한 전역 스코프는 그것의 정의를 포함하는 모듈이다. (클래스는 결코 전역 스코프로 사용되지 않는다.) 메서드에서 전역 데이터를 사용할 좋은 이유를 거의 만나지 못하지만, 전역 스코프를 정당하게 사용하는 여러 가지 경우가 있다: 한가지는, 전역 스코프에 정의된 함수와 메서드 뿐만 아니라, 그곳에 임포트된 함수와 모듈도 메서드가 사용할 수 있다는 것이다. 보통, 메서드를 포함하는 클래스 자신은 이 전역 스코프에 정의되고, 다음 섹션에서 메서드가 자신의 클래스를 참조하길 원하는 몇 가지 좋은 이유를 보게 될 것이다.</p>
<p>각 값은 객체고, 그러므로 <em>클래스</em> (<em>형</em> 이라고도 불린다) 를 갖는다. 이것은 <code class="docutils literal notranslate"><span class="pre">object.__class__</span></code> 에 저장되어 있다.</p>
</div>
<div class="section" id="inheritance">
<span id="tut-inheritance"></span><h2>9.5. 상속<a class="headerlink" href="#inheritance" title="永久链接至标题">¶</a></h2>
<p>물론, 상속을 지원하지 않는다면 언어 기능은 &quot;클래스&quot;라는 이름을 붙일만한 가치가 없을 것이다. 파생 클래스 정의의 문법은 이렇게 생겼다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DerivedClassName</span><span class="p">(</span><span class="n">BaseClassName</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="n">N</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>이름 <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseClassName</span></code> 은 파생 클래스 정의를 포함하는 스코프에 정의되어 있어야 한다. 베이스 클래스 이름의 자리에 다른 임의의 표현식도 허락된다. 예를 들어, 베이스 클래스가 다른 모듈에 정의되어 있을 때 유용하다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DerivedClassName</span><span class="p">(</span><span class="n">modname</span><span class="o">.</span><span class="n">BaseClassName</span><span class="p">):</span>
</pre></div>
</div>
<p>파생 클래스 정의의 실행은 베이스 클래스와 같은 방식으로 진행된다. 클래스 객체가 만들어질 때, 베이스 클래스가 기억된다. 이것은 어트리뷰트 참조를 결정할 때 사용된다: 요청된 어트리뷰트가 클래스에서 발견되지 않으면 베이스 클래스로 검색을 확장한다. 베이스 클래스 또한 다른 클래스로부터 파생되었다면 이 규칙은 재귀적으로 적용된다.</p>
<p>파생 클래스의 인스턴스 만들기에 특별한 것은 없다: <code class="docutils literal notranslate"><span class="pre">DerivedClassName()</span></code> 는 그 클래스의 새 인스턴스를 만든다. 메서드 참조는 다음과 같이 결정된다: 대응하는 클래스 어트리뷰트가 검색되는데, 필요하면 베이스 클래스의 연쇄를 타고 내려간다. 이것이 함수 객체를 준다면 메서드 참조는 올바르다.</p>
<p>파생 클래스는 베이스 클래스의 메서드들을 재정의할 수 있다. 메서드가 같은 객체의 다른 메서드를 호출할 때 특별한 권한 같은 것은 없으므로, 베이스 클래스에 정의된 다른 메서드를 호출하는 베이스 클래스의 메서드는 재정의된 파생 클래스의 메서드를 호출하게 된다. (C++ 프로그래머를 위한 표현으로: 파이썬의 모든 메서드는 실질적으로 <code class="docutils literal notranslate"><span class="pre">virtual</span></code> 이다.)</p>
<p>파생 클래스에서 재정의된 메서드가, 같은 이름의 베이스 클래스 메서드를 단순히 갈아치우기보다 사실은 확장하고 싶을 수 있다. 베이스 클래스의 메서드를 직접 호출하는 간단한 방법이 있다: 단지 <code class="docutils literal notranslate"><span class="pre">BaseClassName.methodname(self,</span> <span class="pre">arguments)</span></code> 를 호출하면 된다. 이것은 때로 클라이언트에게도 쓸모가 있다. (이것은 베이스 클래스가 전역 스코프에서 <code class="docutils literal notranslate"><span class="pre">BaseClassName</span></code> 으로 액세스 될 수 있을 때만 동작함에 주의해야 한다.)</p>
<p>파이썬에는 상속과 함께 사용할 수 있는 두 개의 내장 함수가 있다:</p>
<ul class="simple">
<li>인스턴스의 형을 검사하려면 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 를 사용한다: <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">int)</span></code> 는 <code class="docutils literal notranslate"><span class="pre">obj.__class__</span></code> 가 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 거나 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 에서 파생된 클래스인 경우만 <code class="docutils literal notranslate"><span class="pre">True</span></code> 가 된다.</li>
<li>클래스 상속을 검사하려면 <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 를 사용한다: <code class="docutils literal notranslate"><span class="pre">issubclass(bool,</span> <span class="pre">int)</span></code> 는 <code class="docutils literal notranslate"><span class="pre">True</span></code> 인데, <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> 이 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 의 서브 클래스이기 때문이다. 하지만, <code class="docutils literal notranslate"><span class="pre">issubclass(float,</span> <span class="pre">int)</span></code> 는 <code class="docutils literal notranslate"><span class="pre">False</span></code> 인데, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 는 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 의 서브 클래스가 아니기 때문이다.</li>
</ul>
<div class="section" id="multiple-inheritance">
<span id="tut-multiple"></span><h3>9.5.1. 다중 상속<a class="headerlink" href="#multiple-inheritance" title="永久链接至标题">¶</a></h3>
<p>파이썬은 다중 상속의 형태도 지원한다. 여러 개의 베이스 클래스를 갖는 클래스 정의는 이런 식이다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DerivedClassName</span><span class="p">(</span><span class="n">Base1</span><span class="p">,</span> <span class="n">Base2</span><span class="p">,</span> <span class="n">Base3</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="n">N</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>대부분의 목적상, 가장 간단한 경우에, 부모 클래스로부터 상속된 어트리뷰트들의 검색을 깊이 우선으로, 왼쪽에서 오른쪽으로, 계층 구조에서 겹치는 같은 클래스를 두 번 검색하지 않는 것으로 생각할 수 있다. 그래서, 어트리뷰트가 <code class="xref py py-class docutils literal notranslate"><span class="pre">DerivedClassName</span></code> 에서 발견되지 않으면, <code class="xref py py-class docutils literal notranslate"><span class="pre">Base1</span></code> 에서 찾고, 그다음 (재귀적으로) <code class="xref py py-class docutils literal notranslate"><span class="pre">Base1</span></code> 의 베이스 클래스들을 검색한다. 거기에서도 발견되지 않으면, <code class="xref py py-class docutils literal notranslate"><span class="pre">Base2</span></code> 에서 찾고, 이런 식으로 계속한다.</p>
<p>사실, 이것보다는 약간 더 복잡하다; 메서드 결정 순서는 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 로의 협력적인 호출을 지원하기 위해 동적으로 변경된다. 이 접근법은 몇몇 다른 다중 상속 언어들에서 call-next-method 라고 알려져 있고, 단일 상속 언어들에서 발견되는 super 호출보다 더 강력하다.</p>
<p>동적인 순서가 필요한 이유는 모든 다중 상속의 경우는 하나나 그 이상의 다이아몬드 관계 (적어도 부모 클래스 중 하나가 가장 바닥 클래스들로부터 여러 경로를 통해 액세스 되는 경우) 를 만들기 때문이다. 예를 들어, 모든 클래스는 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 를 계승하기 때문에, 모든 다중 상속은 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 에 이르는 여러 경로를 제공한다. 베이스 클래스들이 여러 번 액세스 되지 않게 하려고, 동적인 알고리즘이 검색 순서를 선형화하는데, 각 클래스에서 지정된 왼쪽에서 오른쪽으로 가는 순서를 보존하고, 각 부모를 오직 한 번만 호출하고, 단조적 (부모들의 우선순위에 영향을 주지 않으면서 서브 클래스를 만들 수 있다는 의미다) 이도록 만든다. 모두 함께 사용될 때, 이 성질들은 다중 상속으로 신뢰성 있고 확장성 있는 클래스들을 설계할 수 있도록 만든다. 더 자세한 내용은, <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a> 에 있다.</p>
</div>
</div>
<div class="section" id="private-variables">
<span id="tut-private"></span><h2>9.6. 비공개 변수<a class="headerlink" href="#private-variables" title="永久链接至标题">¶</a></h2>
<p>객체 내부에서만 액세스할 수 있는 &quot;비공개&quot; 인스턴스 변수는 파이썬에 존재하지 않는다. 하지만, 대부분의 파이썬 코드에서 따르고 있는 규약이 있다: 밑줄로 시작하는 이름은 (예를 들어, <code class="docutils literal notranslate"><span class="pre">_spam</span></code>) API의 공개적이지 않은 부분으로 취급되어야 한다 (그것이 함수, 메서드, 데이터 멤버중 무엇이건 간에). 구현 상세이고 통보 없이 변경되는 대상으로 취급되어야 한다.</p>
<p>클래스-비공개 멤버들의 올바른 사례가 있으므로 (즉 서브 클래스에서 정의된 이름들과의 충돌을 피하고자), <em class="dfn">이름 뒤섞기 (name mangling)</em> 라고 불리는 메커니즘에 대한 제한된 지원이 있다. <code class="docutils literal notranslate"><span class="pre">__spam</span></code> 형태의 (최소 두 개의 밑줄로 시작하고, 최대 한 개의 밑줄로 끝난다) 모든 식별자는 <code class="docutils literal notranslate"><span class="pre">_classname__spam</span></code> 로 텍스트 적으로 치환되는데, <code class="docutils literal notranslate"><span class="pre">classname</span></code> 은 현재 클래스 이름에서 앞에 오는 밑줄을 제거한 것이다. 이 뒤섞기는 클래스 정의에 등장하는 이상, 식별자의 문법적 위치와 무관하게 수행된다.</p>
<p>이름 뒤섞기는 클래스 내부의 메서드 호출을 방해하지 않고 서브 클래스들이 메서드를 재정의할 수 있도록 하는 데 도움을 준다. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mapping</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__update</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">items_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="n">__update</span> <span class="o">=</span> <span class="n">update</span>   <span class="c1"># private copy of original update() method</span>

<span class="k">class</span> <span class="nc">MappingSubclass</span><span class="p">(</span><span class="n">Mapping</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># provides new signature for update()</span>
        <span class="c1"># but does not break __init__()</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">items_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</pre></div>
</div>
<p>뒤섞기 규칙은 대체로 사고를 피하고자 설계되었다는 것에 주의해야 한다; 여전히 비공개로 취급되는 변수들을 액세스하거나 수정할 수 있다. 이것은 디버거와 같은 특별한 상황에서 쓸모 있기조차 하다.</p>
<p><code class="docutils literal notranslate"><span class="pre">exec()</span></code> 나 <code class="docutils literal notranslate"><span class="pre">eval()</span></code> 로 전달된 코드는 호출하는 클래스의 클래스 이름을 현재 클래스로 여기지 않는다는 것에 주의하라; 이것은 <code class="docutils literal notranslate"><span class="pre">global</span></code> 문의 효과와 유사한데, 효과가 함께 바이트-컴파일된 코드로 제한된다. 같은 제약이 <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> 를 직접 참조할 때뿐만 아니라, <code class="docutils literal notranslate"><span class="pre">getattr()</span></code>, <code class="docutils literal notranslate"><span class="pre">setattr()</span></code>, <code class="docutils literal notranslate"><span class="pre">delattr()</span></code> 에도 적용된다.</p>
</div>
<div class="section" id="odds-and-ends">
<span id="tut-odds"></span><h2>9.7. 잡동사니<a class="headerlink" href="#odds-and-ends" title="永久链接至标题">¶</a></h2>
<p>때로 몇몇 이름 붙은 데이터 항목들을 함께 묶어주는 파스칼의 &quot;record&quot; 나 C의 &quot;struct&quot; 와 유사한 데이터형을 갖는 것이 쓸모 있다. 빈 클래스 정의가 훌륭히 할 수 있는 일이다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="n">john</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">()</span>  <span class="c1"># Create an empty employee record</span>

<span class="c1"># Fill the fields of the record</span>
<span class="n">john</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;John Doe&#39;</span>
<span class="n">john</span><span class="o">.</span><span class="n">dept</span> <span class="o">=</span> <span class="s1">&#39;computer lab&#39;</span>
<span class="n">john</span><span class="o">.</span><span class="n">salary</span> <span class="o">=</span> <span class="mi">1000</span>
</pre></div>
</div>
<p>특정한 추상적인 데이터형을 기대하는 파이썬 코드 조각은, 종종 그 데이터형의 메서드를 흉내 내는 클래스를 대신 전달받을 수 있다. 예를 들어, 파일 객체로부터 데이터를 포맷하는 함수가 있을 때, 대신 문자열 버퍼에서 데이터를 읽는 메서드 <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> 와 <code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code> 을 제공하는 클래스를 정의한 후 인자로 전달할 수 있다.</p>
<p>인스턴스 메서드 객체도 어트리뷰트를 갖는다: <code class="docutils literal notranslate"><span class="pre">m.__self__</span></code> 는 메서드 <code class="xref py py-meth docutils literal notranslate"><span class="pre">m()</span></code> 과 결합한 인스턴스 객체이고, <code class="docutils literal notranslate"><span class="pre">m.__func__</span></code> 는 메서드에 상응하는 함수 객체다.</p>
</div>
<div class="section" id="iterators">
<span id="tut-iterators"></span><h2>9.8. 이터레이터<a class="headerlink" href="#iterators" title="永久链接至标题">¶</a></h2>
<p>지금쯤 아마도 여러분은 대부분의 컨테이너 객체들을 <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 문으로 루핑할 수 있음을 눈치챘을 것이다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;one&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="s2">&quot;123&quot;</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;myfile.txt&quot;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>이런 스타일의 액세스는 명료하고, 간결하고, 편리하다. 이터레이터를 사용하면 파이썬이 보편화하고 통합된다. 무대 뒤에서, <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 문은 컨테이너 객체에 대해 <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 를 호출한다. 이 함수는 메서드 <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 를 정의하는 이터레이터 객체를 돌려주는데, 이 메서드는 컨테이너의 요소들을 한 번에 하나씩 액세스한다. 남은 요소가 없으면, <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 는 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 예외를 일으켜서 <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 루프에 종료를 알린다. <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 내장 함수를 사용해서 <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 메서드를 호출할 수 있다; 이 예는 이 모든 것들이 어떻게 동작하는지 보여준다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span>
<span class="go">&lt;iterator object at 0x00A1DB50&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&#39;c&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
    <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p>이터레이터 프로토콜의 뒤에 있는 메커니즘을 살펴보면, 여러분의 클래스에 이터레이터 동작을 쉽게 추가할 수 있다. <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 메서드를 가진 객체를 돌려주는 <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 메서드를 정의한다. 클래스가 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code> 를 정의하면, <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 는 그냥 <code class="docutils literal notranslate"><span class="pre">self</span></code> 를 돌려줄 수 있다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Reverse</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Iterator for looping over a sequence backwards.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rev</span> <span class="o">=</span> <span class="n">Reverse</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">iter</span><span class="p">(</span><span class="n">rev</span><span class="p">)</span>
<span class="go">&lt;__main__.Reverse object at 0x00A1DB50&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">rev</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">m</span>
<span class="go">a</span>
<span class="go">p</span>
<span class="go">s</span>
</pre></div>
</div>
</div>
<div class="section" id="generators">
<span id="tut-generators"></span><h2>9.9. 제너레이터<a class="headerlink" href="#generators" title="永久链接至标题">¶</a></h2>
<p><a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a> 는 이터레이터를 만드는 간단하고 강력한 도구다. 일반적인 함수처럼 작성되지만 값을 돌려주고 싶을 때마다 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 문을 사용한다. 제너레이터에 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 가 호출될 때마다, 제너레이터는 떠난 곳에서 실행을 재개한다 (모든 데이터 값들과 어떤 문장이 마지막으로 실행되었는지 기억한다). 예는 제너레이터를 사소할 정도로 쉽게 만들 수 있음을 보여준다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">reverse</span><span class="p">(</span><span class="s1">&#39;golf&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">f</span>
<span class="go">l</span>
<span class="go">o</span>
<span class="go">g</span>
</pre></div>
</div>
<p>제너레이터로 할 수 있는 모든 것은 앞 절에서 설명했듯이 클래스 기반 이터레이터로도 할 수 있다. 제너레이터가 간단한 이유는 <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 와 <a class="reference internal" href="../reference/expressions.html#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 메서드가 저절로 만들어지기 때문이다.</p>
<p>또 하나의 주요 기능은 지연 변수들과 실행 상태가 호출 간에 자동으로 보관된다는 것이다. 이것은 <code class="docutils literal notranslate"><span class="pre">self.index</span></code> 나 <code class="docutils literal notranslate"><span class="pre">self.data</span></code> 와 같은 인스턴스 변수를 사용하는 접근법에 비교해 함수를 쓰기 쉽고 명료하게 만든다.</p>
<p>자동 메서드 생성과 프로그램 상태의 저장에 더해, 제너레이터가 종료할 때 자동으로 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 을 일으킨다. 조합하면, 이 기능들이 일반 함수를 작성하는 것만큼 이터레이터를 만들기 쉽게 만든다.</p>
</div>
<div class="section" id="generator-expressions">
<span id="tut-genexps"></span><h2>9.10. 제너레이터 표현식<a class="headerlink" href="#generator-expressions" title="永久链接至标题">¶</a></h2>
<p>Some simple generators can be coded succinctly as expressions using a syntax
similar to list comprehensions but with parentheses instead of square brackets.
These expressions are designed for situations where the generator is used right
away by an enclosing function.  Generator expressions are more compact but less
versatile than full generator definitions and tend to be more memory friendly
than equivalent list comprehensions.</p>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>                 <span class="c1"># sum of squares</span>
<span class="go">285</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">xvec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yvec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xvec</span><span class="p">,</span> <span class="n">yvec</span><span class="p">))</span>         <span class="c1"># dot product</span>
<span class="go">260</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sine_table</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">91</span><span class="p">)}</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">unique_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">word</span>  <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">page</span>  <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">valedictorian</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">student</span><span class="o">.</span><span class="n">gpa</span><span class="p">,</span> <span class="n">student</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">student</span> <span class="ow">in</span> <span class="n">graduates</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;golf&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[&#39;f&#39;, &#39;l&#39;, &#39;o&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
<p class="rubric">각주</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>한 가지만 제외하고. 모듈 객체는 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 라고 불리는 비밀스러운 읽기 전용 어트리뷰트를 갖는데, 모듈의 이름 공간을 구현하는데 사용하는 딕셔너리를 돌려준다; 이름 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 는 어트리뷰트 이지만 전역 이름은 아니다. 명백하게, 이것을 사용하는 것은 이름 공간 구현의 추상화를 파괴하는 것이고, 사후 디버거와 같은 것들로만 제한되어야 한다.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">9. 클래스</a><ul>
<li><a class="reference internal" href="#a-word-about-names-and-objects">9.1. 이름과 객체에 관한 한마디</a></li>
<li><a class="reference internal" href="#python-scopes-and-namespaces">9.2. 파이썬 스코프와 이름 공간</a><ul>
<li><a class="reference internal" href="#scopes-and-namespaces-example">9.2.1. 스코프와 이름 공간 예</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-first-look-at-classes">9.3. 클래스와의 첫 만남</a><ul>
<li><a class="reference internal" href="#class-definition-syntax">9.3.1. 클래스 정의 문법</a></li>
<li><a class="reference internal" href="#class-objects">9.3.2. 클래스 객체</a></li>
<li><a class="reference internal" href="#instance-objects">9.3.3. 인스턴스 객체</a></li>
<li><a class="reference internal" href="#method-objects">9.3.4. 메서드 객체</a></li>
<li><a class="reference internal" href="#class-and-instance-variables">9.3.5. 클래스와 인스턴스 변수</a></li>
</ul>
</li>
<li><a class="reference internal" href="#random-remarks">9.4. 기타 주의사항들</a></li>
<li><a class="reference internal" href="#inheritance">9.5. 상속</a><ul>
<li><a class="reference internal" href="#multiple-inheritance">9.5.1. 다중 상속</a></li>
</ul>
</li>
<li><a class="reference internal" href="#private-variables">9.6. 비공개 변수</a></li>
<li><a class="reference internal" href="#odds-and-ends">9.7. 잡동사니</a></li>
<li><a class="reference internal" href="#iterators">9.8. 이터레이터</a></li>
<li><a class="reference internal" href="#generators">9.9. 제너레이터</a></li>
<li><a class="reference internal" href="#generator-expressions">9.10. 제너레이터 표현식</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="errors.html"
                        title="上一章">8. 에러와 예외</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="stdlib.html"
                        title="下一章">10. 표준 라이브러리 둘러보기</a></p>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/tutorial/classes.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="stdlib.html" title="10. 표준 라이브러리 둘러보기"
             >下一页</a> |</li>
        <li class="right" >
          <a href="errors.html" title="8. 에러와 예외"
             >上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh</span>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">도큐멘테이션 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >测试python入门教程</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    파이썬 소프트웨어 재단은 비영리 법인입니다.
    <a href="https://www.python.org/psf/donations/">기부를 부탁합니다.</a>
    <br />
    4月 21, 2018 에 마지막으로 업데이트되었습니다.
    <a href="../bugs.html">버그를 찾았나요?</a>
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.7.2 를 사용해서 만들었습니다.
    </div>

  </body>
</html>